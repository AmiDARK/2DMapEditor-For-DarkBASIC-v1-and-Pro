Rem ***************************************************************************
Rem *                                                                         *
Rem * 33333 DDDD  M   M  AAA  PPPP        EEEEE DDDD  IIIII TTTTT  OOO  RRRR  *
Rem *     3 D   D MM MM A   A P   P       E   E D   D   I   T T T O   O R   R *
Rem *   33  D   D M M M AAAAA PPPP  ----- EEE   D   D   I     T   O   O RRRR  *
Rem *     3 D   D M   M A   A P           E   E D   D   I     T   O   O R R   *
Rem * 3333  DDDD  M   M A   A P           EEEEE DDDD  IIIII   T    OOO  R  R  *
Rem *                                                                         *
Rem ***************************************************************************
Rem Version/Revision  : 2.40dbp
Rem Date              : 27.08.08
Rem Auteur            : Frédéric Cordier
Rem Map Ver/Rev       : 1.12
Rem
_Ver$="Ver 2.40(27.08.08)"
Rem                                                                  ********************************************
Rem                                                                   **
Rem                                                                     ***
Rem ************************************************************************ COMMENTAIRES / MISES à JOUR .
Rem ****************************************************************************
Rem Adaptation des fonctions vers Magic-Windows :
Rem ---------------------------------------------
Rem Files patchées pour Magic-Windows :
Rem _editor_language_functions.dba       Ok!
Rem _editor_synchro_functions.dba        PATCHED !
Rem _editor_objects_functions.dba        PATCHED ! 100% Real-Time : Objects-Properties
Rem _editor_miscellaneous_functions.dba  Ok!
Rem _editor_fileselector_function.dba    PATCHED !
Rem _editor_zones_functions.dba          Ok!
Rem _menuv2_functions.dba                Ok!
Rem _editor_matrix_functions.dba         PATCHED ! 100% Real-Time : Matrixes-Properties
Rem _user_collision_system.dba           Ok!
Rem _MW_functions.dba                    SYSTEM !
Rem _3DMe_Magic_Windows.dba              Ok!
Rem _MAIN_PROGRAM_FILE.dba               PATCHED !

Rem
Rem STILL TO DO :
Rem -------------
REM MATRICES :
REM - fonction "Matrix Terrain" ( fonction inactive en ver 2.30 )
REM - fonction "Matrix Noise" ( fonction inactive en ver 2.30 )
Rem - Matrix WATER slow-motion
REM OBJETS 3D :
REM - amélioration du système de scaling de texture sur les objets :
Rem                                    MODE AUTO-SCALING / NO SCALINGS / MANUAL SCALING
REM - déplacement d'un membre d'un objet
REM - rotation d'un membre d'un objet
REM - texturage d'un membre d'un objet
REM ZONES D'ACTION :
REM - nouvelle zone d'action " Zone de pluie - particules emulation "
REM - nouvelle zone d'action " Zone de neige - particules emulation "
REM - nouvelle zone d'action " Zone de feu - particules emulation - Objet 3D "
REM SONS 3D :
REM - Panneau de configuration pour les sons 3D ( replay , delay , etc . . . )
REM SOURCES LUMINEUSES :
REM - Panneau de configuration pour les lumières ( point light , lights effects )
REM - Effets lumineux surprises ( stroboscopes , variables , torche , etc . . . )
REM - Sélection des lumières
REM DIVERS :
REM - Simplification du système d'utilisation des .maps de 3DMe
REM - Aide " Build IN "
REM - Aide " Iconographique " ( doc détaillée dans le logiciel sur les icones )
REM EDITOR :
REM - Changement de résolution d'écran
REM - Mode fenétré
Rem - Project Manager : Permettra de sauver une carte ainsi que tout les fichiers nécessaires dans 1 dossier.
Rem - Textures pack : sélection d'un pack de texture dans une liste , puis d'une texture dans un pack.
Rem - Objects Pack : Sélection d'un pack d'objets 3D dans une liste , puis d'1 objet précis pour l'ajouter.

Rem ****************************************************************************
Rem 20.12.02 / Ver 2.31
Rem   - Mise en place de Magic-Windows et des systèmes de fenêtres
Rem   - Fix du pas de rotation par défaut à 45° .
Rem   - Sauvegarde des positions des fenêtres pour chargement en début d'utilisation.
Rem   - Icones sélectionnés en Surbrillance.
Rem   - Mode De texturage augmenté. ( mode AUTO-SCALING / SCALING )
Rem   - Fix du bug de la barre de menu qui fait clignoter les fenêtres.
Rem ****************************************************************************
Rem 20.11.02 / Ver 2.30
Rem   - Fix d'un bug sur le Skin par défaut si le fichier est effacé.
Rem   - Fix d'un bug dans la lumière ambiante après chargement d'une map.
Rem   - Mise en place du système de menus Ver2.00+.
Rem   - Mise en place des commentaires dans la sélection des options de menus.
Rem   - Mise en place du nouveau SKIN editeur 100%
Rem   - Mise en place du système de matrices 3DGC complet + collisions dans le mode démo .
Rem   - ( Map revision 1.12 : Gestion des matrices ) .
Rem ****************************************************************************
Rem 07.07.02 / Ver 2.29
Rem   - Fix du flash pendant le file selecteur pour charger les maps.
Rem   - Ajout des menus déroulants 1,2,3 et 4.
Rem   - Fix d'un bug dans le chargement de nouveaux sons 3D.
Rem   - Fix pour utiliser les valeurs définies de la couleur Ambiante
Rem   - Mise en place de SKINS pour customiser l'éditeur ! ( changer le look graphique de l'éditeur )
Rem   - Ajout des fonctions :
Rem          _Create_Zone / _Move_Zone / _Scale_Zone / _Refresh_Zone / _Select_Zone / _Kill_Zone / _Zone_Properties
Rem   - Les zones sont sauvegardées et chargés des fichiers map.
Rem   - Les zones sont cachés dans la démo.
Rem   - Les utilisateurs non-enregistrés ne pourront créer qu'un maximum de 16 zones ( au lieu de 256 )
Rem   - Zone 0 à 6 prêtes à 100%
Rem   - Mise en place du scaling de texture pour des valeur de 0.01 à 0.99 par pas de 0.01 minimum.
Rem   - Optimisation du code source de l'éditeur utilisant maintenant des "Fonctions" au lieu de "sous-programmes"
Rem   - L'éditeur accepte les chemins de dossier relatifs dans le fichier 3DMapEdit.cfg
Rem ****************************************************************************
Rem 13.06.02 / Ver 2.28
Rem   - Fix du QUIT de l'éditeur , maintenant , tout est éffacé correctement.
Rem ****************************************************************************
Rem 06.06.02 / Ver 2.27 Beta r1
Rem   - Ajout d'une nouvelle fonction : OBJET CACHE
Rem   - Ajout d'une nouvelle fonction : COLLISION D'OBJET.
Rem   - Changement : Mode preview est maintenant un mode exploration 3D complet ( démo jouable )
Rem   - Fix des bugs d'affichage des sprites de la souris et des cases de sélection.
Rem ****************************************************************************
Rem 11.05.02 / Ver 2.26 Beta r1
Rem   - Rajout de la fonction de sélection d'objet 3D DirectX.
Rem   - Rajout de la fonction de sélection d'un son 3D.
Rem   - Fix d'un bug dans le file-loader sur les filtres de fichiers.
Rem   - L'éditeur n'utilise plus la mémoire vidéo et la compression de texture.(options à activer dans le fichier 3DMAPEDIT.CFG)
Rem   - Fix d'un bug qui empechait de charger les cartes dans le dossier "tutorials_maps"
Rem   - Création d'une fonction de WaitSynchro pour toutes les routines ( avec mouvements de la souris )
Rem   - Fix du bug de la camera lorsqu'on ajoute un objet 3D DirectX.
Rem   - Matrice de calage evoluée
Rem ****************************************************************************
Rem 25.04.02 - 26.04.02 / Ver 2.25
Rem   - Finition de la routine de _Kill Texture ( ajout des aperçus de textures + utilisation de chaque texture )
Rem   - Nouvelle fonction routine _Kill_DirectXObject ( copie de _Kill_Texture mais pour les objets directX )
Rem   - le code source de 3DMapEditor dépasse les 3000 lignes !!!!
Rem   - Nouvelle fonction routine _Kill_3DSound !!! ( copie de _Kill_DirectXObject ) NON TESTEE !!!
Rem   - Fix d'un bug : lorsque l'on effaçais unt object 3DSOUND , le son restait . Fixé.
Rem   - Protection des routines contre les appels inutiles.
Rem   - Ajout du support pour l'affichage dans le file-selector des SNAPSHOTS-MINIATURES des cartes
Rem   - Toutes les fonction quittables par la barre d'espace le sont aussi par le bouton droit de la souris.
Rem   - Les objets 3D du type 3DS sont gérés.
Rem ****************************************************************************
Rem 24.04.02 / Ver 2.24
Rem   - Mise en place de la gestion des attributs WIREFRAME,TRANSPARENCY,CULL,FILTER,LIGHT,FOG,AMBIENT
Rem   - Mise en place de l'aperçu rapide et information de format de textures dans le file-selector.
Rem   - Nouvelle organisation de l'interface de l'éditeur.
Rem   - Nouvelle fonction : Destruction d'une texture de la liste.
Rem   - modification des raccourcis clavier
Rem ****************************************************************************
Rem 15.04.02 / Ver 2.22
Rem   - Mise en place de mon file selector pour le chargement de cartes 3D ( inspiré de celui de Dobro ).
Rem   - Idem pour le chargement de textures et des sons 3D
Rem   - Mise en place des dossiers de travail MAPS / TEXTURES / OBJECTS_LIBRARY / 3DSOUND.
Rem   - Rectification d'un bug qui mettait tout en noir apres chargement de carte.
Rem ****************************************************************************
Rem 12.04.02 / Ver 2.21
Rem   - Les lampes sont vues comme des lampes en object 3D transparent ( DirectX object )
Rem   - Optimisations des créations des objets ( interne à l'éditeur )
Rem   - Chargement et mise en place de sons 3D. ( vus comme une note musicale )
Rem   - Maintenant langages sont 100% selon la sélection.
Rem   - Les Sons 3D sont sauvés et chargés dans les maps.
Rem   - Ré-organisation de la position des routines de l'éditeur. ( optimisations )
Rem ****************************************************************************
Rem 10.04.02 / Ver 2.20
Rem   - Correction d'un bug qui faisait doubler le dernier objet après effacement d'objets.
Rem   - Ajout de la fonction d'optimisation des objets 3D par rapport aux distances respectives.
Rem ****************************************************************************
Rem 08.04.02 / Ver 2.19
Rem   - SET OBJECT COLLISION OFF xxx , pour rendre un peu plus fluide .
Rem 09.04.02 / Ver 2.19b
Rem   - HTML documentation en ANGLAIS !!!
Rem   - Ajout de la gestion du langage ANGLAIS dans l'éditeur.
Rem   - Ajout de l'aide rapide lors de la sélection d'un icone.
Rem   - Fonction de suppression d'objet ( et de lumière aussi ) active
Rem   - Fix d'un bug de rafraichissement d'objet en mode "selection objet"
Rem ****************************************************************************
Rem 07.04.02 / Ver 2.18
Rem   - Mise en place de la gestion du numero d'utilisateur
Rem   - Correction d'un bug du chargement de cartes.
Rem   - Mise en place du spy dans la map
Rem ****************************************************************************
Rem 06.04.02 / Ver 2.17
Rem   - Ajout de la gestion du SCALING de TEXTURES : Ok!
Rem ****************************************************************************
Rem 03.04.02 / Ver 2.16 .
Rem   - Improvements sur la gestion des objets 3D DirectX.
Rem ****************************************************************************
Rem 01.04.02 / Ver 2.15 .
Rem   - Ajout du chargement et de la mise en place des objets 3D.   Ok!
Rem   - Type de mémoire utilisée par les textures ( +compression )
Rem ****************************************************************************
Rem 25.03.02 / Ver 2.14 .
Rem   - Minor improvements.
Rem ****************************************************************************
Rem 24.03.02 / Ver 2.12 - 2.13 :
Rem   - Corrected a bug un texture_modify                           Working !
Rem   - Scaling Object kind 1,2,3 are now fully optionnal           Working !
Rem   - NEW OPTION : Copy Object fully fonctionnal                  Ok !
Rem   - Optimisation de la routine de rafraichissement d'objets.    Ok !
Rem   - Correction d'un bug qui effaçait la matrice.                Ok !
Rem ****************************************************************************
Rem 19.03.02 / Ver 2.10 - 2.11 :
Rem   - Ajout de la lumière d'ambiance EDITEUR/SAVE/LOAD            Working !
Rem   - Ajout de l'angle de la lumière ambiante.                    Working !
Rem   - Ajout de la gestion des lumières !                          Working !
Rem   - Paramètres de lumière actifs !                              Working !
Rem ****************************************************************************
Rem 18.03.02 / Ver 2.00 - 2.01 - 2.02 :
Rem   - Restructuration complète de l'éditeur !                     Working !
Rem   - Optimisations liées aux choix.                              Working !
Rem   - Fast-Debugging : all functions tested.                      Ok !
Rem   - Corrections mineures.                                       Ok !
Rem   - Il est à nouveau possible de rentrer les noms de fichiers.  Working !
Rem   - Affichage de 4 textures sur la barre et décalage.           Working !
Rem   - Les textures sont directement selectionnables par clics     Working !
Rem ****************************************************************************

Rem Fonctions à ajouter :
Rem   - Pouvoir modifier les paramètres d'une lumière deja créee et n'étant pas la dernière en cours.
Rem   - Utilisation des matrices .
Rem   - Gestion de scripts pour les objets 3D.
Rem ****************************************************************************
Rem
Rem                                                                  ********************************************
Rem                                                                   **
Rem                                                                     ***
Rem ************************************************************************ INITIALISATIONS / VARIABLES .
Rem Définition des variables principales.
MapVersion=1
MapRevision=12
rem Variables temporaires ( initiales ).
_FADEOBJECT=3000
_keyboard=1
plandetravail=16
defaultsizex=128
defaultsizey=128
defaultsizez=128
defaulttexture=0
defaultboxsize=160
defaultrot=45
lastx=0
lasty=0
lastz=0
newobj=1
lastobject=newobj
defaultstep=32
movespeed=16
movespeedneg=0-movespeed
Rem CONFIGURATION INITIALE SI LE FICHIER 3DMAPEDIT.CFG N'EXISTE PAS !
_BgdRedRGB=0
_BgdGreenRGB=16
_BgdBlueRGB=64
cd "."
_EdPath$=get dir$()
_MapPath$=_EdPath$+"\Maps\"
_TutorialMapPath$=_MapPath$+"Tutorials_Maps\"
_TexturePath$=_EdPath$+"\Textures\"
_3DObjectPath$=_EdPath$+"\Objects_Library\"
_3DSoundPath$=_EdPath$+"\3DSound\"
_muspath$=_edpath$+"\musics\"
_soundpath$=_edpath$+"\sounds\"
Dim _obj(16383,27) : Rem NEW DIMENSION !!! 27 Values for objects Ver 2.27
Dim _ObjTemp(25)
Dim _Textures$(256)
Dim _Config$(256)
Dim _Lights(256,16) : Rem Défini les 256 lumières qui peuvent virtuellement être crées.
Dim _LightActive(8) : Rem Défini les 7 lumières qui peuvent être actives en même temps.
Dim _DirectXObject$(256)
Dim _3DSound$(256)
Dim comp(16)
Dim _Dialogue$(100)
dim _text$(32)
Rem Variables nécessaires à Magic-windows
Rem Variables nécessaires à Magic-windows
Dim _Windows_sys(32) : Dim _Windows_Order(24)
Dim _Windows_Data(24,32) : Dim _Windows_Title$(24) : Dim _Windows_Font$(24)
Dim _Windows_Gadget(24,32,8) : Dim _Windows_Gadget_Text$(24,32) : Dim _Windows_Text$(64)
Dim _Windows_Default(32,2)
Dim _Windows_Gadget_Value(24,32)
Dim _Windows_Default(24,2) : Rem Sauvegarde des positions initialies des fenêtres magic-windows.
Dim _buttons(2)
Rem ************************************************************************************
Rem Gestion des matrices Ver 1.0
Dim _Matrix(256,16) : Rem Variables système aux matrices.
Dim _Matrix_Height(256,64,64) : Rem Store all points height
Dim _Matrix_Tile(256,64,64) : Rem Store which texture are used on matrix.
Dim _Matrix_RealTile(256,64,64) : Rem Store which texture-tile will really be used on matrix.
Dim _matrix_tilelist(64) : Rem stoque la liste des images à utiliser pour faire les tiles.
Dim _Image_X(65535)
Dim _Image_Y(65535)
Rem
Rem ************************************************************************************
Rem FILE SELECTOR VER 2.0 NEEDED VALUES
Rem ************************************************************************************
 dim fileselector$(9)
 dim fileselectordata(12)
 dim _filespath$(7)
 dim _fichier$(256)
 fileselector$(1)=get dir$()
 fileselector$(2)="Charger une map"
 fileselectordata(1)=150
 fileselectordata(2)=80
 fileselectordata(11)=65535
 fileselectordata(12)=65534
Rem ************************************************************************************
Rem Variables du système de menu v2.00+
dim _menu_name$(5,20) : Rem            Stoque les noms des différents menus et options de menu.
dim _menu_options(16) : Rem             Définit combien il existe d'option par menu.
dim _option_state(16,32) : Rem          Status des options ACTIVES/INACTIVES
dim _menu_sys(16) : Rem                 Définition de valeurs système pour le menu.
dim _menu_value(16,32) : Rem            Stoque les valeurs pour CHOICE.
 Rem Initialisation du système de menu v2.00+
_menu_sys(1)=65532 : Rem numéro de l'image ou stoquer l'image du menu
_menu_sys(2)=65533 : Rem numéro de l'image ou stoquer le fond d'écran.
_menu_sys(3)=0 : Rem Cette variable est réservée , ne pas la toucher ou la modifier !
_menu_sys(4)=1 : Rem 1=Utilisation de déssins 2D ( et/ou 3D )  dans l'écran / 0=3D seule dans l'écran.
Rem ************************************************************************************
Rem
Dim _EditorPath$(8)
Dim _skin_data$(50)
Rem INFORMATIONS LIES A LA GESTION DES ZONES.
dim _zone_info(256,17) : Rem Les Zones d'action.
dim _zone_filename$(256)
dim _zone_gravity$(2)
dim _zone_type$(6)
dim _zone_inside(256) : Rem définit si on est ou pas dans une zone précise.
dim _zone_sortance(256) : Rem définit si l'on viens juste de sortir d'une zone précise.
dim _zone_entrance(256) : Rem définit si l'on viens juste de rentrer dans une zone précise.
dim _zone_active(256) : Rem définit si une zone est active ou non.
dim _zone_data(16) : Rem store certaines valeurs
dim _skybox_object(16)
dim _3dme_temp(256)

_DirectXObject=0
_LightsNum=0
_TextureNum=0
_FirstTexture=1
_TextureType=0
_FirstTextureImage=200
_3dme_temp(12)=_FirstTextureImage
Rem values are scancode() keyboards values.
pageupkey=201
pagedownkey=209
inserkey=210
supprkey=211
defaultkey=199
 _Registered=0
Rem From Demo
humanwalk=0
walkspeed=10
player=1

Rem                                                                  ********************************************
Rem                                                                   **
Rem                                                                     ***
Rem ************************************************************************ CHARGEMENT DE LA CONFIGURATION .
Set Display Mode 640,480,16
sync rate 75 :sync on
cls rgb(0,0,0) :sync : cls rgb(0,0,0) :sync
hide mouse
autocam off
configuration_load:
ink rgb(255,240,128),rgb(0,0,0)
boucle=0
fichier$="editor\3DMapEdit.cfg"
if file exist(fichier$)=1
  Open to read 1,fichier$
  Repeat
    inc boucle
    Read String 1,_Config$(boucle)
   until _Config$(boucle)="[CONFIGURATION ENDING]"
   arguments=boucle
  close file 1
Rem Analyse file to take known arguments.
For boucle=1 to arguments
  if _config$(boucle)="[MATRIXSIZE]"
    plandetravail=Val(_Config$(boucle+1))
   endif
  if _config$(boucle)="[FOG]"
    _FogRedRGB=Val(_Config$(Boucle+1))
    _FogGreenRGB=Val(_Config$(Boucle+2))
    _FogBlueRGB=Val(_Config$(Boucle+3))
    _fogdistance=Val(_config$(boucle+4))
   endif
  if _config$(boucle)="[BACKGROUND]"
    _BgdRedRGB=Val(_Config$(Boucle+1))
    _BgdGreenRGB=Val(_Config$(Boucle+2))
    _BgdBlueRGB=Val(_Config$(Boucle+3))
   endif
rem  If _Config$(boucle)="[PATH]" then _EdPath$=_Config$(boucle+1)
  if _Config$(boucle)="[RESOLUTION]" then _res$=_Config$(boucle+1)
  If _Config$(boucle)="[MAPPATH]"
    if mid$(_Config$(boucle+1),2)=":" then _MapPath$=_Config$(boucle+1) else _MapPath$=_edpath$+_Config$(boucle+1)
   endif
  If _Config$(boucle)="[TEXTUREPATH]"
    if mid$(_Config$(boucle+1),2)=":" then _TexturePath$=_Config$(boucle+1) else _TexturePath$=_edpath$+_Config$(boucle+1)
   endif
  If _Config$(boucle)="[3DOBJECTPATH]"
    if mid$(_Config$(boucle+1),2)=":" then _3DObjectPath$=_Config$(boucle+1) else _3DObjectPath$=_edpath$+_Config$(boucle+1)
   endif
  If _Config$(boucle)="[3DSOUNDPATH]"
    if mid$(_Config$(boucle+1),2)=":" then _3DSoundPath$=_Config$(boucle+1) else _3DSoundPath$=_edpath$+_Config$(boucle+1)
   endif
  If _Config$(boucle)="[TEXTUREMEM]"
    If _Config$(boucle+1)="VIDEORAM"
      _TextureType=1
     else
      _TextureType=0
     endif
   endif
  if _Config$(boucle)="[DEBUGMODE]" and _Config$(boucle+1)="TRUE" then _Debug_Mode=1
  If _Config$(boucle)="[TEXTURETYPE]" and _Config$(boucle+1)="TRUE" and _TextureType=1 then _TextureType=2
  If _Config$(boucle)="[REGISTERED USER]" then _RegisteredUser$=_Config$(boucle+1)
  If _Config$(boucle)="[REGISTERED ID]" then _RegisteredID$=_Config$(boucle+1)
  if _Config$(boucle)="[LANGUAGE]" then _LANGUAGE$=_Config$(boucle+1)
  if _Config$(boucle)="[SKIN]" then _skin$=_Config$(boucle+1)
 next boucle
if _res$="800x600" then xs=800 : ys=600
if _res$="1024x768" then xs=1024 : ys=768
if _res$="1280x1024" then xs=1280 : ys=1024
if xs>0
  if check display mode(xs,ys,16)=1
    Set display mode xs,ys,16
    sync rate 75 :sync on
    cls rgb(0,0,0) :sync : cls rgb(0,0,0) :sync
   Endif
 Endif
gosub _Set_Language : Rem Vérification du langage selectionné !
hide mouse
Rem
  Print _Dialogue$(1) : Rem CONFIG LOADED
 else
  ink rgb(128,192,255),rgb(0,0,0)
  print _Dialogue$(2) : Rem \ CONFIG NOT LOADED .
  print _Dialogue$(3) : Rem /
 endif
Print "3DMap Editor "+_Ver$
Print "_____________________"
Print " "
Print "Please wait loading configuration ..."
   ink rgb(128,192,255),rgb(0,0,0)
print " "
Rem Définition des chemins d'acces GLOBALS
 _FilesPath$(1)=_edpath$ : _FilesPath$(2)=_mappath$ : _FilesPath$(3)=_TexturePath$
 _FilesPath$(4)=_3DObjectPath$ : _FilesPath$(5)=_3DSoundPath$ : _FilesPath$(6)=_muspath$
 _FilesPath$(7)=_soundpath$
_EditorPath$(1)=_EdPath$ : _EditorPath$(2)=_MapPath$ : _EditorPath$(3)=_TutorialMapPath$
_EditorPath$(4)=_TexturePath$ : _EditorPath$(5)=_3DObjectPath$ : _EditorPath$(6)=_3DSoundPath$
_EditorPath$(7)=_muspath$ : _EditorPath$(8)=_soundpath$
Rem
Rem On prépare le menu à partir d'un fichier .txt
Rem
if _LANGUAGE$="FRANCAIS"
  _file$=_edpath$+"\editor\locales\menu(fr).loc"
 else
  _file$=_edpath$+"\editor\locales\menu(us).loc"
 endif
_menu_charge=_prepare_menu(_file$)
Rem Initialisation des valeurs pour les menus
Restore menus_values:
repeat
  read _dat1 : read _dat2 : read _dat3
  if _dat1>0 then _menu_value(_dat1,_dat2)=_dat3
 until _dat1=0
_disable_option(4,7)
Rem
Rem *****************************************
Rem *                                       *
Rem * Vérification de l'enregistrement !!!! *
Rem *                                       *
Rem *****************************************
Rem
gosub _Registration_Check
If _Registered=0
  ink rgb(128,192,255),rgb(0,0,0)
  Print _Dialogue$(4)
  Print _Dialogue$(5)
  Print _Dialogue$(6)
  print " "
  print _Dialogue$(7)
  print _Dialogue$(8)
  print " "
  print _Dialogue$(9)
  sync
  wait 9000
 else
  Print _Dialogue$(10)
  print _RegisteredUser$
 endif
print
print _Dialogue$(75)
if _TextureType=0 then print _Dialogue$(72)
if _TextureType>0 then print _Dialogue$(73)
if _TextureType=2 then print _Dialogue$(74)
wait 1000
Rem Affichage de la fenêtre correspondante à l'état
Rem
Rem                                                                  ********************************************
Rem                                                                   **
Rem                                                                     ***
Rem ************************************************************************ INITIALISATION DE L'INTERFACE GFX() .
Rem                                                                  VER 2.31 CREATION DE TOUT LES ICONES.
Rem Initialisation des couleurs de fond
Rem On définit le skin à utiliser
gosub _MAKE_SKIN
Rem Chargement des graphiques de l'éditeur.
_Load_Image(_skin_data$(5),1,_TextureType)
_Load_Image(_skin_data$(6),2,_TextureType)
_Load_Image(_skin_data$(7),3,_TextureType)
_Load_Image(_skin_data$(8),4,_TextureType)
Rem Chargement de la texture du plan de travail.
_Load_Image(_skin_data$(9),5,_TextureType)
if _LANGUAGE$="ENGLISH"
  _Load_Image(_skin_data$(13),6,_TextureType)
  _Load_Image(_skin_data$(14),7,_TextureType)
  _Load_Image(_skin_data$(15),10,_TextureType)
  _Load_Image(_skin_data$(16),11,_TextureType)
  _Load_Image(_skin_data$(17),12,_TextureType)
  _Load_Image(_skin_data$(18),22,_TextureType)
  _Load_Image(_skin_data$(19),23,_TextureType)
  _Load_Image(_skin_data$(20),24,_TextureType)
 else
  _Load_Image(_skin_data$(22),6,_TextureType)
  _Load_Image(_skin_data$(23),7,_TextureType)
  _Load_Image(_skin_data$(24),10,_TextureType)
  _Load_Image(_skin_data$(25),11,_TextureType)
  _Load_Image(_skin_data$(26),12,_TextureType)
  _Load_Image(_skin_data$(27),22,_TextureType)
  _Load_Image(_skin_data$(28),23,_TextureType)
  _Load_Image(_skin_data$(29),24,_TextureType)
 endif
_Load_Image(_skin_data$(10),8,_TextureType)
_Load_Image(_skin_data$(11),9,_TextureType)
Rem MISE EN PLACE DES OBJETS POUR LE MENU DEROULANT
create bitmap 7,800,600
set current bitmap 7
paste image 12,0,0
delete image 12
get image 13,0,0,128,16
get image 14,0,224,128,240
get image 15,128,0,256,16
get image 16,128,64,256,80
get image 17,0,16,128,224
get image 18,0,240,128,512
get image 19,128,16,256,64
get image 20,128,80,256,176
xpos=256 : ypos=0
_firstmenuimage=80
for boucle=_firstmenuimage to _firstmenuimage+44
  get image boucle,xpos,ypos,xpos+128,ypos+16
  ypos=ypos+16
  if ypos=512
    ypos=0 : xpos=xpos+128
   endif
 next boucle
delete bitmap 7
Rem On crée les icones graphiques qui servirons aux boutons
Rem Initialization
_tiles=30
MW_Initialize_Tiles(_tiles)
MW_Auto_Refresh_Off()
MW_Disable_RealTime_Scaling()
Rem MW_DBPro_Mode_On()
_icons_images=38
_3DMeMW_Make_Icon_Graphics(_icons_images)
Rem On crée toutes les fenêtres voulues
MW_Load_Default_Positions()
Fct_Windows_Title(_LANGUAGE$)
_3DMeMW_Create_All_windows(_icons_images)
Rem
gosub _define_gadgets_values
set current bitmap 0
REM IMAGE 10 IS USED FOR TEMPORARY TEXTURE DISPLAY SUB-PROGRAM.
Rem Mise en place de l'interface intuitive.
rem set camera view 0,12,bitmap width(0),bitmap height(0)
set camera view 0,12,bitmap width(0),bitmap height(0)
cls rgb(0,0,0) :sync : cls rgb(0,0,0) :sync : cls rgb(0,0,0) :sync
paste image 1,0,0,0 :sync : paste image 1,0,0,0 :sync
rem if bitmap width(0)>640 then copy bitmap 0,512,0,639,14,0,640,0,bitmap width(0)-1,14
Rem ink rgb(32,32,32),rgb(0,0,0) : box 1,457,574,478
Rem Création du plan de travail.
make object plain 1,(64*plandetravail),(64*plandetravail)
position object 1,-4,-1,-4
texture object 1,5
rotate object 1,90,0,0
scale object texture 1,plandetravail,plandetravail
ghost object on 1
rotate camera 0,45.0,45.0
position camera 0,512,-512
color backdrop rgb(_BgdRedGRB,_BgdGreenRGB,_BgdBlueRGB)
_set_fog(_FogRedRGB,_FogGreenRGB,_FogBlueRGB,_fogdistance)
Rem Initialisation des textes pour les Zones D'Action.
  Fct_SetZoneLanguage(_LANGUAGE$)
  gosub _Force_Clear_Map

Rem                                                                  ********************************************
Rem                                                                   **
Rem                                                                     ***
Rem ************************************************************************ BOUCLE PRINCIPALE DE L'EDITEUR 3D .
Rem On désactive les options qui ne sont pas encore réalisées.
_disable_option(5,1) : _disable_option(5,2)
_disable_option(5,3) : _disable_option(5,4)
_disable_option(4,16)
repeat
  choice=0
Rem                                                              Ver 2.31 CALCUL TEMPS-REEL DES FENËTRES
  MW_Background_Task()
  paste image 1,0,0,0
  _wnd=MW_Current_Window()
  if _DEBUG_MODE=1
    MW_Cls(12,32,32,32)
    MW_Ink(12,255,192,160)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,"DEBUG INFO")
    MW_Print(12,"WIN:"+str$(_wnd))
    if _wnd>0
      XM=MW_Window_Position_X() : YM=MW_Window_Position_Y()
      MW_Print(12,"XPOS:"+str$(xm)) : MW_Print(12,"YPOS:"+str$(ym))
      GDG=MW_Current_Gadget()
      MW_Print(12,"GADGET:"+str$(GDG))
     endif
   endif
  Rem
  ycurs=mousey() : xcurs=mousex()
  sprite 2,xcurs,ycurs,3
Rem On check si un icone est sélectionné .
  _window=MW_Current_Window()
  _gadget=MW_Current_gadget()
  if _window>0 and _gadget>0
    choice2=_Windows_Gadget_Value(_window,_gadget)
    MW_Ink(13,192,192,192)
    if choice2<42 then MW_Print(13,_dialogue$(choice2+10))
    if choice2>41 and choice2<48 then MW_Print(13,_dialogue$(choice2+36))
    if choice2>47 then MW_Print(13,_dialogue$(choice2+36))
   Endif
  if mouseclick()=1
    if _window>0 and _gadget>0 then choice=_Windows_Gadget_Value(_window,_gadget)
    if _window=2 and _gadget=4 then choice=22
    if _window=24 and MW_Window_Position_Y()>1 then choice=41
    if _window=0
      xm=mousex() : ym=mousey()
      hide sprite 2
      Repeat
        if upkey()=1 then move camera 10
        if downkey()=1 then move camera 0-10
        xc#=camera position x()
        zc#=camera position z()
        x=xc#/64 : z=zc#/64
        position object 1,-1.75+(x*64),-1,-1.75+(z*64)
        yadd=xm-mousex() : xadd=ym-mousey()
        xangle=wrapvalue(camera angle x()-xadd)
        yangle=wrapvalue(camera angle y()-yadd)
        rotate camera xangle,yangle,0
        _CheckFor7Lights()
        MW_Sync(0)
        position mouse xm,ym
       sync
       until mouseclick()=0
Rem      position mouse xm,ym
      show sprite 2
     endif
   endif
Rem  if ycurs<13 and xcurs<640 then gosub _displaying_menu
Rem
  Rem MISE EN PLACE DES RACCOURCIS CLAVIER.
  fastmenu=0 : keyb=0
rem  if _keyboard=1 then inc acceptkeys
  inc acceptkeys
  if acceptkeys=30
    acceptkeys=0 : Gosub _Scan_For_Shortcuts
   endif
  Rem L'UTILISATEUR FAIT APPEL AUX ICONES POUR UTILISER LES FONCTIONS DE L'EDITEUR.
Rem                                                        PREMIERE LIGNE D'ICONES !!!!
  if Choice>0 then gosub _active_choice
  if MW_Window_Exist(15)=1 then Fct_Object_Properties(newobj)
  if MW_Window_Exist(17)=1 then _Matrix_Properties(_CurrentMatrix)
  Rem AFFICHAGE DU NOMBRE d'OBJETS PRESENTS
  MW_Cls(14,32,32,32)
  MW_Print(14,str$(lastobject-1))
Rem on déplace la matrice pour la garder sous le joueur.
  Rem on positionne l'écouteur sonore
  position listener camera position x(),camera position y(),camera position z()
  rotate listener camera angle x(),camera angle y(),camera angle z()
Rem ON VERIFIE LES LUMIèRES
  _CheckFor7Lights()
  xc#=camera position x()
  zc#=camera position z()
  x=xc#/64 : z=zc#/64
  position object 1,-1.75+(x*64),-1,-1.75+(z*64)
  if upkey()=1 then move camera 10
  if downkey()=1 then move camera 0-10
Rem synchro . . .
  MW_Sync(0)
  sync
  MW_Cls(13,32,32,32)
 until choice=22
Rem
Rem                                                                  ********************************************
Rem                                                                   **
Rem                                                                     ***
Rem ************************************************************************ FIN DE L'EDITEUR , ON QUITTE , BYE.
Rem On efface les bitmaps utilisés.
Rem
Rem On ferme toute les fenêtres actives pour sauvegarder leurs positions.
For bcl=1 to 24 step 1
  If MW_window_Exist(bcl)=1 then MW_Close_Window(bcl)
 Next Boucle
MW_Save_Default_Positions()
Rem On efface les objets 3D crées.
gosub _Force_Clear_Map
Rem On Sauvegarde les positions de toutes les fenetres Magic-Windows.
MW_Release_All()
_3DMeMW_Clear_Icon_Graphics()
for boucle=1 to 65535
  if object exist(boucle)=1 then delete object boucle
  if image exist(boucle)=1 then delete image boucle
 next boucle
Sync
flush video memory
Rem cls
End
Rem
Rem
Rem                     FIN DU PROGRAMME DE L'EDITEUR 3DMAPEDITOR.
Rem
Rem
_define_gadgets_values:
  Restore gadgets_values
  read _winmax
  for _window=1 to _winmax
    read _winnum : read _gadquant
    for _gadget=1 to _gadquant
      read _value
      _Windows_Gadget_Value(_winnum,_gadget)=_value
     next _gadget
   next _window
 Return
_active_choice:
  if choice=1 then gosub _Load_Map
  if choice=2 then gosub _clear_map
  if choice=3 then gosub _charge_texture
  if choice=4 then gosub _kill_texture
  if choice=5 then gosub _charge_directx
  if choice=6 then gosub _Select_3DObject
  if choice=7 then gosub _kill_3DObject
  if choice=8 then gosub _light_intensity
  if ( choice>8 and choice<18 )
    xc#=camera position x() : yc#=camera position y() : zc#=camera position z()
    xa#=camera angle x() : ya#=camera angle y() : za#=camera angle z()
    inc lastobject
    _obj(1,1)=lastobject
    newobj=lastobject
    _obj(newobj,19)=1 : Rem WIREFRAME
    _obj(newobj,20)=1 : Rem ACTIVE BLACK IS TRANSPARENCY OR NOT
    _obj(newobj,21)=0 : Rem CULL ( SHOW HIDDEN FACES )
    _obj(newobj,22)=1 : Rem TEXTURE FILTERING
    _obj(newobj,23)=1 : Rem SENSITIVE TO LIGHTS
    _obj(newobj,24)=1 : Rem SENSITIVE TO FOG
    _obj(newobj,25)=1 : Rem SENSITIVE TO AMBIENT LIGHT
    _obj(newobj,26)=0 : Rem HIDDEN OBJECT
    _obj(newobj,27)=1 : Rem OBJECT COLLISION
rem    if object exist(newobj) then delete object(newobj)
    If choice=9 then gosub _Create_Light
    If choice=10 then gosub _create_directx
    if choice=11 then gosub _create_3dsound
    If choice=12 then gosub _Create_Sphere
    If choice=13 then gosub _Create_Cube
    If choice=14 then gosub _Create_Box
    If choice=15 then gosub _Create_Cylinder
    If choice=16 then gosub _Create_Cone
    If choice=17 then gosub _Create_Plain
    position camera xc#,yc#,zc#
    rotate camera xa#,ya#,za#
   endif
  if choice=18 then gosub _scale_texture
  if choice=19 or choice=20 then gosub _modify_texture
Rem                                                        SECONDE LIGNE D'ICONES !!!!
  if choice=21 then gosub _Save_Map
  REM If choice=22 then QUIT EDITOR.
  if choice=23 then gosub _save_camera_view
  if choice=24 then gosub _fogtest
  if choice=25 then gosub _charge_3dsound
  if choice=26 then gosub _select_3dsound
  if choice=27 then gosub _kill_3dsound : Rem NOT TESTED
  if choice=28 then gosub _ambient_light
  if choice=29 then gosub _ambient_orientation
  if choice=30 then gosub _Kill_Object
  if choice=31 then gosub _Select_Object
  if choice=32 then gosub _copy_object
  If choice=33 then gosub _Move_Object
  If choice=34 then gosub _Scale_Object
  If choice=35 then gosub _Rotate_Object
  if choice=36 then gosub _object_properties
  if choice=37 then gosub _optimize_objects
  if choice=38 then gosub _Ghost_Mode
  if choice=39 then gosub _decrease_texture_view
  if choice=40 then gosub _increase_texture_view
  if choice=41 then gosub _apply_selected_texture
REM  if xcurs>577 and ycurs>87 and ycurs<328 then choice=41
Rem NEWS FUNCTIONS FROM VER 2.29
  if choice=42 then gosub _create_zone
  if choice=43 then gosub _move_zone
  if choice=44 then gosub _scale_zone
  if choice=45 then gosub _select_zone
  if choice=46 then gosub _zone_properties
  if choice=47 then gosub _kill_zone
Rem News Functions from 2.30+
  if choice=49 then gosub _create_new_matrix
  if choice=50 then gosub _Move_Matrix
  if choice=51 then gosub _change_point_height
  if choice=52 then gosub _texture_matrix_tile
  if choice=53 then gosub _select_another_matrix
  if choice=54 then gosub _define_matrix_properties
  if choice=55 then gosub _Delete_Current_Matrix
  if choice=56 then gosub _make_random_height
  Repeat
   Until mouseclick()=0
 Return
Rem
Rem
Rem
_displaying_menu:
  if spr1=1
Rem    spr1=0 : delete sprite 1
   endif
  Repeat
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    option_choisie=_select_submenu(menu_choisi)
    menu_choisi=_display_menu(option_choisie)
    if menu_choisi>0 and option_choisie>0
      rc=_menu_value(menu_choisi,option_choisie)
      tmpchoice=_menu_value(menu_choisi,option_choisie)
     else
      rc=0
     endif
    if menu_choisi>3 and rc>0 then inc rc,26
    if rc>0
      MW_Ink(13,192,192,192)
      MW_Print(13,_dialogue$(rc+10))
     endif
    sync
    MW_Sync(0)
    MW_Cls(13,32,32,32)
Rem    if _menu_sys(4)=1 then _aftersync_menu()
    if _menu_sys(4)=1 then paste image 1,0,0
    mc=mouseclick()
   until mc<>0 or (option_choisie=0 and menu_choisi=0)
  if mc=1 then choice=_menu_value(menu_choisi,option_choisie)
  _Wait_MouseClick0()
 return
Rem
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                                 CHARGER UN CARTE SAUVEGARDEE SUR DISQUE                                   *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Load_Map:
Rem  Set Current Bitmap 1
  MW_Background_Task() : MW_sync(0) : sync
  choice=0
  Rem Ouverture du fichier cible et de son Header ( entête ).
Rem  map$="default.map" : rem on recupere le nom du chemin et du fichier choisi
  ink rgb(128,128,128),rgb(1,1,1)
  set cursor 5,460
rem  printc _Dialogue$(52)
rem  input " ";map$
  title$=_Dialogue$(52)
REM FILE SELECTOR FUNCTION USE
  fileselector$(2)=title$
  _loaderpath$=_MapPath$
  filter1$=".map" : filter2$=""
  Fct_File_Selector_v1(_loaderpath$,filter1$,filter2$)
  _dossierfinal$=fileselector$(8)
  _fichierfinal$=fileselector$(9)
REM
  if file exist(_MapPath$+_fichierfinal$)
    map$=_MapPath$+_fichierfinal$
   else
    if file exist(_dossierfinal$+_fichierfinal$)
      map$=_dossierfinal$+_fichierfinal$
     else
      map$=_fichierfinal$
     endif
   endif
  maploaded$=_fichierfinal$
rem   if map$="" then map$="default.map"
  if file exist(map$)=1
    Rem on efface tout les objets 3D existants.
    sel$="O"
Rem   sync :sync
    MW_Print(13,"Loading : Opening File")
    MW_Background_Task() : MW_sync(0) : sync
    gosub _Force_Clear_Map
    MW_Background_Task() : MW_sync(0) : sync
    MW_Ink(13,255,255,255)
    _loaded=true
    Open to read 1,map$
Rem Définition de carte et de versions de l'éditeur.
    read string 1,file1$
    read byte 1,MapVersionFile
    read byte 1,MapRevisionFile
    read string 1,file2$
Rem définition de la carte.
    For boucle=1 to 16
      read file 1,_obj(1,boucle)
     next boucle
Rem Debut header
    read string 1,file3$
Rem Définition des objets.
    newobj=_obj(1,1)
    lastobject=newobj
Rem    MW_Print(13,"Loading map in progress : Objects datas")
    MW_Print(13,"Loading : Load All Objects")
    for boucle=2 to newobj
      for sousboucle=1 to 16
        read file 1,_obj(boucle,sousboucle)
       next sousboucle
      If MapVersionFile>0 and MapRevisionFile>4
        read file 1,_obj(boucle,17)
        read file 1,_obj(boucle,18)
       endif
      If MapVersionFile>0 and MapRevisionFile>6
        for sousboucle=19 to 25
          read file 1,_obj(boucle,sousboucle)
         next sousboucle
       else
        _obj(boucle,19)=1 : Rem WIREFRAME
        _obj(boucle,20)=1 : Rem ACTIVE BLACK IS TRANSPARENCY OR NOT
        _obj(boucle,21)=0 : Rem CULL ( SHOW HIDDEN FACES )
        _obj(boucle,22)=1 : Rem TEXTURE FILTERING
        _obj(boucle,23)=1 : Rem SENSITIVE TO LIGHTS
        _obj(boucle,24)=1 : Rem SENSITIVE TO FOG
        _obj(boucle,25)=1 : Rem SENSITIVE TO AMBIENT LIGHT
       endif
Rem AJOUT DES DEUX DERNIERES OPTIONS DES ATTRIBUTS DES OBJETS 3D.
      if MapVersionFile>0 and MapRevisionFile>7
        read file 1,_Obj(boucle,26)
        read file 1,_Obj(boucle,27)
       else
        _Obj(boucle,26)=0 : Rem OBJET CACHE = FALSE
        _Obj(boucle,27)=1 : Rem OBJET COLLISIONS = TRUE
       endif
      MW_Background_Task() : MW_sync(0) : sync
     next boucle
    MW_Background_Task() : MW_sync(0) : sync
Rem 2ème version de la carte , GESTION DES TEXTURES.
    If MapVersionFile>0 and MapRevisionFile>1
      MW_Print(13,"Loading : Textures data")
      read string 1,file4$
      _TextureNum=_obj(1,8)
      For bouclet=1 to _TextureNum
        read string 1,_Textures$(bouclet)
       next bouclet
     endif
    MW_Background_Task() : MW_sync(0) : sync
Rem Ver 1.3 Gestion des lumières
    If MapVersionFile>0 and MapRevisionFile>2
      MW_Print(13,"Loading : Lights datas")
      read string 1,file5$
      _LightNum=_Obj(1,16)
      if _LightNum>0
        For boucle=1 to _LightNum
          for sousboucle=1 to 16
            read file 1,_Lights(boucle,sousboucle)
           next sousboucle
         next boucle
       endif
     endif
    MW_Background_Task() : MW_sync(0) : sync
Rem Ver 1.4 Gestion des objets 3D Direct X ( .x )
    If MapVersionFile>0 and MapRevisionFile>3
      MW_Print(13,"Loading : Imported Objects Datas")
      read string 1,file6$
      read file 1,_DirectXObject
      if _DirectXObject>0
        For boucle=1 to _DirectXObject
          read string 1,_DirectXObject$(boucle)
         next boucle
       endif
     endif
    MW_Background_Task() : MW_sync(0) : sync
Rem Ver 1.6 Gestion des sons 3D.
    If MapVersionFile>0 and MapRevisionFile>5
      MW_Print(13,"Loading : 3DSounds datas")
      read string 1,file7$
      read file 1,_3DSoundObject
      if _3DSoundObject>0
        For boucle=1 to _3DSoundObject
          read string 1,_3DSound$(boucle)
         next boucle
       endif
     endif
    MW_Background_Task() : MW_sync(0) : sync
Rem Ver 1.9 Gestions des zones d'action.
    if MapVersionFile>0 and MapRevisionFile>8
      MW_Print(13,"Loading : Action Zones datas")
      read string 1,file8$
      read file 1,_last_zone
      _zone_data(1)=_last_zone
      _current_zone=_last_zone
      if _last_zone>0
        for boucle=1 to _last_zone
          for sousboucle=1 to 16
            read long 1,_Zone_Info(boucle,sousboucle)
           next sousboucle
          if MapVersionFile>0 and MapRevisionFile>9 then read long 1,_Zone_Info(boucle,17)
          if MapVersionFile>0 and MapRevisionFile>10 then read string 1,_Zone_Filename$(boucle)
         next boucle
       endif
     endif
Rem
    MW_Background_Task() : MW_sync(0) : sync
    If MapVersionFile>0 and MapRevisionFile>11
      MW_Print(13,"Loading : Matrixes datas")
      read string 1,file9$
      read file 1,_LastMatrix
      _Matrix(0,0)=_LastMatrix : _CurrentMatrix=_LastMatrix
      if _LastMatrix>0
        For Boucle=1 to _LastMatrix
          for _mdat=1 to 16
            read long 1,_Matrix(Boucle,_mdat)
           next _mdat
          for zbcl=0 to _Matrix(Boucle,5)
            for xbcl=0 to _Matrix(Boucle,4)
              read long 1,_Matrix_Height(Boucle,Xbcl,Zbcl)
              read long 1,_Matrix_Tile(boucle,xbcl,zbcl)
             next xbcl
           next zbcl
         next boucle
       Endif
     Endif
    MW_Background_Task() : MW_sync(0) : sync
Rem END OF .MAP FILE
    read string 1,file10$
    close file 1
    MW_Background_Task() : MW_sync(0) : sync
    if _TextureNum>0
      MW_Print(13,"Loading : Loading Textures . . .")
      for bouclet=1 to _TextureNum+1
        if image exist(_FirstTextureImage+bouclet)=1
          delete image (_FirstTextureImage+bouclet)
          MW_Background_Task() : MW_sync(0) : sync
         endif
        if file exist(_texturepath$+_textures$(bouclet))=1
          _Load_Image(_texturepath$+_Textures$(bouclet),(_FirstTextureImage+bouclet),_TextureType)
          MW_Background_Task() : MW_sync(0) : sync
         else
          if file exist(_textures$(bouclet))=1
            _Load_Image(_Textures$(bouclet),(_FirstTextureImage+bouclet),_TextureType)
            MW_Background_Task() : MW_sync(0) : sync
           endif
         endif
       next bouclet
     endif
    MW_Background_Task() : MW_sync(0) : sync
    MW_Print(13,"Loading : Refresh All Objects")
    for boucle=2 to newobj
      Fct_Refresh_Object(boucle)
      MW_Background_Task() : MW_sync(0) : sync
     next boucle
    MW_Background_Task() : MW_sync(0) : sync
Rem                                Ver 2.29 RAFRAICHISSEMENT DES ZONES APRES CHARGEMENT DE MAPS !!!!!
    if _last_zone>0
      MW_Print(13,"Loading : Refresh Zones")
      for _zone_ref=1 to _last_zone
        gosub _refresh_zone
        MW_Background_Task() : MW_sync(0) : sync
       next _zone_ref
     endif
    MW_Background_Task() : MW_sync(0) : sync
    xcam=_obj(1,2)
    ycam=_obj(1,3)
    zcam=_obj(1,4)
    xang=_obj(1,5)
    yang=_obj(1,6)
    zang=_obj(1,7)
    position camera xcam,ycam,zcam
    rotate camera xang,yang,zang
   endif
Rem                               Ver 2.30 Mise en place des matrices sauvées .
  if _LastMatrix>0
    MW_Print(13,"Loading : Refresh Matrixes")
    for boucle=1 to _lastmatrix
      _3DMe_Refresh_Matrix(boucle,_FirstTextureImage,_texturenum)
      MW_Background_Task() : MW_sync(0) : sync
     next boucle
   endif
Rem Mise en place de la couleur d'ambiance après le chargement de la carte.
Rem  MW_Print(13,"Loading map in progress : Restore Lights Datas")
  _AmbientRed=_Obj(1,9)
  _AmbientGreen=_Obj(1,10)
  _AmbientBlue=_Obj(1,11)
  _AmbientLight=_Obj(1,12)
  _AmbientX=_Obj(1,13)
  _AmbientY=_Obj(1,14)
  _AmbientZ=_Obj(1,15)
rem  if _loaded=true
  color ambient light Rgb(_AmbientRed,_AmbientGreen,_AmbientBlue)
  set ambient light _AmbientLight
  set directional light 0,_AmbientX,_AmbientY,_AmbientZ
  _3dme_temp(4)=_AmbientRed : _3dme_temp(5)=_AmbienGreen : _3dme_temp(6)=_AmbientBlue
  _3dme_temp(7)=_AmbientLight
  _checkFor7Lights()
  MW_Background_Task() : MW_sync(0) : sync
  gosub _display_texture
  Set Current Bitmap 0
 Return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                                   SAUVER LA CARTE EN MEMOIRE SUR DISQUE                                   *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Save_Map:
  choice=0
  if lastobject=1 and _lastmatrix=0 then return
Rem Ver 2.17 Version ENREGISTREE ou version DEMO !
  if _Registered=1
    lastobject2=lastobject
   else
    lastobject2=128
    if lastobject2>lastobject then lastobject2=lastobject
   endif
  _obj(1,1)=lastobject2
  _obj(1,8)=_TextureNum
  Rem Sauvegarde du nombre de lumières crées.
  _Obj(1,16)=_LightNum
  Rem Création du fichier cible et de son Header ( entête ).
Rem  ink rgb(128,128,128),rgb(1,1,1)
Rem  set cursor 5,461
Rem  printc _Dialogue$(53)
Rem  input " ";map$
  Repeat
    MW_Background_Task()
    d$=inkey$()
    if d$<>""
      repeat
        MW_Background_Task() : MW_Sync(0) : sync
       until inkey$()=""
      if _text<32 and asc(d$)<>13 and asc(d$)<>8
        inc _text,1
        _text$(_text)=d$
       endif
      if asc(d$)=8 and _text>0 then dec _text,1
     endif
    map$=""
    if _text>0
      for boucle=1 to _text
        map$=map$+_text$(boucle)
       next boucle
     endif
    MW_Ink(13,128,128,128)
    MW_Set_Cursor(13,0,0)
    MW_Print(13,_Dialogue$(53)+" "+map$)
    MW_Sync(0)
    sync
    MW_Cls(13,32,32,32)
   Until asc(d$)=13
  if map$<>"" and right$(map$,4)<>".map" then map$=map$+".map"
  if map$="" then map$=maploaded$
  if map$="" then map$="default.map"
  rem  if map$="" then map$="default2.map"
  ink rgb(32,32,32),rgb(32,32,32)
  box 3,462,573,477
  hide mouse
  if file exist(_MapPath$+map$)=1 then delete file _MapPath$+map$
  Open to write 1,_MapPath$+map$
Rem Définition de carte et de versions de l'éditeur.
  Write string 1,"FLXMap. "
  Write byte 1,MapVersion
  Write byte 1,MapRevision
  Write string 1,"definition"
Rem définition de la carte.
  For boucle=1 to 16
    write file 1,_obj(1,boucle)
   next boucle
Rem Debut header
  write string 1,"objects"
Rem Définition des objets.
  for boucle=2 to lastobject2
    for sousboucle=1 to 27
      write file 1,_obj(boucle,sousboucle)
     next sousboucle
   next boucle
Rem Ver 1.2 Gestion des textures.
  write string 1,"textures"
  For boucle=1 to _TextureNum
    write string 1,_Textures$(boucle)
   next boucle
Rem Ver 1.3 Gestion des lumières
  write string 1,"light_sources"
  if _LightNum>0
    For boucle=1 to _LightNum
      for sousboucle=1 to 16
        write file 1,_Lights(boucle,sousboucle)
       next sousboucle
     next boucle
   endif
Rem Ver 1.4 Gestion des objets 3D Direct X ( .x )
  write string 1,"Direct X Objects"
  write file 1,_DirectXObject
  if _DirectXObject>0
    For boucle=1 to _DirectXObject
      write string 1,_DirectXObject$(boucle)
     next boucle
   endif
Rem   endif
Rem Ver 1.6 Gestion des sons 3D (.wav/.mp3)
  write string 1,"3D Sounds"
  write file 1,_3DSoundObject
  if _3DSoundObject>0
    For boucle=1 to _3DSoundObject
      write string 1,_3DSound$(boucle)
     next boucle
   endif
Rem   endif
Rem Ver 1.9 Gestion des Zones d'action ( zones )
  write string 1,"Action Zones"
  write file 1,_last_zone
  if _last_zone>0
    for boucle=1 to _last_zone
      for sousboucle=1 to 17
        write long 1,_Zone_Info(boucle,sousboucle)
       next sousboucle
      write string 1,_Zone_Filename$(boucle)
     next boucle
   endif
Rem Ver 1.12 Gestion des matrices .
  write string 1,"Matrixes"
  write file 1,_LastMatrix
  if _LastMatrix>0
    For Boucle=1 to _LastMatrix
      for _mdat=1 to 16
        write long 1,_Matrix(Boucle,_mdat)
       next _mdat
      for zbcl=0 to _Matrix(Boucle,5)
        for xbcl=0 to _Matrix(Boucle,4)
          write long 1,_Matrix_Height(Boucle,Xbcl,Zbcl)
          write long 1,_Matrix_Tile(boucle,xbcl,zbcl)
         next xbcl
       next zbcl
     next boucle
   Endif
   Rem Fin de fichier.
    write string 1,"endofdatas"
Rem MISE EN PLACE DE L'ESPION DE L'UTILISATEUR
  if _Registered=1
    _RegisteredUser2$=""
    For boucle=1 to 16
      char=asc(mid$(_RegisteredUser$,boucle))
      if char>0 then inc char,25
      write byte 1,char
     next boucle
   endif
  close file 1
  maploaded$=map$
 Return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                                 EFFACER ENTIEREMENT LA CARTE EN COURS                                     *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Clear_Map:
  choice=0
  MW_Ink(13,128,128,128)
  MW_Print(13,_dialogue$(54))
  Repeat
    _key=scancode()
    MW_Background_Task() : MW_sync(0) : sync
   until _key<>0
  sel$=str$(_key)
  MW_Cls(13,32,32,32)
  _Force_Clear_Map:
  ink rgb(32,32,32),rgb(32,32,32)
  _texturefirst=1
  sel$=upper$(sel$)
  box 2,462,573,477
  if sel$<>"N" or sel$<>"NON"
Rem on efface tout les objets 3D existants.
    if newobj<lastobject then newobj=lastobject
    for newobj=lastobject to 1 step -1
      gosub _Kill_Object
     next newobj
    lastobject=1
      MW_Background_Task() : MW_sync(0) : sync
Rem On efface toute les textures chargées.
    for boucle=1 to _TextureNum
      if image exist(boucle+_FirstTextureImage) then delete image boucle+_FirstTextureImage
      _textures$(boucle)=""
     next boucle
    MW_Background_Task() : MW_sync(0) : sync
    _TextureNum=0
    _Obj(1,8)=0
    lastobject=1
    newobj=1
    MW_Cls(24,32,32,32)
Rem On efface aussi toute les lumières
    MW_Background_Task() : MW_sync(0) : sync
    For boucle=1 to _LightNum
      for sousboucle=1 to 16
        _Lights(boucle,sousboucle)=0
       next sousboucle
     next boucle
    _LightNum=0
    For boucle=1 to 7
      if light exist(boucle) then delete light boucle
     next boucle
    MW_Background_Task() : MW_sync(0) : sync
    if _3DSoundObject>0
      for boucle=1 to _3DSoundObject
        _3DSound$(boucle)=""
       next boucle
      _3DSoundObject=0
     endif
    MW_Background_Task() : MW_sync(0) : sync
    if _last_zone>0
      for boucle=1 to _last_zone
        if object exist(65536-boucle)=1 then delete object 65536-boucle
        for sousboucle=1 to 16
          _zone_info(boucle,sousboucle)=0
          _zone_filename$(boucle)=""
         next sousboucle
       next boucle
      _last_zone=0 : _current_zone=0
     endif
    _Obj(1,9)=128
    _Obj(1,10)=128
    _Obj(1,11)=128
    _Obj(1,12)=64
    _Obj(1,13)=0
    _Obj(1,14)=0
    _Obj(1,15)=0
    MW_Background_Task() : MW_sync(0) : sync
    color ambient light Rgb(128,128,128)
    set ambient light 64
    set directional light 0,0,0,0
  Rem Efface les textures affichées à droite de l'écran.
    ink rgb(32,32,32),rgb(32,32,32)
    box 578,88,637,327
  Rem Ver 2.30+ Suppression de toute les matrices crées.
    If _LastMatrix>0
      for boucle=_lastmatrix to 1 step -1
        _3DME_Delete_Matrix(boucle)
       next boucle
      _lastmatrix=0 : _currentmatrix=0
     Endif
    _Matrix(0,0)=_LastMatrix
    MW_Background_Task() : MW_sync(0) : sync
   endif
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                   CHARGER UN NOUVEL OBJET 3D DIRECT-X A PARTIR D'UN FICHIER SUR DISQUE                    *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Charge_DirectX:
  choice=0
  _loaderpath$=_3DObjectPath$
  title$=_Dialogue$(63)
REM FILE SELECTOR FUNCTION USE
  fileselector$(2)=title$
  filter1$=".x" : filter2$=".3ds"
  Fct_File_Selector_v1(_loaderpath$,filter1$,filter2$)
  _dossierfinal$=fileselector$(8)
  _fichierfinal$=fileselector$(9)
REM
  if right$(_fichierfinal$,4)=".3DS"
    3ds2x _fichierfinal$,left$(_fichierfinal$,len(_fichierfinal$)-4)+".x"
    _fichierfinal2$=left$(_fichierfinal$,len(_fichierfinal$)-4)+".x"
    _fichierfinal$=_fichierfinal2$
   endif
  if file exist(_3DObjectPath$+_fichierfinal$)
    txt$=_fichierfinal$
   else
    txt$=_dossierfinal$+_fichierfinal$
   endif
  inc _DirectXObject
  _DirectXObject$(_DirectXObject)=txt$
  _current3dobject=_DirectXObject
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                     CHARGER UN NOUVEAU SON 3D A PARTIR D'UN FICHIER SUR DISQUE                            *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Charge_3DSound:
  choice=0
  _loaderpath$=_3DSoundPath$
  title$=_Dialogue$(66)
  filter1$=".wav"
  filter2$=".mp3"
REM FILE SELECTOR FUNCTION USE
  fileselector$(2)=title$
  Fct_File_Selector_v1(_loaderpath$,filter1$,filter2$)
  _dossierfinal$=fileselector$(8)
  _fichierfinal$=fileselector$(9)
REM
  if file exist(_3DSoundPath$+_fichierfinal$)
    txt$=_fichierfinal$
   else
    txt$=_dossierfinal$+_fichierfinal$
   endif
  if file exist(txt$) or file exist(_3DSoundPath$+txt$)
    inc _3DSoundObject
    _3DSound$(_3DSoundObject)=txt$
   endif
  _Current_3dsound=_3DSoundObject
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                        CHARGER UNE NOUVELLE TEXTURE A PARTIR D'UN FICHIER SUR DISQUE                      *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Charge_Texture:
  choice=0
  _loaderpath$=_TexturePath$
  title$=_Dialogue$(55)
  filter1$=".bmp"
  filter2$=".jpg"
REM FILE SELECTOR FUNCTION USE
  fileselector$(2)=title$
  Fct_File_Selector_v1(_loaderpath$,filter1$,filter2$)
  _dossierfinal$=fileselector$(8)
  _fichierfinal$=fileselector$(9)
REM
  if file exist(_TexturePath$+_fichierfinal$)
    txt$=_fichierfinal$
   else
    txt$=_dossierfinal$+_fichierfinal$
   endif
  if file exist(txt$)
    inc _TextureNum
    _Textures$(_TextureNum)=txt$
    if image exist(_FirstTextureImage+_Texturenum) then delete image (_FirstTextureImage+_Texturenum)
    _Load_Image(txt$,(_FirstTextureImage+_TextureNum),_TextureType)
   else
    if file exist(_TexturePath$+txt$)
      inc _TextureNum
      _Textures$(_TextureNum)=txt$
      if image exist(_FirstTextureImage+_Texturenum) then delete image (_FirstTextureImage+_Texturenum)
      _Load_Image(_TexturePath$+txt$,(_FirstTextureImage+_TextureNum),_TextureType)
     endif
   endif
  _Obj(1,8)=_numtexture
  REM return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                               AFFICHER LES TEXTURES DE L'APERCU RAPIDE                                    *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Display_Texture:
  choice=0
  MW_Cls(24,32,32,32)
  if _TextureNum>0
    MW_Background_Task()
    yp=0
    _texturefirst=_firsttexture
    if _texturefirst>_TextureNum then _texturefirst=_TextureNum
    _texturelast=_texturefirst+3
    if _texturelast>_TextureNum then _texturelast=_TextureNum
    if bitmap exist(1)=1 then delete bitmap 1
    create bitmap 1,640,480 : MW_Sync(0) : sync
    for boucle=_texturefirst to _texturelast step 1
      _img=boucle+_FirstTextureImage
      if image exist(_img)=1
        set current bitmap 1
        paste image _img,0,0
        MW_Copy_Bitmap2Window(1,0,0,_image_x(_img),_image_y(_img),24,0,yp,63,yp+60)
       endif
      inc yp,60
     next boucle
    if bitmap exist(1)=1 then delete bitmap 1
    set current bitmap 0
    MW_Background_Task()
    MW_Sync(0) : sync
    endif
  return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *              APPLIQUER LA TEXTURE SELECTIONNE DANS L'APERCU RAPIDE SUR L'OBJET COURANT                    *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Apply_Selected_Texture:
  choice=0
  if lastobject=1 then return
  if newobj>lastobject then newobj=lastobject
  _window=MW_Current_Window()
  if _window=24
    yp=MW_Window_Position_Y()
    if yp>0
      _textur=_firsttexture+(yp/60)
      if _textur>_texturenum then _textur=_texturenum
      if _TextureNum>0 and newobj>1 then texture object newobj,(_textur+_FirstTextureImage)
      _obj(newobj,10)=_textur
     endif
   endif
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                       CHANGER LES DIMENSIONS D'UNE TEXTURE APPLIQUEE SUR L'OBJET COURANT                  *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Scale_Texture:
  choice=0
  if lastobject=1 then return
  defaultstep2=1
    xscaletinit=_obj(newobj,17)
    yscaletinit=_obj(newobj,18)
  repeat
    MW_Background_Task()
    xc#=camera position x()
    yc#=camera position y()
    zc#=camera position z()
    xscalet=_obj(newobj,17)
    yscalet=_obj(newobj,18)
    key=scancode()
    if upkey()=1 then yscalet=yscalet+defaultstep2
    if downkey()=1 then yscalet=yscalet-defaultstep2
    if leftkey()=1 then xscalet=xscalet-defaultstep2
    if rightkey()=1 then xscalet=xscalet+defaultstep2
    if key=inserkey then inc defaultstep2
    if key=supprkey then dec defaultstep2
    if key=defaultkey
      xscalet=0 : yscalet=0
     endif
    if defaultstep2=0 then defaultstep2=1
    if defaultstep2>8 then defaultstep2=8
    if xscalet<(0-99) then xscalet=0-99
    if yscalet<(0-99) then yscalet=0-99
    if key=defaultkey
      xscalet=xscaletinit
      yscalet=yscaletinit
     endif
    _obj(newobj,17)=xscalet
    _obj(newobj,18)=yscalet
    Fct_Refresh_Object(newobj)
    if XScalet>0
      XScalet_final#=XScalet
     else
      XScalet_final#=1.0+(XScalet*0.01)
     endif
    if YScalet>0
      YScalet_final#=YScalet
     else
      YScalet_final#=1.0+(YScalet*0.01)
     endif
    if XScalet=0 then XSCalet_final#=xsize/128.0
    if YScalet=0 then YSCalet_final#=ysize/128.0
    rem Use MOUSEMOVE to alter camera angles
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,"Texture:")
    MW_Print(12,"Xs="+str$(xscalet_final#))
    MW_Print(12,"Ys="+str$(yscalet_final#))
    MW_Print(12,_Dialogue$(56)+str$(defaultstep2))
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
    MW_Sync(0) : sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  _Wait_MouseClick0()
 Return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                    APPLIQUER LA TEXTURE SUIVANTE OU PRECEDENTE A L'OBJET COURANT                          *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Modify_Texture:
  choice=0
  if lastobject=1 then return
  textre=_obj(newobj,10)
  if choice=19 then dec textre
  if choice=20 then inc textre
  if textre<1 then textre=1
  if textre>_TextureNum then textre=_TextureNum
  if _TextureNum>0 and newobj>0 then texture object newobj,(textre+_FirstTextureImage)
  _obj(newobj,10)=textre
  choice=0
  MW_Background_Task() : MW_sync(0) : sync
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                                 SE DEPLACER DANS LES TEXTURES AFFICHEES                                   *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Decrease_Texture_View:
  choice=0
  dec _firsttexture
  if _firsttexture<1 then _firsttexture=1
  gosub _display_texture
 return
Rem *************************************************************************************************************
_Increase_Texture_View:
  choice=0
  inc _firsttexture
  if _firsttexture>(_texturenum-3) then _firsttexture=_texturenum-3
  if _firsttexture<1 then _firsttexture=1
  gosub _display_texture
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                          DETRUIRE UNE TEXTURE AINSI QUE LES EVENEMENTS ASSOCIES                           *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Kill_Texture:
  choice=0
  if _TextureNum=0 then Return
  if MW_Window_Exist(18)=0
    MW_Open_New_Window(18,_Dialogue$(67),196,242,1,1,0)
    MW_Position_Window(18,128,12)
    MW_Paste_Image(18,11,0,0)
   Endif
  _first=1
  gosub _refresh_texture_list
  _delete_texture=0
  repeat
    MW_Background_Task()
    _window=MW_Current_Window()
    if _window=18
      xm=MW_Window_Position_X() : ym=MW_Window_Position_Y()
     else
      xm=0 : ym=0
     endif
    if mouseclick()=1
      if xm>17 and xm<80
        if ym>176 and ym<193
          _quit=1 : Rem QUITTE PAR LA FONCTION 'ANNULER'
         endif
        if ym>156 and ym<173
          _delete_texture=_selected : _quit=1
         endif
       endif
      if xm>171 and xm<188
        if ym>15 and ym<32
          dec _first : _reftexture=1
         endif
        if ym>127 and ym<144
          inc _first : _reftexture=1
         endif
       endif
      if _reftexture=1
        _reftexture=0
        if _first>(_TextureNum-7) then _first=_Texturenum-7
        if _first<1 then _first=1
        gosub _refresh_texture_list
       endif
      if xm>33 and xm<170 and ym>15 and ym<144
        _YLine=(ym-16)/16
        _Selected=_first+(_YLine)
        if _Selected>_TextureNum then _Selected=0
        gosub _refresh_texture_list
        MW_Ink(18,64,192,255)
        MW_Set_cursor(18,42,16+((_YLine)*16))
        MW_print(18,right$(_textures$(_Selected),16))
        if _selected>0 then gosub _DisplayPreviewTexture
       endif
     endif
    if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
    MW_Sync(0)
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    sync
   until _quit=1 or MW_window_Exist(18)=0
  _quit=0
  if _delete_texture>0
    rem On décale la liste des textures de -1
    for boucle=_delete_texture to _texturenum-1
      _textures$(boucle)=_textures$(boucle+1)
     next boucle
    dec _TextureNum,1
rem   endif
    if image exist(_FirstTextureImage+_TextureNum+1)=1 then delete image (_FirstTextureImage+_TextureNum+1)
    Rem ON REACTUALISE LES IMAGES DES TEXTURES
    for boucle=1 to _TextureNum
      txt$=_Textures$(boucle)
      if file exist(txt$)
        if image exist(_FirstTextureImage+boucle)=1 then delete image (_FirstTextureImage+boucle)
        _Load_Image(txt$,(_FirstTextureImage+boucle),_TextureType)
       else
        if file exist(_TexturePath$+txt$)
          if image exist(_FirstTextureImage+boucle)=1 then delete image (_FirstTextureImage+boucle)
          _Load_Image(_TexturePath$+txt$,(_FirstTextureImage+boucle),_TextureType)
         endif
       endif
     next boucle
    REM Suppression de la texture dans les objets et décalage de -1 pour les suivantes.
    for boucle=2 to lastobject step 1
      if _obj(boucle,10)=_delete_texture
        _obj(boucle,10)=0
        Fct_Refresh_Object(boucle)
       endif
      if _obj(boucle,10)>_delete_texture
        _obj(boucle,10)=_obj(boucle,10)-1
        Fct_Refresh_Object(boucle)
       endif
     next boucle
    Rem Suppression de la texture dans les matrices et décalage de -1 pour les suivantes.
    If _LastMatrix>0
      For Boucle=1 to _LastMatrix
        _modified=0
        For ZT=0 to _Matrix(boucle,5)
          For XT=0 to _Matrix(boucle,4)
            _TILE=_Matrix_Tile(boucle,xt,zt)
            if _TILE=_delete_texture then _TILE=1 : _modified=1
            if _TILE>_delete_texture then dec _TILE,1 : _modified=1
            _Matrix_Tile(boucle,xt,zt)=_TILE
           next xt
         next zt
        if _modified=1 then _3DMe_Refresh_Matrix(boucle,_FirstTextureImage,_texturenum)
       Next Boucle
     Endif
    _delete_texture=0
    gosub _display_texture
   endif
  _Obj(1,8)=_numtexture
  if MW_Window_Exist(18)=1 then MW_Close_Window(18)
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *         RAFRAICHIR L'AFFICHAGE DE LA LISTE DES TEXTURES DANS LA FENETRE DE SELECTION DES TEXTURES         *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_refresh_texture_list:
  MW_Paste_Image(18,11,0,0)
  MW_Ink(18,0,0,0)
  MW_Set_Cursor(18,13,0)
  _lastt=_first+7
  if _lastt>_texturenum then _lastt=_texturenum
  yp=16
  MW_Ink(18,255,255,255)
  for boucle=_first to _lastt
    _textureused=0
    for sousboucle=2 to lastobject
      if _obj(sousboucle,10)=boucle then inc _textureused
     next sousboucle
    MW_Set_Cursor(18,8,yp)
    MW_Print(18,str$(_textureused))
    MW_Set_Cursor(18,42,yp)
    MW_Print(18,right$(_textures$(boucle),16))
    inc yp,16
   next boucle
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *              AFFICHER LE MEDAILLON D'UNE TEXTURE DANS LA FENETRE DE SUPPRESSION DE TEXTURES               *
Rem *                                                                                                           *
Rem *************************************************************************************************************
 _Displaypreviewtexture:
  file$=_textures$(_selected)
  if bitmap exist(1)=1 then delete bitmap 1

  MW_Sync(0) : sync
  if file exist(_texturepath$+file$)=1
    load bitmap _texturepath$+file$,1
   else
    if file exist(file$)=1
      load bitmap file$,1
     endif
   endif
  MW_Sync(0) : sync
  xbitmap=bitmap width(1) : ybitmap=bitmap height(1)
  MW_Copy_Bitmap2Window(1,0,0,xbitmap-1,ybitmap-1,18,112,159,191,238)
  MW_Sync(0) : sync
  delete bitmap 1
  set current bitmap 0
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                                  AJOUTER UN OBJET PRIMITIF - SPHERE -                                     *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Create_Sphere:
  choice=0
  Fct_Create_Sphere(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
 Return
_Create_Cube:
  choice=0
  Fct_Create_Cube(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
 Return
_Create_Box:
  choice=0
  Fct_Create_Box(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
 Return
_Create_Cylinder:
  choice=0
  Fct_Create_Cylinder(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
 Return
_Create_Cone:
  choice=0
  Fct_Create_Cone(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
 Return
_Create_Plain:
  choice=0
  Fct_Create_Plain(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
 Return
_Create_Light:
  choice=0
  Inc _LightNum
  fct_create_light(newobj,_lightnum,lastx,lasty,lastz)
  _Obj(1,16)=_LightNum
 Return
_Create_3DSound:
  choice=0
  fct_Create_3DSound(newobj,_3Dsoundobject,lastx,lasty,lastz)
 Return
Rem *************************************************************************************************************
_Create_DirectX:
  choice=0
  xcp#=camera position x()
  ycp#=camera position y()
  zcp#=camera position z()
  if _current3dobject>0
  rem Définition de l'objet 3D.
    if file exist(_3DObjectPath$+_DirectXObject$(_current3dobject))=1
      load object _3DObjectPath$+_DirectXObject$(_current3dobject),newobj
     else
      if file exist(_DirectXObject$(_current3dobject))=1
        load object _DirectXObject$(_current3dobject),newobj
       endif
     endif
    _obj(newobj,1)=lastx
    _obj(newobj,2)=lasty
    _obj(newobj,3)=lastz
    if _zoom#<>0
      finalx#=object size x(newobj) : finalx#=finalx#*_zoom# : finalx=int(finalx#)
      finaly#=object size y(newobj) : finaly#=finaly#*_zoom# : finaly=int(finaly#)
      finalz#=object size z(newobj) : finalz#=finalz#*_zoom# : finalz=int(finalz#)
     else
       finalx=object size x(newobj)
       finaly=object size y(newobj)
       finalz=object size z(newobj)
      endif
    _obj(newobj,4)=finalx
    _obj(newobj,5)=finaly
    _obj(newobj,6)=finalz
    _obj(newobj,7)=(10+_current3dobject)
    _obj(newobj,8)=128
    _Obj(newobj,15)=128
    _Obj(newobj,16)=128
    _obj(newobj,9)=0
    _obj(newobj,10)=defaulttexture
    position camera xcp#,ycp#,zcp#
    Fct_Refresh_Object(newobj)
  endif
 Return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                                        DEPLACER L'OBJET COURANT                                           *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Move_Object:
  choice=0
  if lastobject=1 then return
  Fct_Move_Object(newobj)
  lastx=_obj(newobj,1)
  lasty=_obj(newobj,2)
  lastz=_obj(newobj,3)
 Return
Rem *************************************************************************************************************
_Scale_Object:
  choice=0
  if lastobject=1 then return
  Fct_Scale_Object(newobj)
 Return
Rem *************************************************************************************************************
_Rotate_Object:
  choice=0
  if lastobject=1 then return
  Fct_Rotate_Object(newobj)
 Return
Rem *************************************************************************************************************
_Ghost_Mode:
  choice=0
  if lastobject=1 then return
  Fct_Ghost_Object(newobj)
 Return
Rem *************************************************************************************************************
_Select_Object:
  choice=0
  if lastobject=1 then return
  newobj=Fct_select_Object(newobj,lastobject)
 Return
Rem *************************************************************************************************************
_Copy_Object:
  choice=0
  if _obj(newobj,7)=8 or _obj(newobj,7)=9 then return
  if lastobject=1 then return
  inc lastobject
  _Obj(1,1)=lastobject
    xc#=camera position x()
    yc#=camera position y()
    zc#=camera position z()
  for boucle=1 to 27
    _Obj(lastobject,boucle)=_Obj(newobj,boucle)
   next boucle
  newobj=lastobject
  Fct_Refresh_Object(newobj)
  position camera xc#,yc#,zc#
 Return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                                DETRUIRE L'OBJET 3D COURANT DE LA CARTE                                    *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Kill_Object:
  choice=0
  if lastobject=1 then return
  if _obj(newobj,7)=8 then gosub _Kill_Light
  if object exist(lastobject) then delete object lastobject
  if sound exist(lastobject) then stop sound lastobject
  if newobj<lastobject
    for boucle=newobj to (lastobject-1)
      for sousboucle=1 to 25
        _Obj(boucle,sousboucle)=_Obj(boucle+1,sousboucle)
       next sousboucle
     next boucle
   endif
  for boucle=1 to 25
    _Obj(lastobject,boucle)=0
   next boucle
  dec lastobject
  if newobj>lastobject then newobj=lastobject
  if lastobject>1
    for boucle=newobj to lastobject
      Fct_Refresh_Object(boucle)
     next boucle
   endif
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *           OPTIMISZE LES OBJETS 3D PRESENTS DANS LA CARTE PAR RAPPORT A LEUR DISTANCES RESPECTIVES         *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Optimize_Objects:
  choice=0
  if lastobject=1 then return
  Fct_Optimize_Objects(lastobject)
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                            MODIFICATION DES ATTRIBUTS DE L'OBJET EN COURS                                 *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Object_Properties:
  choice=0
  if lastobject=1 then return
  Fct_Object_Properties(newobj)
 Return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                     DEFINIR LA COULEUR ET L'INTENSITE DE LA LUMIERE AMBIANTE                              *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Ambient_Light:
  choice=0
  _AmbientRed=_Obj(1,9)
  _AmbientGreen=_Obj(1,10)
  _AmbientBlue=_Obj(1,11)
  _AmbientLight=_Obj(1,12)
  repeat
    MW_background_Task()
    Inc _AmbientRed,upkey()-downkey()
    Inc _AmbientGreen,rightkey()-leftkey()
    key=scancode()
    if key=pageupkey then Inc _AmbientBlue
    if key=pagedownkey then Dec _AmbientBlue
    if key=inserkey then Inc _AmbientLight
    if key=supprkey then Dec _AmbientLight
    If _AmbientRed<0 then _AmbientRed=0
    If _AmbientGreen<0 then _AmbientGreen=0
    If _AmbientBlue<0 then _AmbientBlue=0
    If _AmbientLight<0 then _AmbientLight=0
    If _AmbientRed>255 then _AmbientRed=255
    If _AmbientGreen>255 then _AmbientGreen=255
    If _AmbientBlue>255 then _AmbientBlue=255
    If _AmbientLight>100 then _AmbientLight=100
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,_Dialogue$(61))
    MW_Print(12,"R:"+str$(_AmbientRed))
    MW_Print(12,"V:"+str$(_AmbientGreen))
    MW_Print(12,"B:"+str$(_AmbientBlue))
    MW_Print(12,"I:"+str$(_AmbientLight))
    color ambient light Rgb(_AmbientRed,_AmbientGreen,_AmbientBlue)
    set ambient light _AmbientLight
    if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    MW_sync(0)
    sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  _Wait_MouseClick0()
  _Obj(1,9)=_AmbientRed
  _Obj(1,10)=_AmbientGreen
  _Obj(1,11)=_AmbientBlue
  _Obj(1,12)=_AmbientLight
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                            DEFINIR LA DIRECTION DE LA LUMIERE AMBIANTE                                    *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_ambient_orientation:
  choice=0
  _AmbientX=_Obj(1,13)
  _AmbientY=_Obj(1,14)
  _AmbientZ=_Obj(1,15)
  repeat
    MW_background_Task()
    Inc _AmbientX,upkey()-downkey()
    Inc _AmbientY,rightkey()-leftkey()
    key=scancode()
    if key=pageupkey then Inc _AmbientZ
    if key=pagedownkey then Dec _AmbientZ
    If _AmbientX<-1 then _AmbientX=-1
    If _AmbientY<-1 then _AmbientY=-1
    If _AmbientZ<-1 then _AmbientZ=-1
    If _AmbientX>1 then _AmbientX=1
    If _AmbientY>1 then _AmbientY=1
    If _AmbientZ>1 then _AmbientZ=1
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12, _Dialogue$(61))
    MW_Print(12,"Xo:"+str$(_AmbientX))
    MW_Print(12,"Yo:"+str$(_AmbientY))
    MW_Print(12,"Zo:"+str$(_AmbientZ))
    set directional light 0,_AmbientX,_AmbientY,_AmbientZ
    if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    MW_sync(0)
    Sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  _Wait_MouseClick0()
  _Obj(1,13)=_AmbientX
  _Obj(1,14)=_AmbientY
  _Obj(1,15)=_AmbientZ
  return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *    DEFINIR L'ORIENTATION DE LA LUMIERE COURANTE ( DESACTIVE DANS LES DERNIERES VERSIONS DE L'EDITEUR )    *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Light_Orientation:
  choice=0
  if lastobject=1 then return
  _AmbientX=_Lights(_LightNum,9)
  _AmbientY=_Lights(_LightNum,10)
  _AmbientZ=_Lights(_LightNum,11)
  repeat
    MW_BackGround_Task()
    Inc _AmbientX,upkey()-downkey()
    Inc _AmbientY,rightkey()-leftkey()
    key=scancode()
    if key=pageupkey then Inc _AmbientZ
    if key=pagedownkey then Dec _AmbientZ
    If _AmbientX<-1 then _AmbientX=-1
    If _AmbientY<-1 then _AmbientY=-1
    If _AmbientZ<-1 then _AmbientZ=-1
    If _AmbientX>1 then _AmbientX=1
    If _AmbientY>1 then _AmbientY=1
    If _AmbientZ>1 then _AmbientZ=1
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,_Dialogue$(62))
    MW_Print(12,"X:"+str$(_AmbientX))
    MW_Print(12,"Y:"+str$(_AmbientY))
    MW_Print(12,"Z:"+str$(_AmbientZ))
    _Lights(1,9)=_AmbientX
    _Lights(1,10)=_AmbientY
    _Lights(1,11)=_AmbientZ
    _checkFor7Lights()
    if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    MW_sync(0)
    Sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  _Wait_MouseClick0()
  return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                          DEFINIR L'INTENSITE ET LA COULEUR DE LA LUMIERE COURANTE                         *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_light_Intensity:
  choice=0
  if lastobject=1 then return
  _LightRed=_Lights(_LightNum,4)
  _LightGreen=_Lights(_LightNum,5)
  _LightBlue=_Lights(_LightNum,6)
  _LightLight=_Lights(_LightNum,8)
  repeat
    MW_background_Task()
    Inc _LightRed,upkey()-downkey()
    Inc _LightGreen,rightkey()-leftkey()
    key=scancode()
    if key=pageupkey then Inc _LightBlue
    if key=pagedownkey then Dec _LightBlue
    if key=inserkey then Inc _LightLight
    if key=supprkey then Dec _LightLight
    If _LightRed<(0-255) then _LightRed=(0-255)
    If _LightGreen<(0-255) then _LightGreen=(0-255)
    If _LightBlue<(0-255) then _LightBlue=(0-255)
    If _LightLight<(0-255) then _LightLight=(0-255)
    If _LightRed>255 then _LightRed=255
    If _LightGreen>255 then _LightGreen=255
    If _LightBlue>255 then _LightBlue=255
    If _LightLight<10 then _LightLight=10
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,_Dialogue$(62))
    MW_Print(12,"R:"+str$(_LightRed))
    MW_Print(12,"V:"+str$(_LightGreen))
    MW_Print(12,"B:"+str$(_LightBlue))
    MW_Print(12,"I:"+str$(_LightLight))
    _Lights(_LightNum,4)=_LightRed
    _Lights(_LightNum,5)=_LightGreen
    _Lights(_LightNum,6)=_LightBlue
    _Lights(_LightNum,8)=_LightLight
    _checkFor7Lights()
    if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    MW_sync(0)
    Sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  repeat
   until spacekey()=0 and mouseclick()=0
  return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                               DETRUIRE UNE LUMIERE ET LES EVENEMENTS ASSOCIES                             *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Kill_Light:
  choice=0
  if lastobject=1 then return
  _lightkilled=_Obj(newobj,14)
  if _lightkilled<_lightnum
    for boucle=_lightkilled to (_lightnum-1)
      for sousboucle=1 to 16
        _Lights(boucle,sousboucle)=_Lights(boucle+1,sousboucle)
       next sousboucle
     next boucle
   endif
  for boucle=1 to 16
    _Lights(_lightnum,boucle)=0
   next boucle
  dec _lightnum
  _checkFor7Lights()
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                         DETRUIRE UN OBJET 3D DE LA LISTE ET LES OBJETS ASSOCIES                           *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Kill_3dobject:
  choice=0
  if _DirectXObject=0 then Return
  _first=1
  If MW_Window_Exist(19)=0
    MW_Open_New_Window(19,_Dialogue$(68),196,242,1,1,0)
    MW_Position_Window(19,128,12)
    MW_Paste_Image(19,11,0,0)
   Endif
  rem set camera view 0,12,bitmap width(0),bitmap height(0)
  gosub _refresh_3DObject_list
  _delete_3dobject=0
  repeat
    MW_Background_Task()
    _wnd=MW_Current_Window()
    if _wnd=19
      xm=MW_Window_Position_X() : ym=MW_Window_Position_Y()
     else
      xm=0 : ym=0
     endif
    if mouseclick()=1 and ym>0
      if xm>15 and xm<78
        if ym>176 and ym<193
          _quit=1 : Rem QUITTE PAR LA FONCTION 'ANNULER'
         endif
        if ym>156 and ym<173
          _delete_DirectXObject=_selected
          _quit=1
         endif
       endif
      if xm>169 and xm<186
        if ym>15 and ym<32
          dec _first
          _ref3dobject=1
         endif
        if ym>127 and ym<144
          inc _first
          _ref3dobject=1
         endif
       endif
      if _ref3dobject=1
        _ref3dobject=0
        if _first>(_DirectXObject-7) then _first=_DirectXObject-7
        if _first<1 then _first=1
        gosub _refresh_3dObject_list
       endif
      if xm>33 and xm<170 and ym>15 and ym<144
        _YLine=(ym-28)/16
        _Selected=_first+(_YLine)
        if _Selected>_DirectXObject then _Selected=0
        gosub _refresh_3DObject_list
        MW_Ink(19,64,192,255)
        MW_Set_Cursor(19,42,16+(_YLine*16))
        MW_Print(19,right$(_DirectXObject$(_Selected),16))
       endif
     endif
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    MW_Sync(0)
    Sync
   until _quit=1 or MW_window_Exist(19)=0
  _quit=0
  If MW_Window_Exist(19)=1 then MW_Close_Window(19)
  if _delete_DirectXObject>0
    rem On décale la liste des textures de -1
    for boucle=_delete_DirectXObject to _DirectXObject-1
      _DirectXObject$(boucle)=_DirectXObject$(boucle+1)
     next boucle
    dec _DirectXObject,1
rem   endif
    Rem ON REACTUALISE LES IMAGES DES TEXTURES
    REM Suppression de la texture dans les objets et décalage de -1 pour les suivantes.
    for boucle=lastobject to 2 step -1
      if _obj(boucle,7)=(_delete_DirectXObject+10)
        newobj=boucle
        gosub _kill_object
rem        refobj=boucle
rem        gosub _refresh_object
       endif
      if _obj(boucle,7)>(_delete_DirectXObject+10)
        Fct_Refresh_Object(boucle)
       endif
     next boucle
    _delete_DirectXObject=0
   endif
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                        SELECTIONNER UN SON OBJET DANS LA LISTE EN MEMOIRE                                 *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Select_3dobject:
  choice=0
  if _DirectXObject=0 then Return
  If MW_Window_Exist(19)=0
    MW_Open_New_Window(19,_Dialogue$(68+2),196,242,1,1,0)
    MW_Position_Window(19,128,12)
    MW_Paste_Image(19,11,0,0)
   Endif
  _first=1
  rem set camera view 0,12,bitmap width(0),bitmap height(0)
  gosub _refresh_3DObject_list
  _delete_3dobject=0
  repeat
    MW_Background_Task()
    _wnd=MW_Current_Window()
    if _wnd=19
      xm=MW_Window_Position_X() : ym=MW_Window_Position_Y()
     else
      xm=0 : ym=0
     endif
    if mouseclick()=1 and ym>0
      if xm>15 and xm<78
        if ym>176 and ym<193
          _quit=1 : Rem QUITTE PAR LA FONCTION 'ANNULER'
         endif
        if ym>156 and ym<173
          _delete_DirectXObject=_selected
          _quit=1
         endif
       endif
      if xm>169 and xm<186
        if ym>15 and ym<32
          dec _first
          _ref3dobject=1
         endif
        if ym>127 and ym<144
          inc _first
          _ref3dobject=1
         endif
       endif
      if _ref3dobject=1
        _ref3dobject=0
        if _first>(_DirectXObject-7) then _first=_DirectXObject-7
        if _first<1 then _first=1
        gosub _refresh_3dObject_list
       endif
      if xm>33 and xm<170 and ym>15 and ym<144
        _YLine=(ym-16)/16
        _Selected=_first+(_YLine)
        if _Selected>_DirectXObject then _Selected=0
        gosub _refresh_3DObject_list
        MW_Ink(19,64,192,255)
        MW_Set_Cursor(19,42,16+(_YLine*16))
        MW_Print(19,right$(_DirectXObject$(_Selected),16))
       endif
     endif
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    MW_sync(0)
    sync
   until _quit=1 or MW_Window_Exist(19)=0
  _quit=0
  If MW_Window_Exist(19)=1 then MW_Close_Window(19)
  rem set camera view 0,12,bitmap width(0),bitmap height(0)
  if _delete_DirectXObject>0
     _current3dobject=_delete_DirectXObject
    _delete_DirectXObject=0
   endif
  s3do=0
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *       RAFRAICHIR L'AFFICHAGE DE LA LISTE DES OBJETS 3D DANS LA FENETRE DE SELECTION DE D'OBJETS 3D        *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_refresh_3DObject_list:
  MW_paste_image(19,11,0,0)
  MW_Ink(19,0,0,0)
  MW_Set_Cursor(19,11,0)
  _lastt=_first+7
  if _lastt>_DirectXObject then _lastt=_DirectXObject
  yp=16
  MW_Ink(19,255,255,255)
  for boucle=_first to _lastt
    _textureused=0
    for sousboucle=2 to lastobject
      if _obj(sousboucle,7)=(boucle+10) then inc _textureused
     next sousboucle
    MW_Set_Cursor(19,8,yp)
    MW_Print(19, str$(_textureused))
    MW_Set_Cursor(19,42,yp)
    MW_Print(19,right$(_DirectXObject$(boucle),16))
    inc yp,16
   next boucle
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                        DETRUIRE UN SON 3D DE LA LISTE ET LES EVENEMENTS SONORES ASSOCIES                  *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Kill_3dsound:
  choice=0
  if _3DSoundObject=0 then Return
  If MW_Window_Exist(20)=0
    MW_Open_New_Window(20,_Dialogue$(69),196,242,1,1,0)
    MW_Position_Window(20,128,12)
    MW_Paste_Image(20,11,0,0)
   Endif
  _first=1
  rem set camera view 0,12,bitmap width(0),bitmap height(0)
  gosub _refresh_3DSound_list
  _delete_3dsound=0
  repeat
    MW_Background_Task()
    _wnd=MW_Current_Window()
    if _wnd=20
      xm=MW_Window_Position_X() : ym=MW_Window_Position_Y()
     else
      xm=0 : ym=0
     endif
    if mouseclick()=1 and ym>0
      if xm>15 and xm<78
        if ym>176 and ym<193
          _quit=1 : Rem QUITTE PAR LA FONCTION 'ANNULER'
         endif
        if ym>156 and ym<173
          _delete_3DSound=_selected
          _quit=1
         endif
       endif
      if xm>169 and x<186
        if ym>15 and ym<32
          dec _first
          _ref3dsound=1
         endif
        if ym>127 and ym<144
          inc _first
          _ref3dsound=1
         endif
       endif
      if _ref3dsound=1
        _ref3dsound=0
        if _first>(_3DSoundObject-7) then _first=_3DSoundObject-7
        if _first<1 then _first=1
        gosub _refresh_3dsound_list
       endif
      if xm>33 and xm<170 and ym>15 and ym<144
        _YLine=(ym-16)/16
        _Selected=_first+(_YLine)
        if _Selected>_3DSoundObject then _Selected=0
        gosub _refresh_3dsound_list
        MW_Ink(20,64,192,255)
        MW_Set_Cursor(20,42,16+(_YLine*16))
        MW_Print(20,right$(_3DSound$(_Selected),16))
       endif
     endif
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    MW_Sync(0)
    Sync
   until _quit=1 or MW_Window_Exist(20)=0
  _quit=0
  if MW_window_Exist(20)=1 then MW_Close_Window(20)
  rem set camera view 0,12,bitmap width(0),bitmap height(0)
  if _delete_3dsound>0
    rem On décale la liste des textures de -1
    for boucle=_delete_3Dsound to _3DSoundObject-1
      _3DSound$(boucle)=_3DSound$(boucle+1)
     next boucle
    dec _3DSoundObject,1
rem   endif
    Rem ON REACTUALISE LES IMAGES DES TEXTURES
    REM Suppression de la texture dans les objets et décalage de -1 pour les suivantes.
    for boucle=lastobject to 2 step -1
      if _obj(boucle,7)=9
        if _obj(boucle,14)=_delete_3dsound
          newobj=boucle
          gosub _kill_object
         else
          if _obj(boucle,14)>_delete_3dsound
rem            _obj(boucle,14)=(_obj(boucle,14))-1
            Fct_Refresh_Object(boucle)
           endif
         endif
       endif
     next boucle
    _delete_3dsound=0
   endif
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                        SELECTIONNER UN SON 3D DANS LA LISTE EN MEMOIRE                                    *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Select_3dsound:
  choice=0
  if _3DSoundObject=0 then Return
  If MW_Window_Exist(20)=0
    MW_Open_New_Window(20,_Dialogue$(69+2),196,242,1,1,0)
    MW_Position_Window(20,128,12)
    MW_Paste_Image(20,11,0,0)
   Endif
  _first=1
  gosub _refresh_3DSound_list
  _delete_3dsound=0
  repeat
    MW_Background_Task()
    _wnd=MW_Current_Window()
    if _wnd=20
      xm=MW_Window_Position_X() : ym=MW_Window_Position_Y()
     else
      xm=0 : ym=0
     endif
    if mouseclick()=1 and ym>0
      if xm>15 and xm<78
        if ym>176 and ym<193
          _quit=1 : Rem QUITTE PAR LA FONCTION 'ANNULER'
         endif
        if ym>156 and ym<173
          _delete_3DSound=_selected
          _quit=1
         endif
       endif
      if xm>169 and xm<186
        if ym>15 and ym<32
          dec _first
          _ref3dsound=1
         endif
        if ym>127 and ym<144
          inc _first
          _ref3dsound=1
         endif
       endif
      if _ref3dsound=1
        _ref3dsound=0
        if _first>(_3DSoundObject-7) then _first=_3DSoundObject-7
        if _first<1 then _first=1
        gosub _refresh_3dsound_list
       endif
      if xm>33 and xm<170 and ym>15 and ym<144
        _YLine=(ym-16)/16
        _Selected=_first+(_YLine)
        if _Selected>_3DSoundObject then _Selected=0
        gosub _refresh_3dsound_list
        MW_Ink(20,64,192,255)
        MW_Set_Cursor(20,42,16+(_YLine*16))
        MW_Print(20,right$(_3DSound$(_Selected),16))
       endif
     endif
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    MW_sync(0)
    Sync
   until _quit=1 or MW_Window_Exist(20)=0
  _quit=0
  if MW_Window_Exist(20)=1 then MW_Close_Window(20)
  rem set camera view 0,12,bitmap width(0),bitmap height(0)
  _Current_3dsound=_delete_3dsound
  _delete_3dsound=0
  s3ds=0
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *           RAFRAICHIR L'AFFICHAGE DE LA LISTE DES SONS 3D DANS LA FENETRE DE SELECTION DE SONS 3D          *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_refresh_3Dsound_list:
  MW_Paste_Image(20,11,0,0)
  MW_Ink(20,0,0,0)
  MW_Set_Cursor(20,11,0)
  _lastt=_first+7
  if _lastt>_3dsoundobject then _lastt=_3dsoundobject
  yp=16
  for boucle=_first to _lastt
    _textureused=0
    for sousboucle=2 to lastobject
      if _obj(sousboucle,7)=9 and _obj(sousboucle,14)=boucle then inc _textureused
     next sousboucle
    MW_Ink(20,255,255,255)
    MW_Set_Cursor(20,8,yp)
    MW_Print(20,str$(_textureused))
    MW_Set_Cursor(20,42,yp)
    MW_Print(20,right$(_3dsound$(boucle),16))
    inc yp,16
   next boucle
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                         PASSAGE DU MODE NORMAL à PREVIEW et PREVIEW à NORMAL                              *
Rem *                                                                                                           *
Rem *************************************************************************************************************
Rem Now use real Exploration mode.
_FogTest:
  choice=0
  hide object 1
  gosub _3D_Exploration
  show object 1
  fog off
 Return
  inc _fogtype
  if _fogtype=2 then _fogtype=0
  if _fogtype=0
    fog off
    color backdrop rgb(_BgdRedGRB,_BgdGreenRGB,_BgdBlueRGB)
    show object 1
   else
    hide object 1
    fog color rgb(_FogRedRGB,_FogGreenRGB,_FogBlueRGB)
    fog distance _fogdistance
    color backdrop rgb(_FogRedRGB,_FogGreenRGB,_FogBlueRGB)
    fog on
   endif
 sync
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                             APPROCHER OU ELOIGNER LA DISTANCE DU BROUILLARD                               *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Fog_Far:
  choice=0
  _fogdistance=_fogdistance+100
  fog distance _fogdistance
 return
_Fog_Near:
  choice=0
  _fogdistance=_fogdistance-50
  if _fogdistance<100 then _fogdistance=100
  fog distance _fogdistance
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                        DEFINITION DU CHOIX DU LANGAGE FRANCAIS/ENGLAIS                                    *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Set_Language:
  Fct_SetLanguage(_LANGUAGE$)
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                        SAUVER LE POSITIONNEMENT ET L'ANGLE DE VUE DE LA CAMERA                            *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Save_Camera_View:
  choice=0
  Fct_Save_Camera_States()
 return
_Scan_For_shortcuts:
  choice=fct_scan_keyboards()
 Return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                                     Utilisateur enregistré ou shareware ?                                 *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Registration_Check:
  L=len(_RegisteredUser$)
  restore donnees_password
  if L>7
    for boucle=1 to 16
      read comp(boucle)
      if comp(boucle)>L then comp(boucle)=comp(boucle)-8
     next boucle
    password$=""
    for boucle=1 to 16 step 1
      charac$=mid$(_RegisteredUser$,comp(boucle)) : Rem EXTRACTION DU CHARACTERE DU NOM D'UTILISATEUR.
      if charac$=" " then charac$="z"
      number=asc(charac$)-97 : Rem CONVERTION DE CE CARACTERE EN NOMBRE ( "a"=97 )
      inc number,comp(boucle)
      if number>9 then dec number,10
      if number>9 then dec number,10
      if number>9 then dec number,10
      password$=password$+chr$(number+48)
     next boucle
    _Check=0
    for boucle=1 to 16
      chr1$=mid$(_RegisteredID$,boucle)
      chr2$=mid$(Password$,boucle)
      if chr1$=chr2$ then inc _Check
     next boucle
    if _check=16 then _Registered=1
   endif
  Rem If a beta Tester exist The register to beta tester
  If _Beta_Tester1$<>""
    _RegisteredUser$=_Beta_Tester1$
    _Registered=1
    _RegisteredID$="0000000000000000"
   endif
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                                   REAL PREVIEW MODE FOR 3D EXPLORATION                                    *
Rem *                                                                                                           *
Rem *************************************************************************************************************
Rem Chargement du décor de fond.
rem load image "background2.jpg",numtextures+1
_3D_Exploration:
  Hide sprite 2
  xc=camera position x()
  yc=camera position y()
  zc=camera position z()
  player=lastobject+1
  rem set camera view 0,0,640,480
  Load Sound "viewsound/woodstep.wav",1022
  Load Sound "viewsound/scream1.wav",1023
Rem  _set_fog(0,0,0,4000)
  set camera range 1,4000
Rem  color backdrop rgb(0,0,0)
  load music "musics\default.mid",1
  play music 1
  loop music 1
  Rem Création de l'objet représentant le personnage.
  make object box player,6,80,6
  set object collision on player
position object player,xc,yc,zc
hide object player
rem position camera object position x(player),object position y(player),object position z(player)
make object collision box player,-16,-40,-16,16,40,16,0
for boucle=2 to lastobject
  xp=_obj(boucle,1) : yp=_obj(boucle,2) : zp=_obj(boucle,3)
  xs=_obj(boucle,4) : if xs<2 then xs=2
  ys=_obj(boucle,5) : if ys<2 then ys=2
  zs=_obj(boucle,6) : if zs<2 then zs=2
  kind=_obj(boucle,7) : xrot=_obj(boucle,11) : yrot=_obj(boucle,12) : zrot=_obj(boucle,13)
  _HiddenObject=_Obj(boucle,26) : _ObjectCollisions=_Obj(boucle,27)
  if _HiddenObject=1 or kind=8 or kind=9 then hide object boucle
  if _ObjectCollisions=1 and ( kind<8 or kind>9 )
    set object collision on boucle
   else
    set object collision off boucle
   endif
 next boucle
Rem Cache les zones d'action
if _last_zone>0
  for boucle=1 to _last_zone
    if object exist(65536-boucle) then hide object 65536-boucle
   next boucle
 endif
Rem **************************************************
Rem *                                                *
Rem * DEBUT DE LA BOUCLE PRINCIPALE DU MOTEUR DE JEU *
Rem *                                                *
Rem **************************************************
Rem INITIALISATION DE LA ZONE DE CIEL AVANT LA BOUCLE PRINCIPALE.
Rem
set object collision off 1
Rem On initialise la SkyBox.
_initialize_zones()
Rem
repeat
  paste image 1,0,0,0
  oldx#=object position x(player)
  oldy#=object position y(player)
  oldz#=object position z(player)
Rem Calcul du nouvel angle de vue selon le déplacement de la souris.
  position mouse 320,240
  cx#=wrapvalue(cx#+(mousemovey()/2))
  cy#=wrapvalue(cy#+(mousemovex()/2))

rem Avancer , reculer ( , se déplacer en strafe )
  course#=(shiftkey()/2.0)+1.0
  player_walk=upkey()-downkey()
  if player_walk<>0
    move object player,movespeed*player_walk
    humanwalk=wrapvalue(humanwalk+(walkspeed*course#))
  endif
  strafe=rightkey()-leftkey()
  if strafe<>0
    cy2#=wrapvalue(cy#+(90*strafe))
    rotate object player,0,cy2#,0
    move object player,movespeed
    rotate object player,0,cy#,0
   endif
  x#=object position x(player)
  y#=oldy#
  z#=object position z(player)
  position object player,x#,y#,z#

Rem calcul des collisions de l'objets aux murs .
  set object collision on player
  x#=object position x(player)
  y#=object position y(player)
  z#=object position z(player)

Rem calcul simple d'une marche.
  if object collision(player,0)>0
    position object player,x#,y#+16,z#
    if object collision(player,0)=0
      inc y#,16
      for boucle=1 to 4
        position object player,x#,y#-4,z#
        if object collision(player,0)=0 then y#=y#-4
       next boucle
     endif
   endif
  position object player,x#,y#,z#
Rem Collision aux murs !
  if object collision(player,0)>0
    x#=x#-get object collision x()
    z#=z#-get object collision z()
  endif
  position object player,x#,y#,z#
Rem Si le mur n'est pas sur un angle de 0°,90°,180°,270°
  if object collision(player,0)>0
    x#=oldx#
    z#=oldz#
    position object player,x#,y#,z#
   endif
ground=0
  Rem Calcul de l'apesanteur
  if jump<1 and ground=0
    position object player,x#,y#-4,z#
    if object collision(player,0)=0
      y#=(y#-4)
     else
      ground=1
      position object player,x#,y#,z#
     endif
   endif
Rem Calcul de collision avec les matrices
  newy#=_Check_for_ground(x#,y#,z#,object size y(player))
  if newy#<>y# then ground=1
  y#=newy#
  position object player,x#,y#,z#
  Rem le joueur veut sauter ?
  if jump=0 and ground=1 and mouseclick()=2 then jump=16

  Rem On crée le saut et on vérifie qu'il n'y aie pas de plafond!
    if jump>0
      position object player,x#,y#+4,z#
      if object collision(player,0)=0
        dec jump
        if jump=0 then jump=0
        y#=(y#+4)
       else
        jump=0
     endif
   endif
  rem position object player,x#,y#,z#
  rem Object and Camera are linked for easy calculation of collisions !
  rotate object player,0,cy#,0
  rotate camera cx#,cy#,0
  humancalc=cos(humanwalk)*4
  position camera object position x(player),object position y(player)+32+humancalc,object position z(player)

rem   scroll backdrop (cy#/4),(cx#/4)
  if humanwalk>190 and humanwalk<211 and jump=0 and ground=1
    play sound 1022
    humanwalk=humanwalk+10
   endif
Rem Important : Recalcul de la vitesse du joueur selon le nombre d'images par secondes.
  movespeed=4*course#
  inc _lightcheck
  if _lightcheck=16
    _checkFor7Lights() : Rem vérifie et met 7 lumières MAX !
    _lightcheck=0
   endif
Rem
Rem GESTION DES ZONES D'ACTIONS JUSTE AVANT LAsync
  _check_all_zones()
Rem
  set cursor 0,0
  ink rgb(255,255,255),rgb(0,0,0)
  for boucle=1 to _zone_data(1)
    if _zone_inside(boucle)=1 then print "inside zone #";boucle
   next boucle
 sync
 until spacekey()=1 or camera position y()<-200

Rem ON DOIT DESACTIVER TOUTE LES ZONES ACTIVES !!!! ET REMETTRE TOUT A 0.
  _quit_all_zones()
  _replace_skyobject()

Rem FIN DE LA BOUCLE PRINCIPALE DU JEU !!!
 delete object player
 play sound 1023
 wait 1000
Rem
Rem On efface les objets 3D crées.
if music exist(1)=1
  stop music 1
  delete music 1
 endif
delete sound 1022
delete sound 1023
color backdrop rgb(_BgdRedGRB,_BgdGreenRGB,_BgdBlueRGB)
_set_fog(_FogRedRGB,_FogGreenRGB,_FogBlueRGB,_fogdistance)
rem set camera view 0,12,bitmap width(0),bitmap height(0)
paste image 1,0,0
sync
movespeed=16
movespeedneg=0-movespeed
for boucle=2 to lastobject
  show object boucle
  set object collision off boucle
 next boucle
Rem re affiche les zones d'action
if _last_zone>0
  for boucle=1 to _last_zone
    if object exist(65536-boucle) then show object 65536-boucle
   next boucle
 endif
  Show sprite 2
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                        MISE EN PLACE D'UN SKIN DIFFERENT DE CELUI PAR DEFAUT                              *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_MAKE_SKIN:
  if _skin$="" or file exist(_edpath$+"\editor\"+_skin$)=0 or _Registered=0
    restore DEFAULT_SKIN_DATA
    boucle=0
    repeat
      inc boucle,1
      read _skin_data$(boucle)
     until _skin_data$(boucle)="END_SKIN"
   else
    open to read 1,_edpath$+"\editor\"+_skin$
    boucle=0
    repeat
      inc boucle,1
      read string 1,_skin_data$(boucle)
     until _skin_data$(boucle)="END_SKIN"
    close file 1
   endif
 Return
DEFAULT_SKIN_DATA:
data "3DMe Theme Skin : DEFAULT 3DME SKIN"
data "Author : Frederic Cordier"
data " "
data "COMMON_FILES:"
data "editor\mainwindow_v3.jpg"
data "editor\case.jpg"
data "editor\mouse.bmp"
data "editor\mousebusy.bmp"
data "editor\mire.jpg"
data "editor\emptybox.bmp"
data "editor\checkedbox.bmp"
data "ENGLISH_FILES:"
data "editor\fileselector_v1_english.jpg"
data "editor\objectattributes_v1_english.jpg"
data "editor\zoneproperties_v1_english.jpg"
data "editor\objectselection_v1_english.jpg"
data "editor\menu_item.jpg"
data "editor\add_matrix_v1_english.jpg"
data "editor\matrixattributes_v1_english.jpg"
data "editor\matrix_rndheight_v1_english.jpg"
data "FRENCH_FILES:"
data "editor\fileselector_v1_french.jpg"
data "editor\objectattributes_v1_french.jpg"
data "editor\zoneproperties_v1_french.jpg"
data "editor\objectselection_v1_french.jpg"
data "editor\menu_item.jpg"
data "editor\add_matrix_v1_french.jpg"
data "editor\matrixattributes_v1_french.jpg"
data "editor\matrix_rndheight_v1_french.jpg"
Data "END_SKIN"

Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                     SOUS-PROGRAMMES SUR LA GESTION DES ZONE D'ACTION                                      *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_create_zone:
  choice=0
  if _registered=0 and _last_zone>15 then return
  if _last_zone>255 then return
  inc _last_zone
  _current_zone=_last_zone
  _zone_data(1)=_last_zone
  _zone_info(_last_zone,1)=0 : Rem ZONE NULLE PAR DEFAUT !!!
  _zone_info(_last_zone,2)=lastx
  _zone_info(_last_zone,3)=lasty
  _zone_info(_last_zone,4)=lastz
  for boucle=5 to 7
    _zone_info(_last_zone,boucle)=defaultboxsize
   next boucle
  for boucle=8 to 16
    _zone_info(_last_zone,boucle)=0
   next boucle
  _zone_ref=_last_zone
  gosub _refresh_zone
 return

_Move_Zone:
  choice=0
  if _last_zone=0 then return
  xposinit=_zone_info(_current_zone,2)
  yposinit=_zone_info(_current_zone,3)
  zposinit=_zone_info(_current_zone,4)
  repeat
    MW_Background_Task()
    xpos=_zone_info(_current_zone,2)
    ypos=_zone_info(_current_zone,3)
    zpos=_zone_info(_current_zone,4)
    key=scancode()
    if key=pageupkey then ypos=ypos+defaultstep
    if key=pagedownkey then ypos=ypos-defaultstep
    if upkey()=1 then zpos=zpos+defaultstep
    if downkey()=1 then zpos=zpos-defaultstep
    if leftkey()=1 then xpos=xpos-defaultstep
    if rightkey()=1 then xpos=xpos+defaultstep
    if key=inserkey then inc defaultstep
    if key=supprkey then dec defaultstep
    if defaultstep=0 then defaultstep=1
    if defaultstep>128 then defaultstep=128
    if key=defaultkey
      xpos=xposinit
      ypos=yposinit
      zpos=zposinit
     endif
    _zone_info(_current_zone,2)=xpos
    _zone_info(_current_zone,3)=ypos
    _zone_info(_current_zone,4)=zpos
    position object 65536-(_current_zone),xpos,ypos,zpos
    if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,_Dialogue$(66))
    MW_Print(12,"X="+str$(xpos))
    MW_Print(12,"Y="+str$(ypos))
    MW_Print(12,"Z="+str$(zpos))
    MW_Print(12,_Dialogue$(56)+str$(defaultstep))
    MW_Sync(0)
    Sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  _Wait_MouseClick0()
  lastx=xpos
  lasty=0
  lastz=zpos
 Return

_Scale_zone:
  choice=0
  if _last_zone=0 then return
  xsizeinit=_zone_info(_current_zone,5)
  ysizeinit=_zone_info(_current_zone,6)
  zsizeinit=_zone_info(_current_zone,7)
  repeat
    MW_Background_Task()
    xc#=camera position x()
    yc#=camera position y()
    zc#=camera position z()
    xsize=_zone_info(_current_zone,5)
    ysize=_zone_info(_current_zone,6)
    zsize=_zone_info(_current_zone,7)
    key=scancode()
    if key=pageupkey then ysize=ysize+defaultstep
    if key=pagedownkey then ysize=ysize-defaultstep
    if upkey()=1 then zsize=zsize+defaultstep
    if downkey()=1 then zsize=zsize-defaultstep
    if leftkey()=1 then xsize=xsize+defaultstep
    if rightkey()=1 then xsize=xsize-defaultstep
    if key=inserkey then inc defaultstep
    if key=supprkey then dec defaultstep
    if defaultstep=0 then defaultstep=1
    if defaultstep>128 then defaultstep=128
    if xsize<1 then xsize=1
    if ysize<1 then ysize=1
    if zsize<1 then zsize=1
    if key=defaultkey
      xsize=xsizeinit
      ysize=ysizeinit
      zsize=zsizeinit
     endif
    _zone_info(_current_zone,5)=xsize
    _zone_info(_current_zone,6)=ysize
    _zone_info(_current_zone,7)=zsize
    _zone_ref=_current_zone
    gosub _Refresh_Zone
    if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
    MW_ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,_Dialogue$(67))
    MW_Print(12,"X="+str$(xsize))
    MW_Print(12,"Y="+str$(ysize))
    MW_Print(12,"Z="+str$(zsize))
    MW_Print(12,_Dialogue$(56)+str$(defaultstep))
    MW_sync(0)
    Sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  _Wait_MouseClick0()
 Return

_refresh_zone:
  Autocam Off
  if _zone_ref>0
    if object exist(65536-_zone_ref) then delete object 65536-_zone_ref
    xp=_zone_info(_zone_ref,2)
    yp=_zone_info(_zone_ref,3)
    zp=_zone_info(_zone_ref,4)
    xs=_zone_info(_zone_ref,5)
    ys=_zone_info(_zone_ref,6)
    zs=_zone_info(_zone_ref,7)
    make object box 65536-_zone_ref,xs,ys,zs
    position object 65536-_zone_ref,xp,yp,zp
    color object 65536-_zone_ref,rgb(240,224,128)
    ghost object on 65536-_zone_ref
    set object collision off 65536-_zone_ref
    set object 65536-_zone_ref,1,1,0
   endif
 return

_Select_zone:
  choice=0
  if _last_zone=0 then return
  repeat
    key=scancode()
    if key=inserkey
      _zone_ref=_current_zone
      gosub _refresh_zone
      inc _current_zone
     endif
    if key=supprkey
      _zone_ref=_current_zone
      gosub _refresh_zone
      dec _current_zone
     endif
    if _current_zone>_last_zone then _current_zone=_last_zone
    if _current_zone<1 then _current_zone=1
    if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,_Dialogue$(60))
    MW_Print(12,"    "+str$(_current_zone))
    if object exist(65536-_current_zone) then texture object 65536-_current_zone,5
    MW_sync(0)
    Sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  _Wait_MouseClick0()
  _zone_ref=_current_zone
  gosub _refresh_zone
 Return

_kill_zone:
  choice=0
  if _last_zone=0 then return
  if object exist(65536-_last_zone) then delete object 65536-_last_zone
  if _current_zone=_last_zone
    for boucle=1 to 16
      _zone_info(_current_zone,boucle)=0
     next boucle
    _zone_filename$(_current_zone)=""
    dec _last_zone
   else
    for boucle=_current_zone+1 to _last_zone
      for sousboucle=1 to 16
        _zone_info(boucle-1,sousboucle)=_zone_info(boucle,sousboucle)
       next sousboucle
      _zone_filename$(boucle-1)=_zone_filename$(boucle)
     next boucle
    for boucle=1 to 16
      _zone_info(_last_zone,boucle)=0
      _zone_filename$(_last_zone)=""
     next boucle
    dec _last_zone
   endif
  for _zone_ref=1 to _last_zone
    gosub _refresh_zone
   next _zone_ref
  _zone_data(1)=_last_zone
 return

 _zone_properties:
  choice=0 : _quit=0
  _refresh=1
  If MW_Window_Exist(21)=0
    MW_Open_New_Window(21,"",396,246,1,1,0)
    MW_Position_Window(21,128,12)
    MW_Paste_Image(21,11,0,0)
   Endif
  repeat
    MW_background_Task()
    _wnd=MW_Current_Window()
    if _wnd=21
      xcurs=MW_Window_Position_X() : ycurs=MW_Window_Position_Y()
     else
      xcurs=0 : ycurs=0
     endif
    if mouseclick()>0 and ycurs>0
      if mouseclick()=2 then ajout=10 else ajout=1
      if mouseclick()=3 then ajout=100
      gosub _check_cases

      MW_Cls(12,32,32,32)
      MW_Set_Cursor(12,0,0)
      MW_Print(12,str$(xcurs))
      MW_Print(12,str$(ycurs))
      MW_Print(12,str$(xcase))
      MW_Print(12,str$(ycase))

      Rem Changer de zone à éditer
      if ycase=1
        if xcase=1 and _current_zone>1 then dec _current_zone
        if xcase=2 and _current_zone<_last_zone then inc _current_zone
        if xcase=1 or xcase=2 then _refresh=1
       endif
      Rem Changer le type de zone
      if ycase=2
        if xcase=1 and _zone_info(_current_zone,1)>0 then _zone_info(_current_zone,1)=_zone_info(_current_zone,1)-1
        if xcase=2 and _zone_info(_current_zone,1)<6 then _zone_info(_current_zone,1)=_zone_info(_current_zone,1)+1
        if xcase=1 or xcase=2 then _refresh=1
        if _zone_info(_current_zone,1)=0
          for boucle=8 to 15
            _zone_info(_current_zone,boucle)=0
           next boucle
         endif
        if _zone_info(_current_zone,1)=1
          for boucle=13 to 15
            _zone_info(_current_zone,boucle)=0
           next boucle
         endif
        if _zone_info(_current_zone,1)=2
          for boucle=11 to 14
            _zone_info(_current_zone,boucle)=0
           next boucle
         endif
        if _zone_info(_current_zone,1)=3 or _zone_info(_current_zone,1)=4
          for boucle=8 to 10
            _zone_info(_current_zone,boucle)=0
           next boucle
          _zone_info(_current_zone,14)=0
          _zone_info(_current_zone,15)=0
         endif
        if _zone_info(_current_zone,1)=5
          _zone_info(_current_zone,14)=0
          _zone_info(_current_zone,15)=0
         endif
        if _zone_info(_current_zone,1)=6
          for boucle=8 to 15
            _zone_info(_current_zone,boucle)=0
           next boucle
         endif
       endif
      Rem Changer la composante ROUGE / VERTE / BLEUE
      if ycase=5 or ycase=6 or ycase=7
        dat=(ycase+3)
        if xcase=1 and _zone_info(_current_zone,dat)>ajout then _zone_info(_current_zone,dat)=_zone_info(_current_zone,dat)-ajout
        if xcase=2 and _zone_info(_current_zone,dat)<(255-ajout) then _zone_info(_current_zone,dat)=_zone_info(_current_zone,dat)+ajout
        if xcase=1 or xcase=2 then _refresh=1
       endif
      Rem Changer FOG DISTANCE / VOLUME / AMPLITUDE
      if ycase=8
        if xcase=1 and _zone_info(_current_zone,11)>ajout then _zone_info(_current_zone,11)=_zone_info(_current_zone,11)-ajout
        if xcase=2 then _zone_info(_current_zone,11)=_zone_info(_current_zone,11)+ajout
        Rem Vérification des limites de cette valeur selon le type de zone utilisé.
        if _zone_info(_current_zone,1)=0 then _zone_info(_current_zone,11)=0
        if _zone_info(_current_zone,1)=1 and _zone_info(_current_zone,11)<100 then _zone_info(_current_zone,11)=100
        if _zone_info(_current_zone,1)=2 then _zone_info(_current_zone,11)=0
        if _zone_info(_current_zone,1)=3 and _zone_info(_current_zone,11)>63 then _zone_info(_current_zone,11)=63
        if _zone_info(_current_zone,1)=4 and _zone_info(_current_zone,11)>63 then _zone_info(_current_zone,11)=63
        if _zone_info(_current_zone,1)=5 and _zone_info(_current_zone,11)>99 then _zone_info(_current_zone,11)=99
        if _zone_info(_current_zone,1)=6 then _zone_info(_current_zone,11)=0
        if xcase=1 or xcase=2 then _refresh=1
       endif
      Rem Changer la valeur de fading #1
      if ycase=9
        if xcase=1 and _zone_info(_current_zone,12)>ajout then _zone_info(_current_zone,12)=_zone_info(_current_zone,12)-ajout
        if xcase=2 then _zone_info(_current_zone,12)=_zone_info(_current_zone,12)+ajout
        if _zone_info(_current_zone,1)=0 then _zone_info(_current_zone,12)=0
        if _zone_info(_current_zone,1)=2 then _zone_info(_current_zone,12)=0
        if _zone_info(_current_zone,1)=6 then _zone_info(_current_zone,12)=0
        if xcase=1 or xcase=2 then _refresh=1
       endif
      Rem Changer la valeur de fading #2
      if ycase=10
        if xcase=1 and _zone_info(_current_zone,13)>ajout then _zone_info(_current_zone,13)=_zone_info(_current_zone,13)-ajout
        if xcase=2 then _zone_info(_current_zone,13)=_zone_info(_current_zone,13)+ajout
        if _zone_info(_current_zone,1)=0 then _zone_info(_current_zone,13)=0
        if _zone_info(_current_zone,1)=2 then _zone_info(_current_zone,13)=0
        if _zone_info(_current_zone,1)=6 then _zone_info(_current_zone,13)=0
        if xcase=1 or xcase=2 then _refresh=1
       endif
      Rem Changer la valeur de la gravité d'une zone
      if ycase=12
        if xcase=1 and _zone_info(_current_zone,15)>0 then _zone_info(_current_zone,15)=_zone_info(_current_zone,15)-1
        if xcase=2 and _zone_info(_current_zone,15)<2 then _zone_info(_current_zone,15)=_zone_info(_current_zone,15)+1
        if _zone_info(_current_zone,1)<>2 then _zone_info(_current_zone,15)=0
        if xcase=1 or xcase=2 then _refresh=1
       endif
      Rem Changer la valeur de désactivation d'une zone.
      if ycase=13
        if xcase=1 and _zone_info(_current_zone,16)>0 then _zone_info(_current_zone,16)=_zone_info(_current_zone,16)-1
        if xcase=2 and _zone_info(_current_zone,16)<15 then _zone_info(_current_zone,16)=_zone_info(_current_zone,16)+1
        if xcase=1 or xcase=2 then _refresh=1
       endif
      Rem Changer le numero de la texture utilisée par la zone.
      if ycase=14
        if xcase=1 and _zone_info(_current_zone,17)>0 then _zone_info(_current_zone,17)=_zone_info(_current_zone,17)-1
        if xcase=2 and _zone_info(_current_zone,17)<_TextureNum then _zone_info(_current_zone,17)=_zone_info(_current_zone,17)+1
        if _zone_info(_current_zone,1)=0 then _zone_info(_current_zone,17)=0
        if _zone_info(_current_zone,1)=3 then _zone_info(_current_zone,17)=0
        if _zone_info(_current_zone,1)=4 then _zone_info(_current_zone,17)=0
        if _zone_info(_current_zone,1)=5 then _zone_info(_current_zone,17)=0
        if xcase=1 or xcase=2 then _refresh=1
       endif
      Rem
      Rem SELECTION DU FICHIER A UTILISER AVEC LA ZONE MUSIQUE / SONS
      Rem
      if _zone_info(_current_zone,1)<3 or _zone_info(_current_zone,1)>4 then _zone_filename$(_current_zone)=""
      if ycase=15 and xcase=2
        fichier$=""
        _loaderpath$=_edpath$
        if _zone_info(_current_zone,1)=3
          _loaderpath$=_musPath$
          filter1$=".mid" : filter2$=".mp3"
         endif
        if _zone_info(_current_zone,1)=4
          _loaderpath$=_soundPath$
          filter1$=".wav" : filter2$=".mp3"
         endif
        title$=_Dialogue$(52)
        REM FILE SELECTOR FUNCTION USE
        fileselector$(2)=title$
        Fct_File_Selector_v1(_loaderpath$,filter1$,filter2$)
        _dossierfinal$=fileselector$(8)
        _fichierfinal$=fileselector$(9)
        REM
        rem set camera view 0,12,bitmap width(0),bitmap height(0)
        if file exist(_loaderPath$+_fichierfinal$)=1
          fichier$=_fichierfinal$
         else
          fichier$=_dossierfinal$+_fichierfinal$
         endif
        _refresh=1
        if fichier$<>"" then _zone_filename$(_current_zone)=fichier$
        Rem
       endif
     endif
    if _refresh=1 then gosub _refresh_zone_properties
    if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
    sprite 2,mousex(),mousey(),3
    MW_sync(0)
    sync
   until _quit=1 or MW_Window_Exist(21)=0
  _quit=0 : _refresh=0
  if MW_Window_Exist(21)=1 then MW_Close_Window(21)
  rem set camera view 0,12,bitmap width(0),bitmap height(0)
 return
_check_cases:
  xc=xcurs : yc=ycurs
  xcase=0 : ycase=0
  if xc>7 and xc<24 then xcase=1
  if xc>25 and xc<42 then xcase=2
  if xcase<>0
    ycase=(yc/16)+1
    if ycase>15 then ycase=0
   endif
  _Wait_MouseClick0()
 return
_refresh_zone_properties:
  _refresh=0
  MW_Paste_Image(21,10,0,0)
  ink rgb(255,255,255),rgb(0,0,0)
  Rem Affichage du numéro de la zone en cours.
  MW_Set_Cursor(21,44,4) : MW_Print(21,str$(_current_zone))
  Rem Affichage du type de zone crée.
  dis=_zone_info(_current_zone,1)
  MW_Set_Cursor(21,44,20) : MW_Print(21,_zone_type$(dis))
  Rem Affichage des positions de la zone.
  MW_Set_Cursor(21,44,36)
  MW_Print(21,str$(_zone_info(_current_zone,2))+","+str$(_zone_info(_current_zone,3))+","+str$(_zone_info(_current_zone,4)))
  Rem Affichage des dimensions de la zone.
  MW_Set_Cursor(21,44,52)
  MW_Print(21,str$(_zone_info(_current_zone,5))+","+str$(_zone_info(_current_zone,6))+","+str$(_zone_info(_current_zone,7)))
  Rem Affichage des 3 composantes de couleur si zone utilise
  MW_Set_Cursor(21,44,68) : MW_Print(21,str$(_zone_info(_current_zone,8)))
  MW_Set_Cursor(21,44,84) : MW_Print(21,str$(_zone_info(_current_zone,9)))
  MW_Set_Cursor(21,44,100) : MW_Print(21,str$(_zone_info(_current_zone,10)))
  Rem Affichage de la valeur FOG_DISTANCE/VOLUME/AMPLITUDE
  MW_Set_Cursor(21,44,116) : MW_Print(21,str$(_zone_info(_current_zone,11)))
  Rem Affichage des valeurs de Fading In/Out
  MW_Set_Cursor(21,44,132) : MW_Print(21,str$(_zone_info(_current_zone,12)))
  MW_Set_Cursor(21,44,148) : MW_Print(21,str$(_zone_info(_current_zone,13)))
  Rem Affichage de valeur nulle
  Rem
  Rem Affichage de la gravité utilisé.
  MW_Set_Cursor(21,44,180) : MW_Print(21,_zone_gravity$(_zone_info(_current_zone,15)))
  Rem Affichage si la zone est destructible et en combien de coups.
  MW_Set_Cursor(21,44,196) : MW_Print(21,str$(_zone_info(_current_zone,16)))
  Rem Affichage de la couleur de la zone dans la boite réservée.
  MW_Ink(21,_zone_info(_current_zone,8),_zone_info(_current_zone,9),_zone_info(_current_zone,10))
  MW_Box(21,345,68,392,115)
  Rem Affichage de la texture utilisée si texture>0
  MW_Ink(21,255,255,255)
  MW_Set_Cursor(21,44,212) : MW_Print(21,str$(_zone_info(_current_zone,17)))
  if _zone_info(_current_zone,17)>0
    imagenum=_firsttextureimage+_zone_info(_current_zone,17)
    if image exist(imagenum)=1
      MW_Sync(0) : Sync
      create bitmap 1,256,256
      paste image imagenum,0,0
      MW_Copy_Bitmap2Window(1,0,0,127,127,21,329,175,392,238)
      delete bitmap 1
      MW_Sync(0) : Sync
     endif
   endif
  Rem Affichage du nom du fichier joint à la zone si existant
  if _zone_filename$(_current_zone)<>""
    MW_Set_Cursor(21,44,228) : MW_Print(21,right$(_zone_filename$(_current_zone),16))
   endif
 return
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                                        GESTION DES MATRICES DE 3DGC                                       *
Rem *                                                                                                           *
Rem *************************************************************************************************************
_Create_New_Matrix:
  choice=0
  if _Registered=0 and _LastMatrix>15 then return
  XTiles=8 : ZTiles=8 : XSize=32 : ZSize=32
  xc=camera position x() : yc=camera position y() : zc=camera position z()
  xa=camera angle x() : ya=camera angle y() : za=camera angle z()
  rem set camera view 0,12,bitmap width(0),bitmap height(0)
  xpos=384/2 : ypos=400/2
  _quit=0
  If MW_Window_Exist(22)=0
    MW_Open_New_Window(22,"",252,76,1,1,0)
    MW_Position_Window(22,128,12)
    MW_Paste_Image(22,22,0,0)
   Endif
Repeat
  MW_Background_Task()
  MW_Paste_Image(22,22,0,0)
  MW_Ink(22,255,255,255)
  MW_Set_Cursor(22,96,16) : MW_Print(22,str$(XTiles))
  MW_Set_Cursor(22,160,16) : MW_Print(22,str$(ZTiles))
  MW_Set_Cursor(22,96,46) : MW_Print(22,str$(XSize))
  MW_Set_Cursor(22,160,46) : MW_Print(22,str$(ZSize))
  _wnd=MW_Current_Window()
  if _wnd=22
    xm=MW_Window_Position_X() : ym=MW_Window_Position_Y()
   else
    xm=0 : ym=0
   endif
  if mouseclick()=1 and ym>0
    if xm>202 and xm<251 and ym>60 and ym<75 then _quit=1
    if xm>153 and xm<202 and ym>60 and ym<75 then _quit=2
    if ym>15 and ym<30
      if xm>133 and xm<145 then dec xtiles,1 : _slow=1
      if xm>144 and xm<156 then inc xtiles,1 : _slow=1
      if xm>196 and xm<208 then dec ztiles,1 : _slow=1
      if xm>207 and xm<219 then inc ztiles,1 : _slow=1
     endif
    if ym>45 and ym<60
      if xm>133 and xm<145 then dec xsize,1 : _slow=1
      if xm>144 and xm<156 then inc xsize,1 : _slow=1
      if xm>196 and xm<208 then dec zsize,1 : _slow=1
      if xm>207 and xm<219 then inc zsize,1 : _slow=1
     endif
   endif
  if xtiles<2 then xtiles=2
  if xtiles>64 then xtiles=64
  if ztiles<2 then ztiles=2
  if ztiles>64 then ztiles=64
  if xsize<8 then xsize=8
  if zsize<8 then zsize=8
  if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
  sprite 2,mousex(),mousey(),3
  MW_Sync(0) : sync
  if _slow=1
    MW_Sync(0) : sync : MW_Sync(0) : sync : MW_Sync(0) :sync : _slow=0
   endif
 until _quit>0 or MW_Window_Exist(22)=0
  _Wait_MouseClick0()
  if MW_Window_Exist(22)=1 then MW_Close_Window(22)
  if _quit=2
    inc _LastMatrix,1
    _3DME_Add_New_Matrix(_Lastmatrix,lastx,lasty,lastz,XTiles,ZTiles,XSIZE,ZSIZE)
    _CurrentMatrix=_LastMatrix
   endif
  position camera xc,yc,zc
  rotate camera xa,ya,za
  _Matrix(0,0)=_LastMatrix
 Return
Rem ---------------------------------------------------
_Delete_Current_Matrix:
  choice=0
  if _CurrentMatrix>0
    _3DME_Delete_Matrix(_currentmatrix)
    if _CurrentMatrix<_LastMatrix
      For boucle=_CurrentMatrix to _LastMatrix-1
        for sb=1 to 16
          _Matrix(boucle,sb)=_Matrix(boucle+1,sb)
         next sb
        for sb1=0 to _matrix(boucle+1,4)
          for sb2=0 to _matrix(boucle+1,5)
            _Matrix_Height(boucle,sb1,sb2)=_Matrix_Height(boucle+1,sb1,sb2)
            _Matrix_Tile(boucle,sb1,sb2)=_Matrix_Tile(boucle+1,sb1,sb2)
           next sb2
         next sb1
       Next boucle
      For boucle=1 to _lastmatrix-1
        if matrix exist(boucle)=1 then _3DME_Delete_Matrix(boucle)
        MW_Background_Task() : MW_sync(0) : sync
        _3DMe_Refresh_Matrix(boucle,_FirstTextureImage,_texturenum)
       Next boucle
     endif
    if matrix exist(_lastmatrix)=1 then _3DME_Delete_Matrix(_lastmatrix)
    MW_Background_Task() : MW_sync(0) : sync
    dec _lastmatrix,1
    if _currentmatrix>_lastmatrix then _currentmatrix=_lastmatrix
   endif
  _Matrix(0,0)=_LastMatrix
 Return
Rem ---------------------------------------------------
_Move_Matrix:
  choice=0
  if _CurrentMatrix>0 then _3DME_Move_Matrix(_CurrentMatrix)
 Return
Rem ---------------------------------------------------
_change_point_height:
  choice=0
  if _CurrentMatrix>0 then _3DME_Move_Matrix_Point(_CurrentMatrix)
 Return
Rem ---------------------------------------------------
_texture_matrix_tile:
  choice=0
  if _CurrentMatrix>0 then _3DME_Texture_Matrix_Tiles(_CurrentMatrix,_FirstTextureImage,_texturenum)
 Return
Rem ---------------------------------------------------
_define_matrix_properties:
  choice=0
  if _CurrentMatrix>0 then _Matrix_Properties(_CurrentMatrix)
 Return
Rem ---------------------------------------------------
_select_another_matrix:
  choice=0
  if _LastMatrix>1 then _CurrentMatrix=Fct_Select_Matrix(_CurrentMatrix,_LastMatrix)
 Return
Rem ---------------------------------------------------
_make_random_height:
  choice=0
  ymax=64 : ymin=0 : y0=32 : alfa=32
  xc=camera position x() : yc=camera position y() : zc=camera position z()
  xa=camera angle x() : ya=camera angle y() : za=camera angle z()
  rem set camera view 0,12,bitmap width(0),bitmap height(0)
  xpos=384/2 : ypos=400/2
  _quit=0
  If MW_Window_Exist(23)=0
    MW_Open_New_Window(23,"",252,76,1,1,0)
    MW_Position_Window(23,128,12)
    MW_Paste_Image(23,24,0,0)
   Endif
Repeat
  MW_Background_Task()
  MW_Paste_Image(23,24,0,0)
  MW_Ink(23,255,255,255)
  MW_Set_Cursor(23,96,16) : MW_Print(23,str$(ymax))
  MW_Set_Cursor(23,160,16) : MW_Print(23,str$(ymin))
  MW_Set_Cursor(23,96,46) : MW_Print(23,str$(y0))
  MW_Set_Cursor(23,160,46) : MW_Print(23,str$(alfa))
  _wnd=MW_Current_Window()
  if _wnd=23
    xm=MW_Window_Position_X() : ym=MW_Window_Position_Y()
   else
    xm=0 : ym=0
   endif
  if mouseclick()=1 and ym>0
    if xm>202 and xm<251 and ym>60 and ym<75 then _quit=1
    if xm>153 and xm<202 and ym>60 and ym<75 then _quit=2
    if ym>15 and ym<30
      if xm>133 and xm<145 then dec ymax,1 : _slow=1
      if xm>144 and xm<156 then inc ymax,1 : _slow=1
      if xm>196 and xm<208 then dec ymin,1 : _slow=1
      if xm>207 and xm<219 then inc ymin,1 : _slow=1
     endif
    if ym>45 and ym<60
      if xm>133 and xm<145 then dec y0,1 : _slow=1
      if xm>144 and xm<156 then inc y0,1 : _slow=1
      if xm>196 and xm<208 then dec alfa,1 : _slow=1
      if xm>207 and xm<219 then inc alfa,1 : _slow=1
     endif
   endif
  if ymax<(ymin+4) then ymax=ymin+4
  if ymin>(ymax-4) then ymin=ymax-4
  if y0<(ymin+2) then y0=ymin+2
  if y0>(ymax-2) then y0=ymax-2
  if alfa<2 then alfa=2
  if alfa>256 then alfa=256
  if mouseclick()=1 then _3DMeMW_Check_Mouse_View()
  sprite 2,mousex(),mousey(),3
  MW_Sync(0)
  sync
  if _slow=1
    MW_Sync(0) : sync : MW_Sync(0) : sync : MW_Sync(0) :sync : _slow=0
   endif
 until _quit>0 or MW_Window_Exist(23)=0
rem set camera view 0,12,bitmap width(0),bitmap height(0)
  _Wait_MouseClick0()
  if MW_Window_Exist(23)=1 then MW_Close_Window(23)
  if _quit=2
    _3DME_Random_Height(_currentmatrix,ymax,ymin,y0,alfa)
   endif
  position camera xc,yc,zc
  rotate camera xa,ya,za
  _Matrix(0,0)=_LastMatrix
 Return
Rem ---------------------------------------------------
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                     DONNEES POUR LA DEFINITION DES CODES IDENTIFIANTS UTILISATEUR                         *
Rem *                                                                                                           *
Rem *************************************************************************************************************
donnees_password:
  Data 10,4,15,7,16,2,1,6
  Data 8,13,11,5,9,14,12,3

menus_values:
data 1,1,1,1,2,21,1,3,2,1,4,3,1,5,4,1,6,5,1,7,6,1,8,7
data 1,9,25,1,10,26,1,11,27,1,12,24,1,13,22
data 2,1,9,2,2,10,2,3,11,2,4,12,2,5,13,2,6,14,2,7,15,2,8,16
data 2,9,17,2,10,32,2,11,33,2,12,34,2,13,35
data 2,14,31,2,15,36,2,16,30,2,17,37
data 3,1,28,3,2,29,3,3,8
data 4,1,42,4,2,43,4,3,44,4,4,45,4,5,46,4,6,47,4,7,0,4,8,49
data 4,9,50,4,10,51,4,11,52,4,12,53,4,13,54,4,14,55,4,15,56,4,16,57
data 5,1,58,5,2,59,5,3,60
data 0,0,0

gadgets_values:
data 9
data 2,6,1,21,2,22,23,24
data 3,7,3,4,18,19,20,39,40
data 4,4,5,10,6,7
data 5,4,25,11,26,27
data 6,4,9,8,28,29
data 7,6,12,13,14,15,16,17
data 8,9,32,33,34,35,36,31,38,37,30
data 9,6,42,43,44,45,46,47
data 10,9,49,50,51,52,53,54,55,56,57
Rem ---------------------------------------------------
Function _Wait_MouseClick0()
  repeat
    MW_Sync(0)
    Sync
   Until MouseClick()=0
 EndFunction
Rem ---------------------------------------------------
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                     DOCUMENTATION SUR LE FORMAT DES DONNEES CONCERNANT LES CARTES 3D                      *
Rem *                                                                                                           *
Rem *************************************************************************************************************
REMSTART
Liste des variables importantes
LastObject   = Numéro du dernier objet existant pour le décor.
_Obj(1,x)    = Données importantes pour la définition de la carte :
  _Obj(1,1)  = LastObject
  _Obj(1,2)  = XCamera Start \
  _Obj(1,3)  = YCamera Start  > Définissent la position initiale du joueur dans la carte 3D.
  _Obj(1,4)  = ZCamera Start /
  _Obj(1,5)  = XCamera Rotate \
  _Obj(1,6)  = YCamera Rotate  > Définissent la rotation de la camera au point initial.
  _Obj(1,7)  = ZCamera Rotate /
  _Obj(1,8)  = Number of textures to be loaded.
  _Obj(1,9)  = Ambient Light Red component.
  _Obj(1,10) = Ambient Light Green component.
  _Obj(1,11) = Ambient Light Blue component.
  _Obj(1,12) = Ambient Light Intensity.
  _Obj(1,13) = Ambient X Orientation.
  _Obj(1,14) = Ambient Y Orientation.
  _Obj(1,15) = Ambient Z Orientation.
  _Obj(1,16) = Nombre de lumières crées.

_Obj(a,B)    = Valeurs de définition pour l'objet a ( 2<a<(lastobject+1) )
  _Obj(a,1)  = XObject Position \
  _Obj(a,2)  = YObject Position  > Coordonnées initiales de l'objet 'a'
  _Obj(a,3)  = ZObject Position /
  _Obj(a,4)  = XObject Size \
  _Obj(a,5)  = YObject Size  > Dimensions initiales de l'objet 'a'
  _Obj(a,6)  = ZObject Size /
  _Obj(a,7)  = Type d'objet 3D.
                 Type = 1 : Sphère
                 Type = 2 : Cube
                 Type = 3 : Boite (Box)
                 Type = 4 : Cylindre
                 Type = 5 : Cone
                 Type = 6 : Plan ( Carré / Rectangle )
                 Type = 7 : Triangle ( NOT INPLEMENTED )
                 Type = 8 : Source de lumière
                 Type = 9 : Son 3D
                 Type = 10 : Unused ( NOT INPLEMENTED )
                 Type = 10+: Objects 3D Direct X.
  _Obj(a,8)  = Couleur de l'objet Rouge
  _Obj(a,9)  = Attributs de l'objet ( transparence )
  _Obj(a,10) = Texture de l'objet
  _Obj(a,11) = XObject Rotate \
  _Obj(a,12) = YObject Rotate  > Définissent la rotation initiale de l'objet 'a'
  _Obj(a,13) = ZObject Rotate /
  _Obj(a,14) = Si Object=Light Then _LightNum attributed IDEM For 3D Sound
  _Obj(a,15) = Couleur de l'objet Vert
  _Obj(a,16) = Couleur de l'objet Bleu
  _Obj(a,17) = X Scaling Texture.
  _Obj(a,18) = Y Scaling Texture.
  _Obj(a,19) = Set object function attributes : Wireframe drawing.
  _Obj(a,20) = Set object function attributes : Black is transparent.
  _Obj(a,21) = Set object function attributes : Cull ( show hidden faces ).
  _Obj(a,22) = Set object function attributes : Texture Filtering.
  _Obj(a,23) = Set object function attributes : Sensitive to light.
  _Obj(a,24) = Set object function attributes : Sensitive to Fog.
  _Obj(a,25) = Set object function attributes : Sensitive to ambient light.
  _Obj(a,26) = Set object function attributes : Hide object.
  _Obj(a,27) = Set object function attributes : Collision activation.


  _Lights(a,1) = Light 'a' X Position.
  _Lights(a,2) = Light 'a' Y Position.
  _Lights(a,3) = Light 'a' Z Position.
  _Lights(a,4) = Light Red component.
  _Lights(a,5) = Light Green component.
  _Lights(a,6) = Light Blue component.
  _Lights(a,7) = Light Intensity.
  _Lights(a,8) = Light Range.
  _Lights(a,9) = Light X Orientation.
  _Lights(a,10) = Light Y Orientation.
  _Lights(a,11) = Light Z Orientation.
  _Lights(a,12) = ...
    ...          = ...
  _Lights(a,16) = ...


  _Zone_Info(Zone_Number,Zone_Data)
  _Zone_Info(Zone_Number,1)=0 No Effect Zone
  _Zone_Info(Zone_Number,1)=1 Fog Zone
  _Zone_Info(Zone_Number,1)=2 Water Zone
  _Zone_Info(Zone_Number,1)=3 Music Zone
  _Zone_Info(Zone_Number,1)=4 Sound Zone
  _Zone_Info(Zone_Number,1)=5 Ambient Zone
  _Zone_Info(Zone_Number,1)=6 Sky Box Zone

  _Zone_Info(Zone,2)=X Position
  _Zone_Info(Zone,3)=Y Position
  _Zone_Info(Zone,4)=Z Position
  _Zone_Info(Zone,5)=X Size
  _Zone_Info(Zone,6)=Y Size
  _Zone_Info(Zone,7)=Z Size
  _Zone_Info(Zone,8)=Red
  _Zone_Info(Zone,9)=Green
  _Zone_Info(Zone,10)=Blue
  _Zone_Info(Zone,11)=Distance / Amplitude / Volume
  _Zone_Info(Zone,12)=Fade In/Out #1
  _Zone_Info(Zone,13)=Fade In/Out #2
  _Zone_Info(Zone,14)=Unused
  _Zone_Info(Zone,15)=Gravity type
  _Zone_Info(Zone,16)=Destructive
  _Zone_Info(Zone,17)=Texture for effects.

  _3dme_temp(1) to _3dme_temp(12) are used

  _Matrix(_MATRIX,1)=Matrix X Position
  _Matrix(_MATRIX,2)=Matrix Y Position
  _Matrix(_MATRIX,3)=Matrix Z Position
  _Matrix(_MATRIX,4)=X Number of tiles
  _Matrix(_MATRIX,5)=Z Number of tiles
  _Matrix(_MATRIX,6)=X tiles size
  _Matrix(_MATRIX,7)=Z tiles size
  _Matrix(_MATRIX,8)=Mode GHOST
  _Matrix(_MATRIX,9)=Fil De Fer
  _Matrix(_MATRIX,10)=Transparence
  _Matrix(_MATRIX,11)=faces cachées
  _Matrix(_MATRIX,12)=filtrage de textures
  _Matrix(_MATRIX,13)=sensible à la lumière
  _Matrix(_MATRIX,14)=sensible au brouillard
  _Matrix(_MATRIX,15)=sensible à la lumière ambiante
  _Matrix(_MATRIX,16)=collisions actives.
  _Matrix_Heigth(_MATRIX,X,Z)=Height of the point X,Z of the matrix _MATRIX
  _Matrix_Tile(_MATRIX,X,Z)=Texture used for the tile X,Z of the matrix _MATRIX
 REMEND

Rem CALCUL DES MOUVEMENTS DE LA SOURIS POUR LES CHANGEMENTS DE VUE.
Rem  position mouse 320,240
Rem  cx#=wrapvalue(cx#+((mousemovey()*movespeed))/8)
Rem  cy#=wrapvalue(cy#+((mousemovex()*movespeed))/8)
rem cz#=wrapvalue(cz#+((mousemovez()*movespeed))/8)
Rem  rotate camera cx#,cy#,cz#
rem DEPLACEMENT EN AVANT ET EN ARRIERE AU CLAVIER.
Rem  move camera movespeed*( upkey()-downkey() )

  Rem FENETRE #02 : Système
  Rem FENETRE #03 : TEXTURES
  Rem FENETRE #04 : OBJECTS IMPORTATION
  Rem FENETRE #05 : 3D SOUNDS
  Rem FENETRE #06 : LIGHTS
  Rem FENETRE #07 : OBJECTS ADDING
  Rem FENETRE #08 : OBJECTS MODIFICATIONS
  Rem FENETRE #09 : ACTION ZONES
  Rem FENETRE #10 : MATRIXES
  Rem FENETRE #11 : BUGG!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  Rem FENETRE #12 : ACTIONS
  Rem FENETRE #13 : DIALOGUES
  Rem FENETRE #14 : COUNTER
  Rem FENETRE #15 : PROPRIETES D'OBJETS
  Rem FENETRE #16 : FILE-SELECTOR
  Rem FENETRE #17 : PROPRIETES MATRICES
  Rem FENETRE #18 : KILL TEXTURES
  Rem FENETRE #19 : IMPORTED 3D OBJECTS
  Rem FENETRE #20 : IMPORTED 3D SOUNDS
  Rem FENETRE #21 : ACTION ZONES PROPERTIES
  Rem FENETRE #22 : MATRIX CREATION
  Rem FENETRE #23 : MATRIX RND HEIGHT
  Rem FENETRE #24 : FENETRE DE MINIATURES DES TEXTURES
  Rem  if mouseclick()=1 then 3DMeMW_Check_Mouse_View()

Rem ******************************************
Rem *                                        *
Rem * GESTION DES TEXTES FRANçAIS ET ANGLAIS *
Rem *                                        *
Rem ******************************************
Function Fct_SetLanguage(_LANGUAGE$)
  if _LANGUAGE$="ENGLISH"
    open to read 1,"editor\locales\english.loc"
   else
    open to read 1,"editor\locales\french.loc"
   endif
  boucle=0
  Repeat
    boucle=boucle+1
    Read string 1 , var$
    _Dialogue$(boucle)=var$
   until var$="END_LOC"
  close file 1
 EndFunction

Function Fct_SetZoneLanguage(_LANGUAGE$)
  if _LANGUAGE$="ENGLISH"
    open to read 1,"editor\locales\english_zones.loc"
   else
    open to read 1,"editor\locales\french_zones.loc"
   endif
  for boucle=0 to 6
    read string 1 , zone$
   _zone_type$(boucle)=zone$
   next boucle
  for boucle2=0 to 2
    read string 1 , zone2$
    _zone_gravity$(boucle2)=zone2$
   next boucle2
  close file 1
 EndFunction

Function Fct_Windows_Title(_LANGUAGE$)
  if _LANGUAGE$="ENGLISH"
    open to read 1,"editor\locales\Windows(us).loc"
   else
    open to read 1,"editor\locales\Windows(fr).loc"
   endif
  For boucle=1 to 24
    Read String 1 , var$
    _Windows_Title$(boucle)=var$
   next boucle
  close file 1
 EndFunction

function fct_Create_Sphere(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
  _DefaultObjectValues(newobj,defaultsizex,defaultsizey,defaultsizez)
  _obj(newobj,1)=lastx
  _obj(newobj,2)=lasty
  _obj(newobj,3)=lastz
  _obj(newobj,7)=1
  _obj(newobj,10)=defaulttexture
  fct_refresh_object(newobj)
 EndFunction
Rem ****************************************************************************************************************
function fct_Create_Cube(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
  _DefaultObjectValues(newobj,defaultsizex,defaultsizey,defaultsizez)
  _obj(newobj,1)=lastx
  _obj(newobj,2)=lasty
  _obj(newobj,3)=lastz
  _obj(newobj,7)=2
  _obj(newobj,10)=defaulttexture
  fct_refresh_object(newobj)
 EndFunction
Rem ****************************************************************************************************************
Function fct_Create_Box(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
  _DefaultObjectValues(newobj,defaultsizex,defaultsizey,defaultsizez)
  _obj(newobj,1)=lastx
  _obj(newobj,2)=lasty
  _obj(newobj,3)=lastz
  _obj(newobj,7)=3
  _obj(newobj,10)=defaulttexture
  fct_refresh_object(newobj)
 EndFunction
Rem ****************************************************************************************************************
Function fct_Create_Cylinder(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
  _DefaultObjectValues(newobj,defaultsizex,defaultsizey,defaultsizez)
  _obj(newobj,1)=lastx
  _obj(newobj,2)=lasty
  _obj(newobj,3)=lastz
  _obj(newobj,7)=4
  _obj(newobj,10)=defaulttexture
  fct_refresh_object(newobj)
 EndFunction
Rem ****************************************************************************************************************
Function fct_Create_Cone(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
  _DefaultObjectValues(newobj,defaultsizex,defaultsizey,defaultsizez)
  _obj(newobj,1)=lastx
  _obj(newobj,2)=lasty
  _obj(newobj,3)=lastz
  _obj(newobj,7)=5
  _obj(newobj,10)=defaulttexture
  fct_refresh_object(newobj)
 EndFunction
Rem ****************************************************************************************************************
Function fct_Create_Plain(newobj,lastx,lasty,lastz,defaultsizex,defaultsizey,defaultsizez,defaulttexture)
  _DefaultObjectValues(newobj,defaultsizex,defaultsizey,defaultsizez)
  _obj(newobj,1)=lastx
  _obj(newobj,2)=lasty
  _obj(newobj,3)=lastz
  _obj(newobj,7)=6
  _obj(newobj,10)=defaulttexture
  fct_refresh_object(newobj)
 EndFunction
Rem ****************************************************************************************************************
Function fct_create_light(newobj,_lightnum,lastx,lasty,lastz)
  _obj(newobj,1)=lastx
  _obj(newobj,2)=lasty
  _obj(newobj,3)=lastz
  _obj(newobj,4)=16
  _obj(newobj,7)=8
  _obj(newobj,8)=255
  _obj(newobj,9)=0
  _obj(newobj,10)=0
  _Obj(newobj,14)=_LightNum
  _Obj(newobj,15)=255
  _Obj(newobj,16)=0
  Rem 2> On crée la lumière proprement dite ( c'est à dire ses valeurs )
  _Lights(_LightNum,1)=lastx
  _Lights(_LightNum,2)=lasty
  _Lights(_LightNum,3)=lastz
  _Lights(_LightNum,4)=128
  _Lights(_LightNum,5)=128
  _Lights(_LightNum,6)=128
  _Lights(_LightNum,7)=64
  _Lights(_LightNum,8)=500
  _Lights(_LightNum,9)=0
  _Lights(_LightNum,10)=0
  _Lights(_LightNum,11)=0
  _Lights(_LightNum,12)=newobj
  fct_refresh_object(newobj)
 EndFunction
Rem ****************************************************************************************************************
Function fct_Create_3DSound(newobj,_3Dsoundobject,lastx,lasty,lastz)
  if _3DSoundObject>0
    _obj(newobj,1)=lastx
    _obj(newobj,2)=lasty
    _obj(newobj,3)=lastz
    _obj(newobj,4)=1
    _obj(newobj,5)=1
    _obj(newobj,6)=0
    _obj(newobj,7)=9
    _obj(newobj,8)=128
    _Obj(newobj,15)=128
    _Obj(newobj,16)=128
    _Obj(newobj,14)=_Current_3dsound
    _obj(newobj,9)=0
    _obj(newobj,10)=0
    fct_refresh_object(newobj)
   endif
 EndFunction
Rem ****************************************************************************************************************
Rem
Rem FONCTIONS DE MODIFICATION D'OBJETS.
Rem
Rem ****************************************************************************************************************
Function Fct_Move_Object(newobj)
  defaultstep=32
  pageupkey=201
  pagedownkey=209
  inserkey=210
  supprkey=211
  defaultkey=199
  xposinit=_obj(newobj,1)
  yposinit=_obj(newobj,2)
  zposinit=_obj(newobj,3)
  repeat
    MW_Background_Task()
    xpos=_obj(newobj,1)
    ypos=_obj(newobj,2)
    zpos=_obj(newobj,3)
    key=scancode()
    if key=pageupkey then ypos=ypos+defaultstep
    if key=pagedownkey then ypos=ypos-defaultstep
    if upkey()=1 then zpos=zpos+defaultstep
    if downkey()=1 then zpos=zpos-defaultstep
    if leftkey()=1 then xpos=xpos-defaultstep
    if rightkey()=1 then xpos=xpos+defaultstep
    if key=inserkey then inc defaultstep,1
    if key=supprkey then dec defaultstep,1
    if defaultstep=0 then defaultstep=1
    if defaultstep>128 then defaultstep=128
    if key=defaultkey
      xpos=xposinit
      ypos=yposinit
      zpos=zposinit
     endif
    _obj(newobj,1)=xpos
    _obj(newobj,2)=ypos
    _obj(newobj,3)=zpos
    objkind=_obj(newobj,7)
    if objkind=9 then position sound newobj,xpos,ypos,zpos
    if mouseclick()=1 then _3DMEMW_Check_Mouse_View()
    if objkind=8
      _ObjLight=_obj(newobj,14)
      _Lights(_ObjLight,1)=xpos
      _Lights(_ObjLight,2)=ypos
      _Lights(_ObjLight,3)=zpos
      _checkFor7Lights()
     endif
    position object newobj,xpos,ypos,zpos
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,_Dialogue$(57))
    MW_Print(12,"X="+str$(xpos))
    MW_Print(12,"Y="+str$(ypos))
    MW_Print(12,"Z="+str$(zpos))
    MW_Print(12,_Dialogue$(56)+str$(defaultstep) )
    Xm=mousex() : Ym=mousey()
    Sprite 2,xm,ym,3
    MW_sync(0)
    sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  repeat
   until spacekey()=0 and mouseclick()=0
 EndFunction
Rem ****************************************************************************************************************
Function Fct_Scale_Object(newobj)
  defaultstep=32
  pageupkey=201
  pagedownkey=209
  inserkey=210
  supprkey=211
  defaultkey=199
  xsizeinit=_obj(newobj,4)
  ysizeinit=_obj(newobj,5)
  zsizeinit=_obj(newobj,6)
  repeat
    MW_Background_Task()
    xc#=camera position x()
    yc#=camera position y()
    zc#=camera position z()
    xsize=_obj(newobj,4)
    ysize=_obj(newobj,5)
    zsize=_obj(newobj,6)
    key=scancode()
    if key=pageupkey then ysize=ysize+defaultstep
    if key=pagedownkey then ysize=ysize-defaultstep
    if upkey()=1 then zsize=zsize+defaultstep
    if downkey()=1 then zsize=zsize-defaultstep
    if leftkey()=1 then xsize=xsize+defaultstep
    if rightkey()=1 then xsize=xsize-defaultstep
    if key=inserkey then inc defaultstep,1
    if key=supprkey then dec defaultstep,1
    if defaultstep=0 then defaultstep=1
    if defaultstep>128 then defaultstep=128
    if xsize<1 then xsize=1
    if ysize<1 then ysize=1
    if zsize<1 then zsize=1
    if mouseclick()=1 then _3DMEMW_Check_Mouse_View()
    if key=defaultkey
      xsize=xsizeinit
      ysize=ysizeinit
      zsize=zsizeinit
     endif
    _obj(newobj,4)=xsize
    _obj(newobj,5)=ysize
    _obj(newobj,6)=zsize
    Fct_Refresh_Object(newobj)
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,_Dialogue$(58))
    MW_Print(12,"X="+str$(xsize) )
    MW_Print(12,"Y="+str$(ysize) )
    MW_Print(12,"Z="+str$(zsize) )
    MW_Print(12,_Dialogue$(56)+str$(defaultstep) )
    Xm=mousex() : Ym=mousey()
    Sprite 2,xm,ym,3
    MW_sync(0)
    sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  repeat
   until spacekey()=0 and mouseclick()=0
 EndFunction
Rem ****************************************************************************************************************
Function Fct_Rotate_Object(newobj)
  defaultrot=45
  pageupkey=201
  pagedownkey=209
  inserkey=210
  supprkey=211
  defaultkey=199
  xrotinit=_obj(newobj,11)
  yrotinit=_obj(newobj,12)
  zrotinit=_obj(newobj,13)
  repeat
    MW_Background_Task()
    xc#=camera position x()
    yc#=camera position y()
    zc#=camera position z()
    xrot=_obj(newobj,11)
    yrot=_obj(newobj,12)
    zrot=_obj(newobj,13)
    key=scancode()
    if key=pageupkey then yrot=yrot+defaultrot
    if key=pagedownkey then yrot=yrot-defaultrot
    if upkey()=1 then zrot=zrot+defaultrot
    if downkey()=1 then zrot=zrot-defaultrot
    if leftkey()=1 then xrot=xrot+defaultrot
    if rightkey()=1 then xrot=xrot-defaultrot
    if key=inserkey then inc defaultrot,1
    if key=supprkey then dec defaultrot,1
    if defaultrot=0 then defaultrot=1
    if defaultrot>90 then defaultrot=90
    if xrot<0 then xrot=xrot+360
    if yrot<0 then yrot=yrot+360
    if zrot<0 then zrot=zrot+360
    if xrot>360 then xrot=xrot-360
    if yrot>360 then yrot=yrot-360
    if zrot>360 then zrot=zrot-360
    if mouseclick()=1 then _3DMEMW_Check_Mouse_View()
    if key=defaultkey
      xrot=xrotinit
      yrot=yrotinit
      zrot=zrotinit
     endif
    _obj(newobj,11)=xrot
    _obj(newobj,12)=yrot
    _obj(newobj,13)=zrot
    Fct_Refresh_Object(newobj)
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,_Dialogue$(59))
    MW_Print(12,"X="+str$(xrot) )
    MW_Print(12,"Y="+str$(yrot) )
    MW_Print(12,"Z="+str$(zrot) )
    MW_Print(12,_Dialogue$(56)+str$(defaultrot) )
    Xm=mousex() : Ym=mousey()
    Sprite 2,xm,ym,3
    MW_Sync(0)
    Sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  repeat
   until spacekey()=0 and mouseclick()=0
 EndFunction
Rem ****************************************************************************************************************
Function Fct_Ghost_Object(newobj)
  attrib=_obj(newobj,9)
  inc attrib,1
  if attrib>2 then attrib=0
  if attrib=0 then ghost object off newobj
  if attrib=1 then ghost object on newobj
  if attrib=2 then ghost object on newobj,1
  _obj(newobj,9)=attrib
  Fct_WaitSynchro(3)
 EndFunction
Rem ****************************************************************************************************************
Function Fct_Select_Object(newobj,lastobject)
  pageupkey=201
  pagedownkey=209
  inserkey=210
  supprkey=211
  defaultkey=199
  _FirstTextureImage=70
  repeat
    MW_BackGround_Task()
    key=scancode()
    if key=inserkey
      Fct_Refresh_Object(newobj)
      inc newobj,1
     endif
    if key=supprkey
      Fct_Refresh_Object(newobj)
      dec newobj,1
     endif
    if newobj>lastobject then newobj=lastobject
    if newobj<2 then newobj=2
    if key=inserkey or key=supprkey
      textre=_obj(newobj,10)
      if textre>0
        texture object newobj,textre+_FirstTextureImage
       else
        color object newobj,rgb(128,128,128)
       endif
     endif
    if upkey()=1 then move camera 10
    if downkey()=1 then move camera -10
        xc#=camera position x()
        zc#=camera position z()
        x=xc#/64 : z=zc#/64
        position object 1,-1.75+(x*64),-1,-1.75+(z*64)
    if mouseclick()=1 then _3DMEMW_Check_Mouse_View()
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(12,0,0)
    MW_Print(12,_Dialogue$(60))
    MW_Print(12,"  "+str$(newobj-1))
    Xm=mousex() : Ym=mousey()
    Sprite 2,xm,ym,3
    MW_Sync(0)
    Sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  repeat
   until spacekey()=0 and mouseclick()=0
  Fct_Refresh_Object(newobj)
 EndFunction newobj
Rem ****************************************************************************************************************
Function Fct_Optimize_Objects(lastobject)
  MW_Cls(14,32,32,32)
  MW_Print(14,_Dialogue$(65))
  MW_Sync(0) : sync
  Rem Objet dont on doit optimiser la position dans la liste.
  for objecttooptimize=4 to lastobject step 1
    distance=10000000 : objetproche=0
    Rem Boucle des objets à vérifier par rapport à l'objet premier.
    Rem on cherche à trouver à quel objet l'objet OBJECTOPTIMIZE est le plus près.
    for secondobject=2 to (objecttooptimize-1) step 1
      Rem Saisie de la distance entre les 2 objets
      xo=_Obj(objecttooptimize,1) : yo=_Obj(objecttooptimize,2) : zo=_Obj(objecttooptimize,3)
      xn=_Obj(secondobject,1) : yn=_Obj(secondobject,2) : zn=_Obj(secondobject,3)
      xdist=abs(xn-xo) : ydist=abs(yn-yo) : zdist=abs(zn-zo)
      newdistance=sqrt((xdist*xdist)+(ydist*ydist)+(zdist*zdist))
      if newdistance<distance
        distance=newdistance
        objetproche=secondobject
       endif
     next secondobject
    Rem si on a trouvé un objet à une distance < 1.000.000.000
    if objetproche>0
      Rem on sauvegarde l'objet à optimiser.
      for boucle=1 to 25
        _ObjTemp(boucle)=_Obj(objecttooptimize,boucle)
       next boucle
      Rem on décale tout les autres obets de 1.
      for boucle=(objecttooptimize-1) to (objetproche+1) step -1
        for sousboucle=1 to 25
          _Obj(boucle+1,sousboucle)=_Obj(boucle,sousboucle)
         next sousboucle
       next boucle
      Rem on insère l'objet à optimizer.
      for boucle=1 to 25
        _Obj(objetproche+1,boucle)=_ObjTemp(boucle)
       next boucle
     endif
   next objecttooptimize
  Rem fin de l'optimisation.
  Rem on rafraichit tout les objets.
  for boucle=2 to lastobject
    Fct_Refresh_Object(boucle)
   next boucle
  MW_Cls(14,32,32,32)
  MW_Sync(0)
 EndFunction
Rem ****************************************************************************************************************
Function Fct_Object_Properties(newobj)
  if object exist(newobj)=1 and newobj>1
    if MW_Window_Exist(15)=0
      MW_Open_New_Window(15,"Objets propriétés",196,242,1,1,0)
      MW_Position_Window(15,128,16)
      MW_Paste_Image(15,7,0,0)
      _modif=1
     else
      _modif=0
     Endif
    Rem Addition from version 2.23
    _ghostMode=_Obj(newobj,9)
    _WireFrame=_Obj(newobj,19)
    _Transparency=_Obj(newobj,20)
    _Cull=_Obj(newobj,21)
    _TextureFiltering=_Obj(newobj,22)
    _LightSensitive=_Obj(newobj,23)
    _FogSensitive=_Obj(newobj,24)
    _AmbientSensitive=_Obj(newobj,25)
    _HiddenObject=_Obj(newobj,26)
    _ObjectCollisions=_Obj(newobj,27)
    _refresh_cases(_ghostmode,_wireframe,_transparency,_cull,_texturefiltering,_lightsensitive,_fogsensitive,_ambientsensitive,_hiddenobject,_ObjectCollisions)
    _wnd=MW_Current_Window()
    if _wnd=15
      xm=MW_Window_Position_X() : ym=MW_Window_Position_Y()
      REM SELECTIONNER L'ICONE QUITTER
      if mouseclick()=1 and ym>0
        if xm>3 and xm<20
          if ym>63 and ym<80
            _modif=1 : inc _GhostMode,1 : if _GhostMode=2 then _GhostMode=0
           endif
          if ym>79 and ym<96
            _modif=1 : inc _Wireframe,1 : if _WireFrame=2 then _WireFrame=0
           endif
          if ym>95 and ym<112
            _modif=1 : inc _Transparency,1 : if _Transparency=2 then _Transparency=0
           endif
          if ym>111 and ym<128
            _modif=1 : inc _Cull,1 : if _Cull=2 then _Cull=0
           endif
          if ym>127 and ym<144
            _modif=1 : inc _TextureFiltering,1 : if _TextureFiltering=2 then _TextureFiltering=0
           endif
          if ym>143 and ym<160
            _modif=1 : inc _LightSensitive,1 : if _LightSensitive=2 then _LightSensitive=0
           endif
          if ym>159 and ym<176
            _modif=1 : inc _FogSensitive,1 : if _FogSensitive=2 then _FogSensitive=0
           endif
          if ym>175 and ym<192
            _modif=1 : inc _AmbientSensitive,1 : if _AmbientSensitive=2 then _AmbientSensitive=0
           endif
          if ym>191 and ym<207
            _modif=1 : inc _HiddenObject,1 : if _HiddenObject=2 then _HiddenObject=0
           endif
          if ym>207 and ym<225
            _modif=1 : inc _ObjectCollisions,1 : if _ObjectCollisions=2 then _ObjectCollisions=0
           endif
         endif
       REM ANTI Multi_click
        repeat
         until mouseclick()=0
       endif
     endif
    if _modif=1
      _Obj(newobj,9)=_ghostMode
      _Obj(newobj,19)=_WireFrame
      _Obj(newobj,20)=_Transparency
      _Obj(newobj,21)=_Cull
      _Obj(newobj,22)=_TextureFiltering
      _Obj(newobj,23)=_LightSensitive
      _Obj(newobj,24)=_FogSensitive
      _Obj(newobj,25)=_AmbientSensitive
      _Obj(newobj,26)=_HiddenObject
      _Obj(newobj,27)=_ObjectCollisions
      Fct_Refresh_Object(newobj)
     endif
   else
    if MW_Window_Exist(15)=1 then MW_Close_Window(15)
   Endif
 EndFunction
Rem ****************************************************************************************************************
Function _refresh_cases(_ghostmode,_wireframe,_transparency,_cull,_texturefiltering,_lightsensitive,_fogsensitive,_ambientsensitive,_hiddenobject,_ObjectCollisions)
  if _ghostmode=1 then MW_Paste_Image(15,9,4,64) else MW_Paste_Image(15,8,4,64)
  if _wireframe=1 then MW_Paste_Image(15,8,4,80) else MW_Paste_Image(15,9,4,80)
  if _Transparency=1 then MW_Paste_Image(15,8,4,96) else MW_Paste_Image(15,9,4,96)
  if _Cull=1 then MW_Paste_Image(15,8,4,112) else MW_Paste_Image(15,9,4,112)
  if _TextureFiltering=1 then MW_Paste_Image(15,9,4,128) else MW_Paste_Image(15,8,4,128)
  if _LightSensitive=1 then MW_Paste_Image(15,9,4,144) else MW_Paste_Image(15,8,4,144)
  if _FogSensitive=1 then MW_Paste_Image(15,9,4,160) else MW_Paste_Image(15,8,4,160)
  if _AmbientSensitive=1 then MW_Paste_Image(15,9,4,176) else MW_Paste_Image(15,8,4,176)
  if _HiddenObject=1 then MW_Paste_Image(15,9,4,192) else MW_Paste_Image(15,8,4,192)
  if _ObjectCollisions=1 then MW_Paste_Image(15,9,4,208) else MW_Paste_Image(15,8,4,208)
 EndFunction
Rem ****************************************************************************************************************
Function Fct_Refresh_Object(refobj)
  _EdPath$=_EditorPath$(1)
  _MapPath$=_EditorPath$(2)
  _TutorialMapPath$=_EditorPath$(3)
  _TexturePath$=_EditorPath$(4)
  _3DObjectPath$=_EditorPath$(5)
  _3DSoundPath$=_EditorPath$(6)
  _muspath$=_EditorPath$(7)
  _soundpath$=_EditorPath$(8)
  _FirstTextureImage=200
  xcp#=camera position x()
  ycp#=camera position y()
  zcp#=camera position z()
  xpos=_obj(refobj,1)
  ypos=_obj(refobj,2)
  zpos=_obj(refobj,3)
  xsize=_obj(refobj,4)
  ysize=_obj(refobj,5)
  zsize=_obj(refobj,6)
  kind=_obj(refobj,7)
  ObjRed=_Obj(refobj,8)
  attrib=_obj(refobj,9)
  textre=_obj(refobj,10)
  xrot=_obj(refobj,11)
  yrot=_obj(refobj,12)
  zrot=_obj(refobj,13)
  ObjGreen=_Obj(refobj,15)
  ObjBlue=_Obj(refobj,16)
  XScalet=_Obj(refobj,17)
  YScalet=_Obj(refobj,18)
  Rem Addition from version 2.23
  _WireFrame=_Obj(refobj,19)
  _Transparency=_Obj(refobj,20)
  _Cull=_Obj(refobj,21)
  _TextureFiltering=_Obj(refobj,22)
  _LightSensitive=_Obj(refobj,23)
  _FogSensitive=_Obj(refobj,24)
  _AmbientSensitive=_Obj(refobj,25)
  _HiddenObject=_Obj(refobj,26)
  _ObjectCollisions=_Obj(refobj,27)
  if object exist(refobj)=1
    if sound exist(refobj)=1 then stop sound refobj
    delete object refobj
   endif
  if kind=1 then make object sphere refobj,xsize
  if kind=2 then make object cube refobj,xsize
  if kind=3 then make object box refobj,xsize,ysize,zsize
  if kind=4 then make object cylinder refobj,xsize
  if kind=5 then make object cone refobj,xsize
  if kind=6 then make object plain refobj,xsize,ysize
  if kind=8
    load object _edpath$+"\editor\lamp.x",refobj
    scale object refobj,1600,1600,1600
   endif
  if kind=9
    load object _edpath$+"\editor\sound.x",refobj
    scale object refobj,1600,1600,1600
    _loaded=0
    if file exist(_3DSoundpath$+_3DSound$(_Obj(refobj,14)))=1
      load 3dsound _3DSoundpath$+_3DSound$(_Obj(refobj,14)),refobj
      _loaded=1
     else
      if file exist(_3DSound$(_Obj(refobj,14)))=1
        load 3dsound _3DSound$(_Obj(refobj,14)),refobj
        _loaded=1
       endif
     endif
    if _loaded=1
      set sound volume refobj,32
      position sound refobj,xpos,ypos,zpos
      loop sound refobj
      play sound refobj
      loop sound refobj
      _loaded=0
     endif
   endif
  if kind>10
    if file exist(_3DObjectPath$+_DirectXObject$(kind-10))=1
      load object _3DObjectPath$+_DirectXObject$(kind-10),refobj
     else
      if file exist(_DirectXObject$(kind-10))=1
        load object _DirectXObject$(kind-10),refobj
       endif
     endif
   endif
  position object refobj,xpos,ypos,zpos
  rotate object refobj,xrot,yrot,zrot
  If xsize>0 and ysize>0 and zsize>0 and (kind=1 or kind=4 or kind=5 or kind>10)
    Scale object refobj,xsize,ysize,zsize
   endif
  if kind<8 or kind=10 then color object refobj,rgb(ObjRed,ObjGreen,ObjBlue)
  Rem  if attrib=0 then ghost object off boucle
  if attrib=1 or kind=8 then ghost object on refobj
  if attrib=2 and kind<>8 then ghost object on refobj,1
  if _HiddenObject=1 then ghost object on refobj
  if textre>0
    texture object refobj,textre+_FirstTextureImage
    if XScalet>0
      XScalet_final#=XScalet
     else
      XScalet_final#=1.0+(XScalet*0.01)
     endif
    if YScalet>0
      YScalet_final#=YScalet
     else
      YScalet_final#=1.0+(YScalet*0.01)
     endif
    if XScalet=0 then XSCalet_final#=xsize/128.0
    if YScalet=0 then YSCalet_final#=ysize/128.0
    if xscalet_final#=1.0 then xscalet_final#=1.0000000001
    if yscalet_final#=1.0 then yscalet_final#=1.0000000001
    scale object texture refobj,XScalet_final#,YScalet_final#
   endif
rem  SET OBJECT TEXTURE refobj,0,1
  fade object refobj,3000
  set object collision off refobj
  set object texture refobj,0,1
  _Cull=0
  set object refobj,_Wireframe,_Transparency,_Cull,_TextureFiltering,_LightSensitive,_FogSensitive,_AmbientSensitive
  position camera xcp#,ycp#,zcp#
 EndFunction
Rem ****************************************************************************************************************
Function _DefaultObjectValues(newobj,defaultsizex,defaultsizey,defaultsizez)
  _obj(newobj,4)=defaultsizex
  _obj(newobj,5)=defaultsizey
  _obj(newobj,6)=defaultsizez
  _obj(newobj,8)=128
  _Obj(newobj,15)=128
  _Obj(newobj,16)=128
  _obj(newobj,9)=0
 EndFunction
Rem ****************************************************************************************************************
function _checkFor7Lights()
  _LightNum=_Obj(1,16)
  for boucle=1 to 7
    if light exist(boucle)=1 then delete light boucle
    _LightActive(boucle)=0
   next boucle
  If _LightNum>0
    For boucle=1 to _LightNum
      DistanceX=abs(camera position x()-_Lights(boucle,1))
      DistanceY=abs(camera position y()-_lights(boucle,2))
      DistanceZ=abs(camera position z()-_lights(boucle,3))
      Distance=Sqrt((Distancex^2)+(Distancey^2)+(distancez^2))
      lt=0
      if Distance<1500
        Rem On cherche la première lumière libre.
        Repeat
          inc lt,1
          if _LightActive(lt)=boucle then lt=8
         until _LightActive(lt)=0 or lt=8
        Rem Si il existe un emplacement lumière de libre , on la crée.
        if lt<8
          _LightActive(lt)=boucle
          make light lt
          set point light lt,_Lights(boucle,1)+_Lights(boucle,9),_Lights(boucle,2)+_Lights(boucle,10),_Lights(boucle,3)+_Lights(boucle,11)
          Color light lt,rgb(_Lights(boucle,4)*2,_Lights(boucle,5)*2,_Lights(boucle,6)*2)
          Set light range lt,_Lights(boucle,8)*2
Rem          Position light lt,_Lights(boucle,1),_Lights(boucle,2),_Lights(boucle,3)
          Show Light lt
         endif
       endif
     next boucle
   endif
 endfunction



function Fct_Save_Camera_States
  xcam=camera position x()
  ycam=camera position y()
  zcam=camera position z()
  xang=camera angle x()
  yang=camera angle y()
  zang=camera angle z()
  _obj(1,2)=xcam
  _obj(1,3)=ycam
  _obj(1,4)=zcam
  _obj(1,5)=xang
  _obj(1,6)=yang
  _obj(1,7)=zang
 endfunction

 Rem ****************************************************************************************************************
function Fct_Scan_Keyboards
  keyb=scancode()
  Rem Load/Save/Quit options
  if keyb=59 then choice=1 : Rem                F1 = Load Map
  if keyb=60 then choice=2 : Rem                F2 = Clear Map
  if keyb=61 then choice=21 : Rem                F3 = Save Map
  if keyb=62 then choice=22 : Rem                F4 = Save Camera States
  if keyb=63 then choice=3 : Rem                F5 = Load Texture
  if keyb=64 then choice=4 : Rem                F6 = Kill Texture
  if keyb=65 then choice=5 : Rem                F7 = Load DirectX
Rem if keyb=66 then choice=7 : Rem                F8 = Kill DirectX
  if keyb=67 then choice=25 : Rem                F9 = Load 3DSound
Rem if keyb=68 then choice=26 : Rem                F10= Kill 3DSound
  Rem Adding Various objects.
  if keyb=2 then choice=9 : Rem                 1 = ADD Light
  if keyb=3 then choice=10 : Rem                 2 = ADD DirectX
  if keyb=4 then choice=11 : Rem                 3 = ADD 3DSound
  if keyb=5 then choice=12 : Rem                 4 = ADD Sphere
  if keyb=6 then choice=13 : Rem                 5 = ADD Cube
  if keyb=7 then choice=14 : Rem                 6 = ADD Box
  if keyb=8 then choice=15 : Rem                 7 = ADD Cylinder
  if keyb=9 then choice=16 : Rem                 8 = ADD Cone
  if keyb=10 then choice=17 : Rem                9 = ADD Plain
  Rem Adding Textures choices.
  if keyb=inserkey then choice=20 : Rem          INSER = Apply Next Texture
  if keyb=supprkey then choice=19 : Rem          SUPPR = Apply Previous Texture
  if keyb=201 then choice=39 : Rem               PAGE UP = Scroll Texture List -1
  if keyb=209 then choice=40 : Rem               PAGE DOWN = Scroll Texture List +1
  Rem Accessing modify object
  if keyb=31 then choice=31 : Rem                S = Select object
  if keyb=16 then choice=36 : Rem                A = Object's Attributes
  if keyb=46 then choice=32 : Rem                C = Copy object
  if keyb=39 then choice=33 : Rem                M = Move object
  if keyb=32 then choice=34 : Rem                D = Scale object ( dimension )
  if keyb=19 then choice=35 : Rem                R = Rotate object
  if keyb=24 then choice=37 : Rem                O = Optimize objects
  if keyb=34 then choice=38 : Rem                G = Object's Ghost mode
  if keyb=25 then choice=24 : Rem                P = Preview mode
  if choice>0 then fastmenu=1
  keyb=0
 endfunction choice

 Rem ****************************************************************************************************************
Function _Load_Image(_Fichier$,_Img,_texture)
  _num=8
  repeat
    dec _num,1
   until bitmap exist(_num)=0 or _num=1
  if file exist(_fichier$)=1
    load bitmap _fichier$,_num
    MW_Sync(0) : Sync
    set current bitmap _num
    _image_x(_Img)=bitmap width(_num)
    _image_y(_Img)=bitmap height(_num)
    get image _Img,0,0,_image_x(_Img),_image_y(_Img),_texture
    set current bitmap 0
    delete bitmap _num
    MW_Sync(0) : Sync
   endif
 EndFunction

 Rem ****************************************************************************************************************
Function _Paste_scaled_Image(_img,X,Y,X2,Y2,target)
  _bmp=8
  repeat
    dec _bmp,1
   until bitmap exist(_bmp)=0 or _bmp=1
  create bitmap _bmp,512,512
  MW_Sync(0) : Sync
  set current bitmap _bmp
  paste image _img,0,0
  xs=_image_x(_img) : if xs<1 then xs=16
  ys=_image_y(_img) : if ys<1 then ys=16
  copy bitmap _bmp,0,0,xs,ys,target,x,y,x2,y2
  delete bitmap _bmp
  MW_Sync(0) : Sync
 EndFunction

Rem ****************************************************************************************************************
Rem ****************************************************************************************************************
Rem ****************************************************************************************************************
Rem ****************************************************************************************************************
Rem ****************************************************************************************************************
Rem ****************************************************************************************************************

Rem *****************************************
Rem *                                       *
Rem * SELECTEUR DE FICHIER VER 1.0 Function *
Rem *                                       *
Rem *****************************************
Rem
Rem NEEDED VALRIABLES LIST :
Rem dim fileselector$(9)
Rem dim fileselectordata(12)
Rem dim _fichier$(256)
Rem fileselector$(1)=get dir$()
Rem fileselector$(2)="Window title"
Rem fileselectordata(1)=150
Rem fileselectordata(2)=50
Rem fileselectordata(11)=1
Rem fileselectordata(12)=2
Rem _FilesPath$(1)=_edpath$
Rem _FilesPath$(2)=_mappath$
Rem _FilesPath$(3)=_TexturePath$
Rem _FilesPath$(4)=_3DObjectPath$
Rem _FilesPath$(5)=_3DSoundPath$
Rem
Rem _File_Selector_v1(_loaderpath$,filter1$,filter2$)
Rem -------------------------------------------------
Rem _loaderpath$=chemin ou aller chercher le fichier par défaut
Rem filter1$=filtre d'extension 1 ( ex : filter1$=".jpg" )
Rem filter2$=filtre d'extension 2 ( ex : filter2$=".bmp" )
Rem
function Fct_File_Selector_v1(_loaderpath$,filter1$,filter2$)
Rem Cette image est l'image de sélecteur de fichier.
  fileselector$(5)=filter1$
  fileselector$(6)=filter2$
  If MW_Window_Exist(16)=1 then MW_Close_Window(16)
  MW_Open_New_Window(16,fileselector$(2),380,353,1,0,0)
  MW_Sync(0) : sync
Rem  MW_Position_Window(16,0,12)
  MW_Paste_Image(16,6,0,0)
  Rem set dir path$
  cd _loaderpath$
  fileselector$(3)=fileselector$(1)
  _refreshdrawercontent()
  _displaydrawername()
  _displayfilters()
  fileselectordata(10)=0
  repeat
    MW_BackGround_Task()
    if mouseclick()=1
      _wnd=MW_Current_Window()
      if _wnd=16
        xm=MW_Window_Position_X() : ym=MW_Window_Position_Y()
       else
        xm=0 : ym=0
       endif
      REM REMONTER DANS LA LISTE D'ITEMS
      if xm>359 and xm<376
        if ym>22 and ym<39
          fileselectordata(4)=fileselectordata(4)-1
          fileselectordata(9)=1
         endif
        REM DESCENDRE DANS LA LISTE D'ITEMS
        if ym>138 and ym<155
          fileselectordata(4)=fileselectordata(4)+1
          fileselectordata(9)=1
         endif
       endif
      REM CHOIX D'UN FICHIER DANS LA LISTE.
      if xm>21 and xm<358 and ym>24 and ym<153
        _num=(ym-24)/14
        fileselectordata(8)=_num+fileselectordata(4)
        if fileselectordata(8)>fileselectordata(5) then fileselectordata(8)=0
        if fileselectordata(8)>0 then _displayselected()
       endif
      if xm>277 and xm<343
        REM OPTION "CANCEL"/"ANNULER" = fileselectordata(10)
        if ym>184 and ym<201
          fileselectordata(10)=1
          fileselector$(8)=""
          fileselector$(9)=""
         endif
         REM OPTION "OUVRIR"
        if ym>156 and ym<173
          if fileselectordata(8)>0
            fileselectordata(10)=1
            fileselector$(8)=fileselector$(3)
            if right$(fileselector$(8),1)<>"\" then fileselector$(8)=fileselector$(8)+"\"
            fileselector$(9)=_extpath$+_fichier$(fileselectordata(8))
           endif
         endif
       endif
     endif
    if fileselectordata(4)>(fileselectordata(5)-9) then fileselectordata(4)=(fileselectordata(5)-9)
    if fileselectordata(4)<1 then fileselectordata(4)=1
    if fileselectordata(9)=1
      _Display_all()
      fileselectordata(9)=0
     endif
    if fileselectordata(8)>0
      fileselector$(7)=_fichier$(fileselectordata(8))
      if fileselector$(7)="[..]"
        fileselector$(4)=".."
        _changedrawer()
        _displaydrawername()
        _displayselected()
       endif
      if left$(fileselector$(7),1)="["
        fileselector$(4)=""
        for boucle=2 to (len(fileselector$(7))-1)
          fileselector$(4)=fileselector$(4)+mid$(fileselector$(7),boucle)
         next boucle
        _changedrawer()
        _displaydrawername()
        _displayselected()
       endif
     endif
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    MW_Sync(0)
    if upkey()=1 then move camera 10
    if downkey()=1 then move camera 0-10
    xc#=camera position x()
    zc#=camera position z()
    x=xc#/64 : z=zc#/64
    position object 1,-1.75+(x*64),-1,-1.75+(z*64)
    if MW_window_Exist(16)=1 then MW_window_To_Front(16)
    sync
   until fileselectordata(10)=1 or MW_Window_Exist(16)=0
  fileselectordata(8)=0 : fileselector$(7)=""
  fileselectordata(10)=0
  cd fileselector$(1)
  if fileselector$(8)<>"" then _selected=1
  if bitmap exist(1)=1 then delete bitmap 1
  if MW_Window_Exist(16)=1 then MW_Close_Window(16)
 endfunction _selected
REM                                             FONCTION POUR AFFICHER LA LISTE DES FICHIERS.
function _Display_all
  xpost=22 : ypost=24
  MW_Ink(16,60,60,60)
  MW_box(16,22,25,357,152)
  REM AFFICHER LA LISTE DE FICHIERS.
  MW_Ink(16,255,255,255)
  fileselectordata(3)=fileselectordata(4)+8
  if fileselectordata(3)>fileselectordata(5) then fileselectordata(3)=fileselectordata(5)
  for boucle=fileselectordata(4) to fileselectordata(3)
    MW_Set_Cursor(16,xpost,ypost)
    inc ypost,14
    MW_Print(16,right$(_fichier$(boucle),40))
   next boucle
 endfunction
REM                                             FONCTION POUR AFFICHER LE NOM DU FICHIER CHOISI.
function _displayselected
  Rem AFFICHER LE FICHIER CHOISI.
  MW_Ink(16,60,60,60)
  MW_Box(16,55,159,246,170)
  MW_Ink(16,255,255,255)
  MW_Set_Cursor(16,55,157)
  if fileselectordata(8)>0
    MW_Print(16,_fichier$(fileselectordata(8)))
    ext$=right$(_fichier$(fileselectordata(8)),4)
    if file exist(_fichier$(fileselectordata(8))+".jpg")=1
      Rem Display a preview of the texture you've selected.
      load bitmap _fichier$(fileselectordata(8))+".jpg",1
      MW_Sync(0) : sync
      xbitmap=bitmap width(1) : ybitmap=bitmap height(1)
      MW_Copy_Bitmap2Window(1,0,0,xbitmap-1,ybitmap-1,16,249,259,328,338)
      MW_Ink(16,64,64,64)
      MW_Box(16,102,264,242,345)
      MW_Ink(16,255,255,255)
     endif
    if ext$=".jpg" or ext$=".bmp"
      Rem Display a preview of the texture you've selected.
      load bitmap _fichier$(fileselectordata(8)),1
      MW_Sync(0) : sync
      xbitmap=bitmap width(1) : ybitmap=bitmap height(1)
      MW_Copy_Bitmap2Window(1,0,0,xbitmap-1,ybitmap-1,16,249,259,328,338)
      MW_Ink(16,64,64,64)
      MW_Box(16,102,264,242,345)
      MW_Ink(16,255,255,255)
      MW_Set_Cursor(16,102,270) : MW_Print(16,str$(xbitmap)+" pixels")
      MW_Set_Cursor(16,102,298) : MW_Print(16,str$(ybitmap)+" pixels")
     endif
   else
    MW_Ink(16,64,64,64)
    MW_Box(16,249,259,328,338)
    MW_Ink(16,119,115,104)
    MW_Box(16,102,264,242,345)
   endif
 endfunction
REM                                             FONTION POUR AFFICHER LE CHEMIN COURANT.
function _displaydrawername
  Rem AFFICHER LE CHEMIN D'ACCES COURANT.
  MW_Ink(16,60,60,60)
  MW_Box(16,63,4,352,15)
  MW_Ink(16,255,255,255)
  MW_Set_Cursor(16,63,3)
  MW_Print(16,right$(fileselector$(3),40))
 endfunction
Rem                                             CHANGE LE DOSSIER COURANT.
function _changedrawer
  cd fileselector$(4)
  fileselector$(3)=get dir$()
  _refreshdrawercontent()
 endfunction
REM                                             REACTUALISE LE CONTENU DU DOSSIER SELON LES FILTRES.
function _refreshdrawercontent
  fileselectordata(5)=1
  perform checklist for files
  fileselectordata(7)=checklist quantity()
  for boucle=1 to fileselectordata(7)
    _name$=checklist string$(boucle)
    if checklist value a(boucle)=1
      _fichier$(fileselectordata(5))=lower$("["+_name$+"]")
      fileselectordata(5)=fileselectordata(5)+1
     endif
   next boucle
  for boucle=1 to fileselectordata(7)
    _name$=checklist string$(boucle)
    if checklist value a(boucle)=0
      if fileselector$(5)="" and fileselector$(6)=""
        _fichier$(fileselectordata(5))=lower$(_name$)
        fileselectordata(5)=fileselectordata(5)+1
       endif
     endif
    Rem SI LE FILTRE 1 EST ACTIF , ON REGARDE SI L'EXTENSION DU FICHIER CORRESPOND
    if fileselector$(5)<>""
      ext$=lower$(right$(_name$,len(fileselector$(5))))
      if ext$=fileselector$(5)
        _fichier$(fileselectordata(5))=lower$(_name$)
        fileselectordata(5)=fileselectordata(5)+1
       endif
     endif
    Rem SI LE FILTRE 1 EST ACTIF , ON REGARDE SI L'EXTENSION DU FICHIER CORRESPOND
    if fileselector$(6)<>""
      ext$=lower$(right$(_name$,len(fileselector$(6))))
      if ext$=fileselector$(6)
        _fichier$(fileselectordata(5))=lower$(_name$)
        fileselectordata(5)=fileselectordata(5)+1
       endif
     endif
   next boucle
  for boucle=fileselectordata(5) to 255 step 1
    _fichier$(boucle)=""
   next boucle
  fileselector$(7)="" : fileselectordata(8)=0
  fileselectordata(9)=1
  repeat
    MW_Sync(0) : Sync
    until mouseclick()=0
 endfunction
REM                                             AFFICHE LES FILTRES DANS LA CASE CHOISIE.
function _displayfilters
  Rem AFFICHER LE FICHIER CHOISI.
    MW_Ink(16,60,60,60)
    MW_Box(16,55,187,246,197)
    MW_Ink(16,255,255,255)
    MW_Set_Cursor(16,55,186)
  if fileselector$(5)<>"" and fileselector$(6)=""
    MW_Print(16,"*"+fileselector$(5))
   endif
  if fileselector$(5)<>"" and fileselector$(6)<>""
    MW_Print(16,"*"+fileselector$(5)+" / *"+fileselector$(6))
   endif
  if fileselector$(5)="" and fileselector$(6)<>""
    MW_Print(16,"*"+fileselector$(6))
   endif
  if fileselector$(5)="" and fileselector$(6)=""
    MW_Print(16,"*.*")
   endif
 endfunction
REMSTART
Rem fileselector$(1)=get dir$()
Rem fileselector$(2)=Window Title$
Rem fileselector$(3)=_path$
Rem fileselector$(4)=_fileselect$
Rem fileselector$(5)=filter1$
Rem fileselector$(6)=filter2$
Rem fileselector$(7)=_file$
Rem fileselector$(8)=_dossierfinal$
Rem fileselector$(9)=_fichierfinal$
Rem
Rem fileselectordata(3)=_lastitem
Rem fileselectordata(4)=_firstitem
Rem fileselectordata(5)=_numfichier
Rem fileselectordata(6)=fileselectordata(8)
Rem fileselectordata(7)=total_fiches
Rem fileselectordata(8)=fileselectordata(8)
Rem fileselectordata(9)=_itemdisplay
Rem fileselectordata(10)=quit
Rem fileselectordata(11)=loaderimagenumber
REMEND

Rem _set_fog(RED,GREEN,BLUE,DISTANCE)                     Define Fog value ( and save states )
Rem _initialize_zones                                     Initialize all zones ( including SkyBox )
Rem _initialize_skybox
Rem _position_skybox                                      Reposition skybox around player vision
Rem _check_zone_inout                                     check if player enter or leave a zone
Rem _check_zone_action(_check)                            Active zone effects .
Rem _enter_water_zone(_zone_number)
Rem _inside_water_zone
Rem _leave_water_zone
Rem _enter_music_zone(_zone_number)
Rem _enter_sound_zone(_zone_number)
Rem _inside_light_zone(_zone_number)
Rem _inside_fog_zone(_zone_number)
Rem
Rem  Fonctions for Editor Only :
Rem ----------------------------
Rem _replace_skyobject()
Rem
Rem _zone_data(1)=_last_zone
Rem _zone_data(2)=_skybox_zone
Rem _zone_data(3)=_skybox_object
Rem
function _set_fog(R,G,B,DIST)
  _3dme_temp(8)=R : _3dme_temp(9)=G : _3dme_temp(10)=B : _3dme_temp(11)=DIST
  fog on
  fog color rgb(R,G,B)
  fog distance DIST
 endfunction
Rem
function _initialize_zones
  Rem Sauvegarde des valeurs de FOG par défaut
  _3dme_temp(4)=_obj(1,9) : _3dme_temp(5)=_obj(1,10) : _3dme_temp(6)=_obj(1,11) : _3dme_temp(7)=_obj(1,12)
  _initialize_skybox()
 endfunction
Rem
function _check_all_zones
  _check=_check_zone_inout()
  if _check>0 then _check_zone_action(_check)
  _position_skybox()
 endfunction
Rem
function _quit_all_zones
  for boucle=1 to _last_zone
    if _zone_inside(boucle)=1
      _zone_inside(boucle)=0
      _zone_entrance(boucle)=0
      _zone_sortance(boucle)=1
     endif
   next boucle
  _sortance=1
  _check_zone_action(2) : Rem on force la sortie de toute les zones.
  for boucle=1 to _last_zone
    _zone_sortance(boucle)=0
   next boucle
 endfunction
Rem
function _initialize_skybox
  _skybox_zone=0
  for bcl=1 to _zone_data(1)
    if _zone_info(bcl,1)=6 then _skybox_zone=bcl
   next bcl
  Rem SI IL EXISTE UNE ZONE DE SKYBOX_ZONE ALORS ON NOTE LES 16 OBJETS ( MAX QU'ELLE CONTIENT )
  if _skybox_zone>0
    xzp=_zone_info(_skybox_zone,2) : yzp=_zone_info(_skybox_zone,3) : zzp=_zone_info(_skybox_zone,4)
    xzs=_zone_info(_skybox_zone,5) : yzs=_zone_info(_skybox_zone,6) : zzs=_zone_info(_skybox_zone,7)
    _sky_object=0
    for boucle=2 to _obj(1,1)
      xop=_obj(boucle,1) : yop=_obj(boucle,2) : zop=_obj(boucle,3)
      if xop>(xzp-(xzs/2)) and xop<(xzp+(xzs/2))
        if yop>(yzp-(yzs/2)) and yop<(yzp+(yzs/2))
          if zop>(zzp-(zzs/2)) and zop<(zzp+(zzs/2))
            if _sky_object<16
              inc _sky_object
              _skybox_object(_sky_object)=boucle
              REM SET OBJECT Object Number, Wireframe, Transparency, Cull, Filter, Light, Fog, Ambient
rem              set object boucle,1,1,0,0,0,1,0
             endif
           endif
         endif
       endif
     next boucle
    _zone_data(2)=_skybox_zone
    _zone_data(3)=_sky_object
   endif
 endfunction
Rem
function _position_skybox
  if _zone_data(2)>0
    set cursor 0,0
    ink rgb(255,255,255),rgb(0,0,0)
    xzp=_zone_info(_zone_data(2),2) : yzp=_zone_info(_zone_data(2),3) : zzp=_zone_info(_zone_data(2),4)
    if _zone_data(3)>0
      for boucle=1 to _zone_data(3)
        _sky_obj=_skybox_object(boucle)
        xop=_obj(_sky_obj,1) : yop=_obj(_sky_obj,2) : zop=_obj(_sky_obj,3)
        xop=xop-xzp : yop=yop-yzp : zop=zop-zzp
        xop=xop+camera position x()
        yop=yop+camera position y()
        zop=zop+camera position z()
        position object _sky_obj,xop,yop,zop
      next boucle
     endif
   endif
 endfunction
Rem
function _check_zone_inout
  _entrance=0 : _sortance=0
  if _zone_data(1)>0
    xc=camera position x() : yc=camera position y() : zc=camera position z()
    for bcl=1 to _zone_data(1)
      xzp=_zone_info(bcl,2) : yzp=_zone_info(bcl,3) : zzp=_zone_info(bcl,4)
      xzs=_zone_info(bcl,5) : yzs=_zone_info(bcl,6) : zzs=_zone_info(bcl,7)
      Rem Si on est dans une zone , calcule si on viens juste d'en sortir.
      _zone_sortance(bcl)=0
      if _zone_inside(bcl)=1
        if xc<(xzp-(xzs/2)) or xc>(xzp+(xzs/2))
          _zone_sortance(bcl)=1 : _zone_inside(bcl)=0 : _zone_entrance(bcl)=0 : _sortance=1
         endif
        if yc<(yzp-(yzs/2)) or yc>(yzp+(yzs/2))
          _zone_sortance(bcl)=1 : _zone_inside(bcl)=0 : _zone_entrance(bcl)=0 : _sortance=1
         endif
        if zc<(zzp-(zzs/2)) or zc>(zzp+(zzs/2))
          _zone_sortance(bcl)=1 : _zone_inside(bcl)=0 : _zone_entrance(bcl)=0 : _sortance=1
         endif
       endif
      Rem Si on viens juste de rentrer dans une zone , on reste dedans mais on désactive le flag d'entrée.
      if _zone_entrance(bcl)=1
        _zone_entrance(bcl)=0
        _zone_inside(bcl)=1
       endif
      Rem Calcule si l'on rentre dans une zone d'action.
      if _zone_inside(bcl)=0
        if xc>(xzp-(xzs/2)) and xc<(xzp+(xzs/2))
          if yc>(yzp-(yzs/2)) and yc<(yzp+(yzs/2))
            if zc>(zzp-(zzs/2)) and zc<(zzp+(zzs/2))
              _zone_entrance(bcl)=1 : _entrance=1
             endif
           endif
         endif
       endif
      if _zone_inside(bcl)=1 then _inside=1
     next boucle
   endif
   _retour=_entrance+(_sortance*2)+(_inside*4)
 endfunction _retour
Rem
Rem Activate action for dedicaced zones.
Rem
function _check_zone_action(_check)
  _entrance=0 : _sortance=0
  if _zone_data(1)>0
    if _check>3
      _inside=1 : _check=_check-4
     endif
    if _check>1
      _sortance=1 : _check=_check-2
     endif
    _entrance=_check
    Rem ON VERIFIE ET EXECUTE LES FONCTIONS D'ENTREE DE ZONES NECESSAIRES.
    for boucle=1 to _zone_data(1)
      if _zone_entrance(boucle)=1
        _zone_number=boucle
        if _zone_info(boucle,1)=2 then _enter_water_zone(_zone_number)
        if _zone_info(boucle,1)=3 then _enter_music_zone(_zone_number)
        if _zone_info(boucle,1)=4 then _enter_sound_zone(_zone_number)
       endif
      if _zone_inside(boucle)=1
        _zone_number=boucle
        if _zone_info(boucle,1)=1 then _inside_fog_zone(_zone_number)
        if _zone_info(boucle,1)=2 then _inside_water_zone()
        if _zone_info(boucle,1)=5 then _inside_light_zone(_zone_number)
       endif
      if _zone_sortance(boucle)=1
        _zone_number=boucle
        if _zone_info(boucle,1)=2 then _leave_water_zone()
       endif
     next boucle
   endif
 endfunction
Rem
Rem Set of 3 functions that control water effects ( entering zone , leaving zone , inside zone )
Rem
function _enter_water_zone(_zone_number)
  wat=65535-256
  if object exist(wat)=1 then delete object wat
  xpos=camera position x() : ypos=camera position y() : zpos=camera position z()
  make object sphere wat,64
  position object wat,xpos,ypos,zpos
  color object wat,rgb(_zone_info(_zone_number,8),_zone_info(_zone_number,9),_zone_info(_zone_number,10))
  ghost object on wat
  fade object wat,3000
  disable object zdepth wat
  set object collision off wat
  Rem Texturage de l'objet d'eau
  if _zone_info(_zone_number,17)>0
    imgnum=_zone_info(_zone_number,17)+_3dme_temp(12)
    if image exist(imgnum)=1 then texture object wat,imgnum
   endif
  REM SET OBJECT Object Number, Wireframe, Transparency, Cull, Filter, Light, Fog, Ambient
  set object wat,1,1,0
 endfunction
function _inside_water_zone
  wat=65535-256
  xdec=_3dme_temp(1) : ydec=_3dme_temp(2) : zdec=_3dme_temp(3)
  xdec=wrapvalue(xdec+1) : ydec=wrapvalue(ydec+1) : zdec=wrapvalue(zdec+2)
  xpos=camera position x() : ypos=camera position y() : zpos=camera position z()
  position object wat,xpos,ypos,zpos
  _3dme_temp(1)=xdec : _3dme_temp(2)=ydec : _3dme_temp(3)=zdec
  xdec=wrapvalue(camera angle x()+xdec)
  ydec=wrapvalue(camera angle y()+ydec)
  zdec=wrapvalue(camera angle z()+zdec)
  rotate object wat,xdec,ydec,zdec
 endfunction
function _leave_water_zone
  wat=65535-256
  if object exist(wat)=1 then delete object wat
 endfunction
Rem
Rem Set of function for Music Zome
Rem
function _enter_music_zone(_zone_number)
  Rem On désactive la musique qui est actuellement jouée.
  if music exist(1)=1
    stop music 1
    delete music 1
   endif
  if file exist(_FilesPath$(6)+_zone_filename$(_zone_number))=1
    load music _FilesPath$(6)+_zone_filename$(_zone_number),1
    play music 1
   endif
 endfunction
Rem
Rem Set of function for Sound Zome
Rem
function _enter_sound_zone(_zone_number)
  if sound exist(1)=1
    stop sound 1
    delete sound 1
   endif
  if file exist(_FilesPath$(7)+_zone_filename$(_zone_number))=1
    load sound _FilesPath$(7)+_zone_filename$(_zone_number),1
    play sound 1
   endif
 endfunction
Rem
Rem Set of function for Light Zone
Rem
function _inside_light_zone(_zone_number)
  redz=_zone_info(_zone_number,8) : greenz=_zone_info(_zone_number,9) : bluez=_zone_info(_zone_number,10)
  ligz=_zone_info(_zone_number,11)
  red=_3dme_temp(4) : green=_3dme_temp(5) : blue=_3dme_temp(6) : lig=_3dme_temp(7)
  if red=redz and green=greenz and blue=bluez and lig=ligz then changes=0 else changes=1
  if red>redz then dec red,1
  if red<redz then inc red,1
  if green>greenz then dec green,1
  if green<greenz then inc green,1
  if blue>bluez then dec blue,1
  if blue<bluez then inc blue,1
  if lig>ligz then dec lig,1
  if lig<ligz then inc lig,1
  if changes=1
    color ambient light rgb(red,green,blue)
    set ambient light lig
   endif
  _3dme_temp(4)=red : _3dme_temp(5)=green : _3dme_temp(6)=blue : _3dme_temp(7)=lig
 endfunction
Rem
Rem Sets of functions for Fog Zone
rem
function _inside_fog_zone(_zone_number)
  redz=_zone_info(_zone_number,8) : greenz=_zone_info(_zone_number,9) : bluez=_zone_info(_zone_number,10)
  disz=_zone_info(_zone_number,11)
  red=_3dme_temp(8) : green=_3dme_temp(9) : blue=_3dme_temp(10) : dis=_3dme_temp(11)
  if red=redz and green=greenz and blue=bluez and dis=disz then changes=0 else changes=1
  if red>redz then dec red,1
  if red<redz then inc red,1
  if green>greenz then dec green,1
  if green<greenz then inc green,1
  if blue>bluez then dec blue,1
  if blue<bluez then inc blue,1
  if dis>disz then dec dis,1
  if dis<disz then inc dis,1
  if changes=1
    fog color rgb(red,green,blue)
    fog distance dis
   endif
  _3dme_temp(8)=red : _3dme_temp(9)=green : _3dme_temp(10)=blue : _3dme_temp(11)=dis
 endfunction
Rem
Rem
Rem
Rem *************************************************************************************************************
Rem *                                                                                                           *
Rem *                     INTERACTION AVEC LES ZONES CREES DANS L'EDITEUR                                       *
Rem *                                                                                                           *
Rem *************************************************************************************************************
Function _replace_skyobject
  _skybox_zone=_zone_data(2)
  _skybox_object=_zone_data(3)
  if _skybox_zone>0
    xzp=_zone_info(_skybox_zone,2) : yzp=_zone_info(_skybox_zone,3) : zzp=_zone_info(_skybox_zone,4)
    if _skybox_object>0
      for boucle=1 to _skybox_object
        _sky_object=_skybox_object(boucle)
        xop=_obj(_sky_object,1) : yop=_obj(_sky_object,2) : zop=_obj(_sky_object,3)
        position object _sky_object,xop,yop,zop
       next boucle
     endif
   endif
 EndFunction


REMSTART
_Prepare_Menu(LANGAGE$)
_MENU_SELECTED=_Display_Menu(_OPTION_SELECTED)
_OPTION_SELECTED=_select_submenu(_MENU_SELECTED)
_aftersync_menu
_disable_option(_menu,_option)
_enable_option(_menu,_option)
RemEND

Rem
Rem Fonction qui permet de créer les menus à partir de fichiers sur disque . . .
Rem
function _prepare_menu(file$)
  _loaded=file exist(file$)
  if _loaded=1
    open to read 1,file$
    read string 1,_how_many$ : _menu_options(0)=val(_how_many$) : Rem Combien de menus différents existe t-il ?
    read string 1,_st$ : Rem Text Transitoire
    for boucle=1 to _menu_options(0)
      read string 1,_menu_name$(boucle,0) : Rem On lit le nom du menu
      read string 1,_opt$ : _menu_options(boucle)=val(_opt$) : Rem On lit combien il y a d'options dans le menu
      if _menu_options(boucle)>_menu_sys(3) then _menu_sys(3)=_menu_options(boucle)
      for sousboucle=1 to _menu_options(boucle)
        read string 1,_menu_name$(boucle,sousboucle) : Rem On lit les options du menu
        _option_state(boucle,sousboucle)=1
       next sousboucle
      read string 1,_st$ : Rem Text transitoire
     next boucle
    close file 1
    load image _FilesPath$(1)+"\editor\menu_item.jpg",_menu_sys(1)
   endif
 endfunction _loaded
Rem
Rem Fonction qui affiche le menu principal si nécessaire.
Rem
function _display_menu(option_selected)
  if option_selected=0
    if _menu_sys(4)=1 then get image _menu_sys(2),0,0,_menu_options(0)*128,(_menu_sys(3)+1)*16
    menu_selected=0
   endif
  Rem on rentre dans la boucle
  xm=mousex() : ym=mousey()
  if ym<16 and xm<(128*_menu_options(0))
    menu_selected=(xm/128)+1
    for boucle=1 to _menu_options(0)
      if boucle=menu_selected then ink rgb(255,255,255),0 else ink rgb(32,32,32),0
      paste image _menu_sys(1),(boucle-1)*128,0
      set cursor ((boucle-1)*128)+4,1 : print _menu_name$(boucle,0)
     next boucle
    for boucle=1 to _menu_options(menu_selected)
     paste image _menu_sys(1),(menu_selected-1)*128,(boucle*16)
      set cursor ((menu_selected-1)*128)+4,(boucle*16)+1
      if _option_state(menu_selected,boucle)=1 then ink rgb(32,32,32),0 else ink rgb(128,128,128),0
      print _menu_name$(menu_selected,boucle)
     next boucle
   endif
 endfunction menu_selected
Rem
Rem Fonction qui affiche les sous-menu si nécessaire
Rem
function _select_submenu(menu_selected)
  option_selected=0
  if menu_selected=0 and _menu_sys(4)=1 then get image _menu_sys(2),0,0,_menu_options(0)*128,(_menu_sys(3)+1)*16
  xm=mousex() : ym=mousey()
  if ym<(16*(_menu_options(menu_selected)+1)) and ym>15
    if xm>=(menu_selected-1)*128 and xm<menu_selected*128
      option_selected=(ym/16)
      for boucle=1 to _menu_options(0)
        if boucle=menu_selected then ink rgb(255,255,255),0 else ink rgb(32,32,32),0
        paste image _menu_sys(1),(boucle-1)*128,0
        set cursor ((boucle-1)*128)+4,1 : print _menu_name$(boucle,0)
       next boucle
      for boucle=1 to _menu_options(menu_selected)
        if _option_state(menu_selected,boucle)=0
          ink rgb(128,128,128),0
         else
          if boucle=option_selected then ink rgb(255,255,255),0 else ink rgb(32,32,32),0
         endif
        paste image _menu_sys(1),(menu_selected-1)*128,(boucle*16)
        set cursor ((menu_selected-1)*128)+4,(boucle*16)+1 : print _menu_name$(menu_selected,boucle)
      next boucle
    endif
  endif
 endfunction option_selected
Rem
Rem Synchro pour le menu .
Rem
function _aftersync_menu
  if image exist(_menu_sys(2) )=1 and _menu_sys(4)=1 then paste image _menu_sys(2),0,0
 endfunction
Rem
Rem On désactive une option si elle est active . . .
Rem
function _disable_option(_menu,_option)
  if _menu_options(0)>=_menu and _menu>0
    if _menu_options(_menu)>=_option and _option>0
      _option_state(_menu,_option)=0
     endif
   endif
 endfunction
Rem
Rem On active une option si elle est inactive . . .
Rem
function _enable_option(_menu,_option)
  if _menu_options(0)>=_menu and _menu>0
    if _menu_options(_menu)>=_option and _option>0
      _option_state(_menu,_option)=1
     endif
   endif
 endfunction
Rem
Rem On efface les buffers si ils sont utilisés.
Rem
function _clear_menu
  if image exist(_menu_sys(1) )=1 then delete image _menu_sys(1)
  if image exist(_menu_sys(2) )=1 then delete image _menu_sys(2)
 endfunction

Rem 3DMapEditor 2.30+ Matrixes functions sets :
Rem -------------------------------------------
Rem
Rem _3DME_Add_New8Matrix(_NewMatrix,XTiles,ZTiles,XSize,ZSize)
Rem _3DME_Move_Matrix(_Matrix)
Rem _3DME_Move_Matrix_Point(_CurrentMatrix)
Rem
Rem _3DME_Refresh_Matrix(_matrix) : Re-actualise complètement une matrice
Rem
Rem
Rem
Function _3DME_Add_New_Matrix(_matrix,posx,posy,posz,XTILES,ZTILES,XSIZE,ZSIZE)
  if _matrix>0 and _matrix<257
    _generated=1
    Rem Re-initialize matrix system data.
    _Matrix(_MATRIX,1)=posx
    _Matrix(_MATRIX,2)=posy
    _Matrix(_MATRIX,3)=posz
    _Matrix(_MATRIX,4)=Xtiles
    _Matrix(_MATRIX,5)=Ztiles
    _Matrix(_MATRIX,6)=Xsize
    _Matrix(_MATRIX,7)=Zsize
    _Matrix(_MATRIX,10)=1 : Rem Black=Translucent false
    _Matrix(_MATRIX,12)=1 : Rem Texture Filtering True
    _Matrix(_MATRIX,11)=1 : Rem Face cachées True
    _Matrix(_MATRIX,13)=1 : Rem Light True
    _Matrix(_MATRIX,14)=1 : Rem Fog True
    _Matrix(_MATRIX,15)=1 : Rem ambient True
    _Matrix(_MATRIX,16)=1 : Rem Collisions True
    Rem Re-initialise all matrix values to 0
    for xm=0 to xtiles
      for zm=0 to ztiles
        _Matrix_Height(_MATRIX,xm,zm)=0
        _Matrix_Tile(_MATRIX,xm,zm)=1
       next zm
     next xm
   else
    _generated=0
   endif
  _3DME_Refresh_Matrix(_matrix,0,0)
 EndFunction _generated
Rem
Rem
Rem
Function _3DME_Delete_Matrix(_matrix)
  if matrix exist(_matrix)=1 then delete matrix _matrix
  For Boucle=1 to 16
    _Matrix(_matrix,boucle)=0
   next boucle
  Rem Re-initialise all matrix values to 0
  for xm=0 to _matrix(_matrix,4)
    for zm=0 to _matrix(_matrix,5)
      _Matrix_Height(_MATRIX,xm,zm)=0
      _Matrix_Tile(_MATRIX,xm,zm)=0
     next zm
   next xm
 EndFunction
Rem
Rem
Rem
Function _3DME_Move_Matrix(_Matrix)
  defaultstep=32
  pageupkey=201
  pagedownkey=209
  inserkey=210
  supprkey=211
  defaultkey=199
  xposinit=_matrix(_matrix,1)
  yposinit=_matrix(_matrix,2)
  zposinit=_matrix(_matrix,3)
  repeat
    MW_Background_Task()
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    xpos=_matrix(_matrix,1)
    ypos=_matrix(_matrix,2)
    zpos=_matrix(_matrix,3)
    key=scancode()
    if key=pageupkey then ypos=ypos+defaultstep
    if key=pagedownkey then ypos=ypos-defaultstep
    if upkey()=1 then zpos=zpos+defaultstep
    if downkey()=1 then zpos=zpos-defaultstep
    if leftkey()=1 then xpos=xpos-defaultstep
    if rightkey()=1 then xpos=xpos+defaultstep
    if key=inserkey then inc defaultstep,1
    if key=supprkey then dec defaultstep,1
    if defaultstep=0 then defaultstep=1
    if defaultstep>128 then defaultstep=128
    if key=defaultkey
      xpos=xposinit
      ypos=yposinit
      zpos=zposinit
     endif
    if mouseclick()=1 then _3DMEMW_Check_Mouse_View()
    _matrix(_matrix,1)=xpos
    _matrix(_matrix,2)=ypos
    _matrix(_matrix,3)=zpos
    position matrix _matrix,xpos,ypos,zpos
    MW_Ink(14,128,128,128)
    MW_Set_Cursor(14,0,0)
    MW_Print(14,"Matrix pos :")
    MW_Print(14,"X="+str$(xpos))
    MW_Print(14,"Y="+str$(ypos))
    MW_Print(14,"Z="+str$(zpos))
    MW_Print(14,_Dialogue$(56)+str$(defaultstep))
Rem    fade object newobj,_FADEOBJECT
    MW_Sync(0)
    Sync
    MW_Cls(14,32,32,32)
   until spacekey()=1 or mouseclick()=2
  repeat
   until spacekey()=0 and mouseclick()=0
 EndFunction
Rem
Rem
Rem
Function _3DME_Move_Matrix_Point(_Matrix)
  autocam off
  defaultstep=16
  pageupkey=201
  pagedownkey=209
  inserkey=210
  supprkey=211
  defaultkey=199
  xpnt=0 : zpnt=0 : _matrixpointer=65535-256
  load object "editor\matrix_pointer.x",_matrixpointer
  xsize=_Matrix(_MATRIX,6) : ysize=_Matrix(_MATRIX,7)
  if xsize<ysize then defsize=xsize else defsize=ysize
  percent#=(defsize/64.0)*100
  scale object _matrixpointer,percent#,percent#,percent#
  set object _matrixpointer,1,0,0,1,1,1,1
  xposm=_matrix(_matrix,1) : yposm=_matrix(_matrix,2) : zposm=_matrix(_matrix,3)
  Xtiles=_Matrix(_MATRIX,4)
  Ztiles=_Matrix(_MATRIX,5)
  Xsize=_Matrix(_MATRIX,6)
  Zsize=_Matrix(_MATRIX,7)
  repeat
    MW_Background_Task()
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    key=scancode()
    xposobj=(xpnt) : zposobj=(zpnt)
    yposobj=get matrix height(_MATRIX,xposobj,zposobj)
    position object _matrixpointer,(xposobj*xsize)+xposm,yposobj+yposm,(zposobj*zsize)+zposm
    xpnt=xpnt+(rightkey() - leftkey() )
    zpnt=zpnt+(upkey() - downkey() )
    if xpnt<0 then xpnt=0
    if xpnt>xtiles then xpnt=xtiles
    if zpnt<0 then zpnt=0
    if zpnt>ztiles then zpnt=ztiles
    if key=inserkey then inc defaultstep,1
    if key=supprkey then dec defaultstep,1
    if defaultstep=0 then defaultstep=1
    if defaultstep>128 then defaultstep=128
    if key=pageupkey or key=pagedownkey
      if key=pageupkey then _Matrix_Height(_MATRIX,Xpnt,Zpnt)=_Matrix_Height(_MATRIX,Xpnt,Zpnt)+defaultstep
      if key=pagedownkey then _Matrix_Height(_MATRIX,Xpnt,Zpnt)=_Matrix_Height(_MATRIX,Xpnt,Zpnt)-defaultstep
      set matrix height _matrix,xpnt,zpnt,_Matrix_Height(_MATRIX,Xpnt,Zpnt)
      update matrix _matrix
     Endif
      if key=17
        for boucle=0 to xtiles
          _Matrix_Height(_MATRIX,boucle,Zpnt)=_Matrix_Height(_MATRIX,Xpnt,Zpnt)
          set matrix height _matrix,boucle,zpnt,_Matrix_Height(_MATRIX,boucle,Zpnt)
         next boucle
       Endif
      if key=45
        for boucle=0 to ztiles
          _Matrix_Height(_MATRIX,Xpnt,boucle)=_Matrix_Height(_MATRIX,Xpnt,Zpnt)
          set matrix height _matrix,xpnt,boucle,_Matrix_Height(_MATRIX,xpnt,boucle)
         next boucle
       Endif
    if mouseclick()=1 then _3DMEMW_Check_Mouse_View()
    if key=17 or key=45 then update matrix _matrix
    MW_Ink(14,128,128,128)
    MW_Set_Cursor(14,0,0)
    MW_Print(14,"Matrix tile :")
    MW_Print(14,"X="+str$(xpnt))
    MW_Print(14,"Y="+str$(ypnt))
    MW_Print(14,"Z="+str$(zpnt))
    MW_Print(14,"Y="+str$(_Matrix_height(_MATRIX,Xpnt,Zpnt)))
    MW_Print(14,_Dialogue$(56)+str$(defaultstep))
    MW_Sync(0)
    Sync
    MW_Cls(14,32,32,32)
   until spacekey()=1 or mouseclick()=2
   delete object _matrixpointer
  repeat
    until spacekey()=0 and mouseclick()=0
 EndFunction
Rem
Rem
Rem
Function _3DME_Texture_Matrix_Tiles(_Matrix,_FirstTextureImage,_texturenum)
  autocam off
  defaultstep=1
  pageupkey=201
  pagedownkey=209
  inserkey=210
  supprkey=211
  defaultkey=199
  if _texturenum>0
    xpnt=0 : zpnt=0 : _matrixpointer=65535-256
    load object "editor\matrix_tiles.x",_matrixpointer
    xsize=_Matrix(_MATRIX,6) : ysize=_Matrix(_MATRIX,7)
    if xsize<ysize then defsize=xsize else defsize=ysize
    percent#=(defsize/128.0)*100
    scale object _matrixpointer,percent#,percent#,percent#
    set object _matrixpointer,1,0,0,1,1,1,1
    xposm=_matrix(_matrix,1) : yposm=_matrix(_matrix,2) : zposm=_matrix(_matrix,3)
    Xtiles=_Matrix(_MATRIX,4)
    Ztiles=_Matrix(_MATRIX,5)
    Xsize=_Matrix(_MATRIX,6)
    Zsize=_Matrix(_MATRIX,7)
    repeat
      ycurs=mousey() : xcurs=mousex()
      sprite 2,xcurs,ycurs,3
      MW_Background_Task()
      key=scancode()
      xposobj=xpnt : zposobj=zpnt
      yposobj=get matrix height(_MATRIX,xposobj,zposobj)
      position object _matrixpointer,(xposobj*xsize)+(xsize/2)+xposm,yposobj+yposm,(zposobj*zsize)+(zsize/2)+zposm
      xpnt=xpnt+(rightkey() - leftkey() )
      zpnt=zpnt+(upkey() - downkey() )
      if xpnt<0 then xpnt=0
      if xpnt>xtiles-1 then xpnt=xtiles-1
      if zpnt<0 then zpnt=0
      if zpnt>ztiles-1 then zpnt=ztiles-1
      _tile=_Matrix_Tile(_MATRIX,Xpnt,Zpnt)
      if key=pageupkey then inc _tile,1
      if key=pagedownkey then dec _tile,1
      if _tile>_texturenum then _tile=_texturenum
      if _tile<1 then _tile=1
      _Matrix_Tile(_MATRIX,Xpnt,Zpnt)=_tile
      if key=17
        for boucle=0 to xtiles-1
          _Matrix_Tile(_MATRIX,boucle,zpnt)=_tile
         next boucle
       Endif
      if key=45
        for boucle=0 to ztiles-1
          _Matrix_Tile(_MATRIX,xpnt,boucle)=_tile
         next boucle
       Endif
      if key=16
        for zbcl=0 to ztiles-1
          for xbcl=0 to xtiles-1
            _Matrix_Tile(_MATRIX,xbcl,zbcl)=_tile
           next xbcl
         next zbcl
       endif
      if key=pageupkey or key=pagedownkey then _3DME_Refresh_Matrix(_matrix,_FirstTextureImage,_texturenum)
      if key=17 or key=45 or key=16 then _3DME_Refresh_Matrix(_matrix,_FirstTextureImage,_texturenum)
      if mouseclick()=1 then _3DMEMW_Check_Mouse_View()
      MW_Ink(14,128,128,128)
      MW_Set_Cursor(14,0,0)
      MW_Print(14,"Mtx point :")
      MW_Print(14,"X="+str$(xpnt))
      MW_Print(14,"Z="+str$(zpnt))
      MW_Print(14,"Y="+str$(_Matrix_Tile(_MATRIX,Xpnt,Zpnt)))
      MW_Print(14,_Dialogue$(56)+str$(defaultstep))
      MW_Sync(0)
      Sync
      MW_Cls(14,32,32,32)
     until spacekey()=1 or mouseclick()=2
     delete object _matrixpointer
    repeat
     until spacekey()=0 and mouseclick()=0
   EndIf
 EndFunction
Rem ****************************************************************************************************************
Function _3DME_Refresh_Matrix(_matrix,_FirstTextureImage,_texturenum)
Rem On met au point la liste des textures à utiliser pour les tiles.
  xc=camera position x() : yc=camera position y() : zc=camera position z()
  xa=camera angle x() : ya=camera angle y() : za=camera angle z()
  _how_many=0
  xtiles=_matrix(_matrix,4) : ztiles=_matrix(_matrix,5)
  xsize=_matrix(_matrix,6) : zsize=_matrix(_matrix,7)
  for zbcl=0 to ztiles
    for xbcl=0 to xtiles
      img=_Matrix_Tile(_MATRIX,xbcl,zbcl)
      if img>0
        if _how_many=0
          _how_many=1
          _matrix_tilelist(_how_many)=img
          _matrix_realtile(_Matrix,xbcl,zbcl)=1
         else
          _exist=0
          for boucle=1 to _how_many
            if _matrix_tilelist(boucle)=img
              _exist=1
              _matrix_realtile(_Matrix,xbcl,zbcl)=boucle
             EndIf
           next boucle
          if _exist=0
            inc _how_many,1
            _matrix_tilelist(_how_many)=img
            _matrix_realtile(_Matrix,xbcl,zbcl)=_how_many
           endif
         endif
       endif
     next xbcl
   next zbcl
Rem On crée maintenant l'image qui servira à faire les tiles pour la matrice
  if _how_many=1 then _mode=1
  if _how_many>1 and _how_many<5 then _mode=2
  if _how_many>4 and _how_many<10 then _mode=3
  if _how_many>9 and _how_many<17 then _mode=4
  create bitmap 2,1024,768
  MW_Sync(0) : sync
  if _texturenum>0
    if _mode=1 or _mode=2
      if _matrix_tilelist(1)>0 then _Paste_scaled_Image(_matrix_tilelist(1)+_FirstTextureImage,0,0,xsize,zsize,2)
     endif
    if _mode=2
      if _matrix_tilelist(2)>0 then _Paste_scaled_Image(_matrix_tilelist(2)+_FirstTextureImage,xsize,0,xsize*2,zsize,2)
      if _matrix_tilelist(3)>0 then _Paste_scaled_Image(_matrix_tilelist(3)+_FirstTextureImage,0,zsize,xsize,zsize*2,2)
      if _matrix_tilelist(4)>0 then _Paste_scaled_Image(_matrix_tilelist(4)+_FirstTextureImage,xsize,zsize,xsize*2,zsize*2,2)
     endif
    if _mode=3
      xpos=0 : ypos=0
      for _til=1 to 9
        if _matrix_tilelist(_til)>0 then _Paste_scaled_Image(_matrix_tilelist(_til)+_FirstTextureImage,xpos,ypos,xpos+xsize,ypos+zsize,2)
        inc xpos,xsize : if xpos=xsize*3 then xpos=0 : inc ypos,zsize
       next _til
     endif
    if _mode=4
      xpos=0 : ypos=0
      for _til=1 to 16
        if _matrix_tilelist(_til)>0 then _Paste_scaled_Image(_matrix_tilelist(_til)+_FirstTextureImage,xpos,ypos,xpos+xsize,ypos+zsize,2)
        inc xpos,xsize : if xpos=xsize*4 then xpos=0 : inc ypos,zsize
       next _til
     endif
   EndIf
  _img=0 : set current bitmap 2
  MW_Sync(0) : sync
  repeat
    inc _img,1
   until image exist(_img)=0
  if _mode=0 then _mode=1 : Rem Force à saisir l'image même vide pour les textures.
  if _mode>0 then get image _img,0,0,xsize*_mode,zsize*_mode
  delete bitmap 2
  MW_Sync(0) : Sync
Rem On va crée l'image qui servira aux tiles .
Rem  if matrix exist(_MATRIX)=1 then delete matrix _MATRIX
Rem  sync
  xt=_Matrix(_MATRIX,4) : zt=_Matrix(_MATRIX,5) : xs=_Matrix(_MATRIX,6) : zs=_Matrix(_MATRIX,7)
  if matrix exist(_matrix)=0
    Rem Création de la matrice . . .
    make matrix _MATRIX,(xt*xs),(zt*zs),xt,zt
    Rem Positionnement . . .
    position matrix _MATRIX,_Matrix(_MATRIX,1),_Matrix(_MATRIX,2),_Matrix(_MATRIX,3)
   endif
  Rem Addition from version 2.30
  _ghostMode=_Matrix(_MATRIX,8)
  _WireFrame=_Matrix(_MATRIX,9)
  _Transparency=_Matrix(_MATRIX,10)
  _Cull=_Matrix(_MATRIX,11)
  _TextureFiltering=_Matrix(_MATRIX,12)
  _LightSensitive=_Matrix(_MATRIX,13)
  _FogSensitive=_Matrix(_MATRIX,14)
  _AmbientSensitive=_Matrix(_MATRIX,15)
  _ObjectCollisions=_Matrix(_MATRIX,16)
  Rem Définition des hauteurs des points .
  for xbcl=0 to xtiles
    for zbcl=0 to ztiles
      _ypos=_Matrix_Height(_matrix,xbcl,zbcl)
      set matrix height _matrix,xbcl,zbcl,_ypos
     next zbcl
   next xbcl
  Rem Mise en place des textures pour la matrice.
  if _texturenum>0
    if _mode>0
      prepare matrix texture _MATRIX,_img,_mode,_mode
      for xbcl=0 to (xtiles-1)
        for zbcl=0 to (ztiles-1)
          _tile=_matrix_realtile(_Matrix,xbcl,zbcl)
          if _tile=0 then _tile=1
          set matrix tile _Matrix,xbcl,zbcl,_tile
         next zbcl
       next xbcl
      delete image _img
     Endif
   EndIf
  update matrix _MATRIX
  set matrix _MATRIX,_Wireframe,_Transparency,_Cull,_TextureFiltering,_LightSensitive,_FogSensitive,_AmbientSensitive
  if _ghostmode=1 then ghost matrix on _MATRIX else ghost matrix off _MATRIX
Rem  update matrix _MATRIX
  position camera xc,yc,zc
  rotate camera xa,ya,za
  MW_Sync(0)
  sync
 EndFunction
Rem ****************************************************************************************************************
Function _Matrix_Properties(_matrix)
  if _matrix>0
    if matrix exist(_matrix)=1
      If MW_window_Exist(17)=0
        MW_Open_New_window(17,"--",196,182,1,1,0)
        MW_Position_Window(17,128,16)
        MW_paste_image(17,23,0,0)
        _modif=1
       else
        _modif=0
       Endif
      Rem Addition from version 2.30
      _ghostMode=_Matrix(_MATRIX,8)
      _WireFrame=_Matrix(_MATRIX,9)
      _Transparency=_Matrix(_MATRIX,10)
      _Cull=_Matrix(_MATRIX,11)
      _TextureFiltering=_Matrix(_MATRIX,12)
      _LightSensitive=_Matrix(_MATRIX,13)
      _FogSensitive=_Matrix(_MATRIX,14)
      _AmbientSensitive=_Matrix(_MATRIX,15)
      _ObjectCollisions=_Matrix(_MATRIX,16)
      _refresh_cases_matrixes(xwindow,ywindow,_ghostmode,_wireframe,_transparency,_cull,_texturefiltering,_lightsensitive,_fogsensitive,_ambientsensitive,_hiddenobject,_ObjectCollisions)
      _wnd=MW_Current_Window()
      if _wnd=17
        xm=MW_Window_Position_X() : ym=MW_Window_Position_Y()
        REM SELECTIONNER L'ICONE QUITTER
        if mouseclick()=1 and ym>0
          if xm>1 and xm<18
            if ym>19 and ym<36
              _modif=1 : inc _GhostMode : if _GhostMode=2 then _GhostMode=0
             endif
            if ym>35 and ym<52
              _modif=1 : inc _Wireframe : if _WireFrame=2 then _WireFrame=0
             endif
            if ym>51 and ym<78
              _modif=1 : inc _Transparency : if _Transparency=2 then _Transparency=0
             endif
            if ym>67 and ym<84
              _modif=1 : inc _Cull : if _Cull=2 then _Cull=0
             endif
            if ym>83 and ym<100
              _modif=1 : inc _TextureFiltering : if _TextureFiltering=2 then _TextureFiltering=0
             endif
            if ym>99 and ym<116
              _modif=1 : inc _LightSensitive : if _LightSensitive=2 then _LightSensitive=0
             endif
            if ym>115 and ym<132
              _modif=1 : inc _FogSensitive : if _FogSensitive=2 then _FogSensitive=0
             endif
            if ym>131 and ym<158
              _modif=1 : inc _AmbientSensitive : if _AmbientSensitive=2 then _AmbientSensitive=0
             endif
            if ym>147 and ym<164
              _modif=1 : inc _HiddenObject : if _HiddenObject=2 then _HiddenObject=0
             endif
            if ym>163 and ym<180
              _modif=1 : inc _ObjectCollisions : if _ObjectCollisions=2 then _ObjectCollisions=0
             endif
           endif
          REM ANTI Multi_click
          repeat
           until mouseclick()=0
         endif
       endif
      if _modif=1
        _Matrix(_MATRIX,8)=_ghostMode
        _Matrix(_MATRIX,9)=_WireFrame
        _Matrix(_MATRIX,10)=_Transparency
        _Matrix(_MATRIX,11)=_Cull
        _Matrix(_MATRIX,12)=_TextureFiltering
        _Matrix(_MATRIX,13)=_LightSensitive
        _Matrix(_MATRIX,14)=_FogSensitive
        _Matrix(_MATRIX,15)=_AmbientSensitive
        _Matrix(_MATRIX,16)=_ObjectCollisions
        _3DME_Refresh_Matrix(_matrix,_FirstTextureImage,_texturenum)
       endif
     Endif
   else
Rem    If MW_Window_Exist(17)=1 then MW_Close_window(17)
   endif
 EndFunction
Rem ****************************************************************************************************************
Function _refresh_cases_matrixes(xwindow,ywindow,_ghostmode,_wireframe,_transparency,_cull,_texturefiltering,_lightsensitive,_fogsensitive,_ambientsensitive,_hiddenobject,_ObjectCollisions)
  if _ghostmode=1 then MW_Paste_Image(17,9,2,20) else MW_Paste_Image(17,8,2,20)
  if _wireframe=1 then MW_Paste_Image(17,8,2,36) else MW_Paste_Image(17,9,2,36)
  if _Transparency=1 then MW_Paste_Image(17,8,2,52) else MW_Paste_Image(17,9,2,52)
  if _Cull=1 then MW_Paste_Image(17,8,2,68) else MW_Paste_Image(17,9,2,68)
  if _TextureFiltering=1 then MW_Paste_Image(17,9,2,84) else MW_Paste_Image(17,8,2,84)
  if _LightSensitive=1 then MW_Paste_Image(17,9,2,100) else MW_Paste_Image(17,8,2,100)
  if _FogSensitive=1 then MW_Paste_Image(17,9,2,116) else MW_Paste_Image(17,8,2,116)
  if _AmbientSensitive=1 then MW_Paste_Image(17,9,2,132) else MW_Paste_Image(17,8,2,132)
  if _HiddenObject=1 then MW_Paste_Image(17,9,2,148) else MW_Paste_Image(17,8,2,148)
  if _ObjectCollisions=1 then MW_Paste_Image(17,9,2,164) else MW_Paste_Image(17,8,2,164)
 EndFunction
Rem ****************************************************************************************************************
Function Fct_Select_Matrix(newmatrix,_lastmatrix)
  pageupkey=201
  pagedownkey=209
  inserkey=210
  supprkey=211
  defaultkey=199
  _FirstTextureImage=70
  repeat
    MW_BackGround_Task()
    key=scancode()
    if key=inserkey then inc newmatrix
    if key=supprkey then dec newmatrix
    if newmatrix>_lastmatrix then newmatrix=_lastmatrix
    if newmatrix<1 then newmatrix=1
    if upkey()=1 then move camera 10
    if downkey()=1 then move camera 0-10
    xc#=camera position x()
    zc#=camera position z()
    x=xc#/64 : z=zc#/64
    position object 1,-1.75+(x*64),-1,-1.75+(z*64)
    if mouseclick()=1 then _3DMEMW_Check_Mouse_View()
    MW_Ink(12,128,128,128)
    MW_Set_Cursor(14,0,0)
    MW_Print(12,"Matrix :")
    MW_Print(12,"   "+str$(newmatrix))
    ycurs=mousey() : xcurs=mousex()
    sprite 2,xcurs,ycurs,3
    if matrix exist(newmatrix)=1
      xpos=matrix position x(newmatrix) : ypos=matrix position y(newmatrix) : zpos=matrix position z(newmatrix)
      point camera xpos,ypos,zpos
     endif
    MW_sync(0)
    sync
    MW_Cls(12,32,32,32)
   until spacekey()=1 or mouseclick()=2
  repeat
   until spacekey()=0 and mouseclick()=0
 EndFunction newmatrix
Rem ****************************************************************************************************************
Function _3DME_Random_Height(_matrix,ymax,ymin,y0,alfa)
  if matrix exist(_matrix)=1
    xtiles=_Matrix(_matrix,4) : Rem X
    ztiles=_Matrix(_matrix,5) : Rem Z
    _Matrix_Height(_matrix,0,0)=y0
    Rem D'abord on définit la première verticale et horizontale.
    for boucle=1 to xtiles
      Rem pour X
      ypos=_Matrix_Height(_MATRIX,boucle-1,0)
      deca=rnd(alfa)-(alfa/2) : ypos=ypos+deca
      if ypos>ymax then ypos=ymax
      if ypox<ymin then ypos=ymin
      _Matrix_Height(_MATRIX,boucle,0)=ypos
      set matrix height _matrix,boucle,0,ypos
     next boucle
    for boucle=1 to ztiles
      Rem pour Z
      ypos=_Matrix_Height(_MATRIX,0,boucle-1)
      deca=rnd(alfa)-(alfa/2) : ypos=ypos+deca
      if ypos>ymax then ypos=ymax
      if ypox<ymin then ypos=ymin
      _Matrix_Height(_MATRIX,0,boucle)=ypos
      set matrix height _matrix,0,boucle,ypos
     next boucle
    Rem Maintenant on définit tout les autres points.
    for xpnt=1 to xtiles
      for zpnt=1 to ztiles
        ypos1=_Matrix_Height(_MATRIX,xpnt-1,zpnt)
        ypos2=_Matrix_Height(_MATRIX,xpnt,zpnt-1)
        ypos=(ypos1+ypos2)/2
        deca=rnd(alfa)-(alfa/2) : ypos=ypos+deca
        if ypos>ymax then ypos=ymax
        if ypox<ymin then ypos=ymin
        _Matrix_Height(_MATRIX,xpnt,zpnt)=ypos
        set matrix height _matrix,xpnt,zpnt,ypos
       next zpnt
     next xpnt
    Update matrix _matrix
   endif
 Endfunction
REMSTART
  _Matrix(_MATRIX,1)=Matrix X Position
  _Matrix(_MATRIX,2)=Matrix Y Position
  _Matrix(_MATRIX,3)=Matrix Z Position
  _Matrix(_MATRIX,4)=X Number of tiles
  _Matrix(_MATRIX,5)=Z Number of tiles
  _Matrix(_MATRIX,6)=X tiles size
  _Matrix(_MATRIX,7)=Z tiles size
  _Matrix(_MATRIX,8)=Mode GHOST
  _Matrix(_MATRIX,9)=Fil De Fer
  _Matrix(_MATRIX,10)=Transparence
  _Matrix(_MATRIX,11)=faces cachées
  _Matrix(_MATRIX,12)=filtrage de textures
  _Matrix(_MATRIX,13)=sensible à la lumière
  _Matrix(_MATRIX,14)=sensible au brouillard
  _Matrix(_MATRIX,15)=sensebile à la lumière ambiante
  _Matrix(_MATRIX,16)=collisions actives.
  _Matrix_Heigth(_MATRIX,X,Z)=Height of the point X,Z of the matrix _MATRIX
  _Matrix_Tile(_MATRIX,X,Z)=Texture used for the tile X,Z of the matrix _MATRIX
REMEND

Rem
Rem Functions to use MATRIXES with 3DMapEditor's maps .
Rem
Function _Check_for_ground(xpos#,ypos#,zpos#,ysize#)
  _lastmatrix=_Matrix(0,0)
  ysize#=ysize#/2.0
  Rem On initialize les valeurs de l'objet en cours pour le calcul.
  if _lastmatrix>0
    for boucle=1 to _lastmatrix
      xpm=_Matrix(boucle,1) : zpm=_Matrix(boucle,3)
      xmax=xpm+(_Matrix(boucle,4)*_Matrix(boucle,6))
      zmax=zpm+(_Matrix(boucle,5)*_Matrix(boucle,7))
      Rem On vérifie si les coordonnées du joueur se trouvent sur la matrice
      Rem et si les collisions de celle-ci sont activées.
      if xpos#>xpm and xpos#<xmax and zpos#>zpm and zpos#<xmax and _Matrix(boucle,16)=1
        _ymat#=get ground height(boucle,int(xpos#)-xpm,int(zpos#)-zpm)
        if ypos#>_ymat
          Rem Checking si la camera ou l'objet est en dessus de la matrice ( = SOL )
          if int(ypos#-_ymat#)<ysize# then ypos#=_ymat#+ysize#
         else
          Rem Checking si la camera ou l'objet est en dessous de la matrice ( = PLAFOND )
          if int(_ymat#-ypos#)<ysize# then ypos#=_ymat#-ysize#
         endif
       endif
     Next boucle
   EndIf
 EndFunction ypos#

Rem
Rem _3DMEMW_Make_Icon_Graphics(_firstimage)         Charge tout les icones graphiques à partir d'un bitmap.
Rem _3DMEMW_Clear_Icon_Graphics()                   Efface tout les icones graphiques utilisés.
Rem _3DMEMW_Create_All_windows(_firstimage)         Crée toutes les fenêtres pour 3DMapEditor.
Rem _3DMEMW_Check_Mouse_View()                      Gère la vue 3D si click en dehors des fenêtres MW.
Rem
Function _3DMeMW_Make_Icon_Graphics(_firstimage)
  _ERROR=0 : _bmp=4
  if bitmap exist(_bmp)=1 then delete bitmap _bmp : sync
  if file exist("editor\icones_v3.jpg")=1
    _buttons(1)=_firstimage
    create bitmap _bmp,800,600
    load bitmap "editor\icones_v3.jpg",_bmp : sync
    set current bitmap _bmp
    sync
    Rem Saisie 1 : SYSTEM
    xpos=0 : ypos=0
    for boucle=1 to 12 step 1
      get image _firstimage,xpos,ypos,xpos+32,ypos+32
      inc xpos,32 : inc _firstimage,1 : wait 1
     next boucle
    Rem Saisie 2 : TEXTURES
    xpos=0 : ypos=32
    for boucle=1 to 14 step 1
      get image _firstimage,xpos,ypos,xpos+32,ypos+32
      inc xpos,32 : inc _firstimage,1 : wait 1
     next boucle
    Rem Saisie 3 : OBJECTS IMPORTATION
    xpos=0 : ypos=32*2
    for boucle=1 to 8 step 1
      get image _firstimage,xpos,ypos,xpos+32,ypos+32
      inc xpos,32 : inc _firstimage,1 : wait 1
     next boucle
    Rem Saisie 4 : 3D SOUNDS
    xpos=0 : ypos=32*3
    for boucle=1 to 8 step 1
      get image _firstimage,xpos,ypos,xpos+32,ypos+32
      inc xpos,32 : inc _firstimage,1 : wait 1
     next boucle
    Rem Saisie 5 : LIGHTS
    xpos=0 : ypos=32*4
    for boucle=1 to 8 step 1
      get image _firstimage,xpos,ypos,xpos+32,ypos+32
      inc xpos,32 : inc _firstimage,1 : wait 1
     next boucle
    Rem Saisie 6 : OBJECTS ADDING
    xpos=0 : ypos=32*5
    for boucle=1 to 12 step 1
      get image _firstimage,xpos,ypos,xpos+32,ypos+32
      inc xpos,32 : inc _firstimage,1 : wait 1
     next boucle
    Rem Saisie 7 : OBJECTS MODIFICATIONS
    xpos=0 : ypos=32*6
    for boucle=1 to 18 step 1
      get image _firstimage,xpos,ypos,xpos+32,ypos+32
      inc xpos,32 : inc _firstimage,1 : wait 1
     next boucle
    Rem Saisie 8 : ACTION ZONES
    xpos=0 : ypos=32*7
    for boucle=1 to 12 step 1
      get image _firstimage,xpos,ypos,xpos+32,ypos+32
      inc xpos,32 : inc _firstimage,1 : wait 1
     next boucle
    Rem Saisie 9 : MATRIXES
    xpos=0 : ypos=32*8
    for boucle=1 to 18 step 1
      get image _firstimage,xpos,ypos,xpos+32,ypos+32
      inc xpos,32 : inc _firstimage,1 : wait 1
     next boucle
   Endif
  _buttons(2)=_firstimage : sync
  if bitmap exist(_bmp)=1 then delete bitmap _bmp : sync
 EndFunction
Rem
Function _3DMEMW_Clear_Icon_Graphics()
  _first=_buttons(1)
  _last=_buttons(2)
  if _last>_first
    for boucle=_first to _last
      if image exist(boucle)=1 then delete image boucle
     next boucle
   endif
 endfunction
Rem
Function _3DMEMW_Create_All_windows(_firstimage2)
  Rem FENETRE #02 : Système
  MW_Open_New_Window(2,"System",32*6,32,1,1,0)
  For boucle=1 to 6
    MW_Create_Graphical_Gadget(2,boucle,_firstimage2,(boucle-1)*32,0,32,32)
    inc _firstimage2,1*2
   Next boucle
  Rem FENETRE #03 : TEXTURES
  MW_Open_New_Window(3,"Textures",32*7,32,1,1,0)
  For boucle=1 to 7
    MW_Create_Graphical_Gadget(3,boucle,_firstimage2,(boucle-1)*32,0,32,32)
    inc _firstimage2,1*2
   Next boucle
  Rem FENETRE #04 : OBJECTS IMPORTATION
  MW_Open_New_Window(4,"Objects Importation",32*4,32,1,1,0)
  For boucle=1 to 4
    MW_Create_Graphical_Gadget(4,boucle,_firstimage2,(boucle-1)*32,0,32,32)
    inc _firstimage2,1*2
   Next boucle
  Rem FENETRE #05 : 3D SOUNDS
  MW_Open_New_Window(5,"3D Sound",32*4,32,1,1,0)
  For boucle=1 to 4
    MW_Create_Graphical_Gadget(5,boucle,_firstimage2,(boucle-1)*32,0,32,32)
    inc _firstimage2,1*2
   Next boucle
  Rem FENETRE #06 : LIGHTS
  MW_Open_New_Window(6,"Lights",32*4,32,1,1,0)
  For boucle=1 to 4
    MW_Create_Graphical_Gadget(6,boucle,_firstimage2,(boucle-1)*32,0,32,32)
    inc _firstimage2,1*2
   Next boucle
  Rem FENETRE #07 : OBJECTS ADDING
  MW_Open_New_Window(7,"Objects Adding",32*6,32,1,1,0)
  For boucle=1 to 6
    MW_Create_Graphical_Gadget(7,boucle,_firstimage2,(boucle-1)*32,0,32,32)
    inc _firstimage2,1*2
   Next boucle
  Rem FENETRE #08 : OBJECTS MODIFICATIONS
  MW_Open_New_Window(8,"Objects Modifications",32*9,32,1,1,0)
  For boucle=1 to 9
    MW_Create_Graphical_Gadget(8,boucle,_firstimage2,(boucle-1)*32,0,32,32)
    inc _firstimage2,1*2
   Next boucle
  Rem FENETRE #09 : ACTION ZONES
  MW_Open_New_Window(9,"Action Zones",32*6,32,1,1,0)
  For boucle=1 to 6
    MW_Create_Graphical_Gadget(9,boucle,_firstimage2,(boucle-1)*32,0,32,32)
    inc _firstimage2,1*2
   Next boucle
  Rem FENETRE #10 : MATRIXES
  MW_Open_New_Window(10,"Matrixes",32*9,32,1,1,0)
  For boucle=1 to 9
    MW_Create_Graphical_Gadget(10,boucle,_firstimage2,(boucle-1)*32,0,32,32)
    inc _firstimage2,1*2
   Next boucle
  Rem FENETRE #11 : FENETRE DE MINIATURES DES TEXTURES
  MW_Open_New_Window(24,"Texture",64,240,1,1,0)
  Rem FENETRE #12 : ACTIONS
  MW_Open_New_Window(12,"Actions",64,106,1,1,0)
  Rem FENETRE #13 : DIALOGUES
  MW_Open_New_Window(13,"Dialogues",572,16,1,1,0)
  Rem FENETRE #14 : COUNTER
  MW_Open_New_Window(14,"Count",64,16,1,1,0)
 EndFunction

Function _3DMEMW_Check_Mouse_View()
    _window=MW_Current_Window()
    _gadget=MW_Current_gadget()
    if _window=0
      xm=mousex() : ym=mousey()
      hide sprite 2
      Repeat
        yadd=xm-mousex() : xadd=ym-mousey()
        xangle=wrapvalue(camera angle x()-xadd)
        yangle=wrapvalue(camera angle y()-yadd)
        rotate camera xangle,yangle,0
        position mouse xm,ym
        if upkey()=1 then move camera 10
        if downkey()=1 then move camera 0-10
        xc#=camera position x()
        zc#=camera position z()
        x=xc#/64 : z=zc#/64
        position object 1,-1.75+(x*64),-1,-1.75+(z*64)
        _CheckFor7Lights()
        MW_Sync(0)
        sync
       until mouseclick()=0
      position mouse xm,ym
      show sprite 2
     endif
 EndFunction

Rem
Rem My Synchro Function for _3DMEEditor
Rem
Function Fct_WaitSynchro(_sync)
  movespeed=16
  movespeedneg=0-movespeed
  cx#=camera angle x()
  cy#=camera angle y()
  for boucle=1 to _Sync
    position mouse 320,240
    MW_Background_Task()
    MW_Sync(0)
    sync
   next boucle
 EndFunction


Rem *****************
Rem * Magic-Windows *
Rem *****************
Rem Ver 1.3
Rem Date 28.11.02 - 29.11.02 - 10.12.02 - 30.01.03 - 03.02.03 - 11.02.03
Rem      19.02.03 - 23.02.03
Rem
Rem ----------------
Rem Still to do :
Rem        - Optimiser pour éviter de retracer le gadget actif en cas de non changement d'état.
Rem        - Fonction pour désactiver les gadgets en 2 couleurs et n'en utiliser qu'un . . .
Rem 1.3 news :
Rem        - Optimisation pour les redimensionnements de fenêtres . . .
Rem        - Mise en place du système de désactivation des bordures de fenêtres . . .
Rem        - Gérer les priorité d'affichage des sprites pour les fenêtres . . .
Rem        - Sprite mode is now fast for windows and menu.
Rem        - Optim : texts outputs are now faster -speed up improvements-
Rem        - MW_Input : do not erase deleted characters in window now fixed.
Rem        - Some small functions bugs ( endfunction , function names )
Rem        - Menu color lighter ( more near to windows98 default colors )
Rem
Rem MAGIC-WINDOWS Ver1.3 NEEDED VALUES :
Rem Dim _Windows_sys(34) : Dim _Windows_Order(16)
Rem Dim _Windows_Data(24,32) : Dim _Windows_Title$(24) : Dim _Windows_Font$(24)
Rem Dim _Windows_Gadget(24,32,8) : Dim _Windows_Gadget_Text$(24,32) : Dim _Windows_Text$(64)
Rem Dim _Windows_Default(32,2)
Rem dim fileselector$(9) : dim fileselectordata(13) : dim _filespath$(7) : dim _fichier$(256)
Rem fileselector$(1)=get dir$() : fileselector$(2)="File Selector Title"
Rem Dim _Menu_Option$(5,17) : Dim _Menu_State(5,17) : Dim _Menu_Logo(5,17) : Dim _Menu_sys(8)
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Open_New_Window(_Window,title$,x,y,close,prior,size)                               Crée une nouvelle fenêtre.
Rem MW_Position_Window(_Window,xpos,ypos)                 Repositionne la fenêtre dans l'écran visible ( Bitmap 0 ).
Rem MW_Close_Window(_Window)                                                            Ferme une fenêtre existante.
Rem MW_Resize_Window(_Window,NewXSize,NewYSize)                                 Redimensionne une fenêtre existante.
Rem MW_Window_bgd(_Window,_red,_green,_blue)                    Définit la couleur du fond de la fenêtre par défaut.
Rem MW_Window_Borders(_Window,_red1,_green1,_blue1,_red2,_green2,_blue2)          Définit les couleurs des bordures.
Rem MW_Window_To_Front(_window)                                              Met la fenêtre choisie au premier plan.
Rem MW_Window_To_Back(_window)                                               Met la fenêtre choisie au dernier plan.
Rem MW_Screen_Title_On()                                             Active l'affichage du titre en haut de l'écran.
Rem MW_Screen_Title_Off()                                         Désactive l'affichage du titre en haut de l'écran.
Rem MW_Set_Screen_Title(_title$) [NEW]                          Permet de définir le titre de l'écran Magic-Windows.
Rem MW_Set_Window_Alpha(_window,_alpha) [NEW]     Utilise la transparence si la fenêtre est affichée en mode sprite.
Rem MW_Load_Default_Positions() [NEW]             Charge les dernières positions des fenêtres à partir d'un fichier.
Rem MW_Save_Default_Positions() [NEW]                   Sauvegarde les dernières positions des fenêtres sur fichier.
Rem ------------------------------------------------------------------------------------ MW 2D FUNCTIONS -----------
Rem MW_Cls(_Window,_red,_green,_blue)                                   Vide la fenêtre avec une couleur spécifique.
Rem MW_Ink(_Window,red,green,blue)                             Définit la couleur d'écriture du texte de la fenêtre.
Rem MW_Box(_Window,x1,y1,x2,y2)                                                  Déssine une boite dans une fenêtre.
Rem MW_Empty_Box(_Window,x1,y1,x2,y2)                                             Draw an empty box inside a window.
Rem MW_Line(_Window,x1,y1,x2,y2)                                                 Déssine une ligne dans une fenêtre.
Rem MW_Dot(_Window,x,y)                                                           Déssine un point dans une fenêtre.
Rem ------------------------------------------------------------------------------- MW 2D GRAPHICS FUNCTIONS -------
Rem MW_Get_Image(_Window,_Image,Xpos,Ypos,Xpos2,Ypos2)                        Crée une image saisie dans la fenêtre.
Rem MW_Paste_Image(_Window,_Image,Xpos,Ypos)                                     Affiche une image dans une fenêtre.
Rem MW_Copy_Bitmap2Window(_Bitmap,X,Y,X2,Y2,_Window,X3,Y3,X4,Y4)      Copie une partie d'un bitmap dans une fenêtre.
Rem MW_Copy_Window2Bitmap(_Window,X,Y,X2,Y2,_Bitmap,X3,Y3,X4,Y4)      Copie une partie d'une fenêtre dans un bitmap.
Rem MW_Copy_Window2Window(_Window,X,Y,X2,Y2,_Window,X3,Y2,X4,Y4)      Copie une partie d'une fenêtre dans une autre.
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Print(_Window,_text$)                                                 Ecrit un texte dans la fenêtre choisie.
Rem MW_MPrint(_Window,_text$)                         Ecrit un texte dans la fenêtre choisie sans retour à la ligne.
Rem MW_Text(_Window,xpos,ypos,_text$)                     Ecrit un texte en le centrant par rapport aux coordonnées.
Rem MW_Set_Cursor(_Window,Xcurs,Ycurs)               Redéfinit la position du curseur texte dans la fenêtre choisie.
Rem MW_Set_Font_Size(_Window,_FontSize)                     Redéfinit la dimension des textes de la fenêtre choisie.
Rem MW_Set_Font_Name(_Window,_fonte$)                 Définit quel type d'écriture utiliser dans la fanêtre choisie.
Rem =MW_Input(_window,_texte$)                                                  équivalent d'un style INPUT de 3DGC.
Rem MW_Set_Text_Normal(_Window)                                                  Define text as default DBv1 values.
Rem MW_Set_Text_Opaque(_window)                                                          Define text as opaque text.
Rem MW_Set_Text_Transparent(_Window)                                                Define text as transparent text.
Rem MW_Set_Text_To_Italic(_Window)                                                       Use Italic for text output.
Rem MW_Set_Text_To_Bold(_Window)                                                           Use bold for text output.
Rem MW_Set_Text_To_BoldItalic(_Window)                                          Use bold and italic for text output.
Rem MW_Set_Text_To_Normal_Sys() [SYSTEM]                              Check mode and active it if needed (speed up).
Rem MW_Set_Text_To_Italic_Sys() [SYSTEM]                              Check mode and active it if needed (speed up).
Rem MW_Set_Text_To_Bold_Sys() [SYSTEM]                                Check mode and active it if needed (speed up).
Rem MW_Set_Text_To_BoldItalic_Sys() [SYSTEM]                          Check mode and active it if needed (speed up).
Rem MW_Set_Text_Size_Sys() [SYSTEM]                                   Check mode and active it if needed (speed up).
Rem MW_Set_Text_Opaque_Sys() [SYSTEM]                                 Check mode and active it if needed (speed up).
Rem MW_Set_Text_Transparent_Sys() [SYSTEM]                            Check mode and active it if needed (speed up).
Rem MW_Set_Text_Font_sys(font$) [SYSTEM]                              Check mode and active it if needed (speed up).
Rem ----------------------------------------------------------------------------------- MW DISK FUNCTIONS ----------
Rem MW_Load_Bitmap2Window(_file$,_window)                            Charge une image .bmp ou .jpg dans une fenêtre.
Rem MW_Save_WindowImage(_windonw,_file$)                    Sauvegarde le contenu d'une fenêtre en image sur disque.
Rem =MW_File_Selector_v2(_window,_loaderpath$,filter1$,filter2$)          Crée une fenêtre de sélecteur de fichiers.
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Create_Text_Gadget(_Window,_Gadget,_Text$,XPos,Ypos,Xsize,Ysize)                Crée un gadget de type texte.
Rem MW_Create_Graphical_Gadget(_Window,_Gadget,_Image,Xpos,Ypos,Xsize,Ysize)       Crée un gadget de type graphique.
Rem MW_Set_Alternate_Gadget_Image(_Window,_Gadget,_Image)               Créer l'image alternée de l'icone graphique.
Rem MW_Refresh_Gadget(_window,_gadget)                                         Redéssine un gadget dans une fenêtre.
Rem MW_Delete_Gadget(_Window,_Gadget)                                                     Efface un gadget existant.
Rem MW_Disable_Gadget(_Window,_Gadget)                                              Rend un gadget existant inactif.
Rem MW_Enable_Gadget(_Window,_Gadget)                                                 Rend un gadget existant actif.
Rem MW_Refresh_Text_Gadget(_window,_gadget)                     Rafraichit un gadget de type texte dans une fenetre.
Rem MW_Refresh_Text_Gadget_Light(_window,_gadget) [SYSTEM]            Rafraichit un gadget de type texte en + clair.
Rem MW_Refresh_Graphic_Gadget(_window,_gadget)                  Rafraichit un gadget de type texte dans une fenetre.
Rem MW_Refresh_Graphic_Gadget_Light(_winnum,_gadget) [SYSTEM]     Rafraichit un icone en utilisant l'image alternée.
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Initialize_Tiles(_firstimage)             Charge les images qui serviront à la partie graphique des fenêtres.
Rem MW_Release_All()                                     Libère la mémoire utilisée par les graphiques des fenêtres.
Rem MW_Sync()                                     Réactualise toutes les fenêtres dans l'écran visible ( Bitmap 0 ).
Rem MW_BackGround_Task()                        Permet les déplacement , dimensionnement , fermetures en temps réel.
Rem MW_Retrace_Window(_Window)                                Retrace entièrement la fenêtre ( bordures , contenu ).
Rem MW_Auto_Refresh_On()                             Active le rafraichissement de bords de fenêtres à chaque frame.
Rem MW_Auto_Refresh_Off()                        Désactive la fonctionalité ( peut permettre de gagner quelques FPS.
Rem MW_Enable_RealTime_Moving()                         Active le mode temps réel pour les déplacements de fenêtres.
Rem MW_Disable_RealTime_Moving()                     Désactive le mode temps réel pour les déplacements de fenêtres.
Rem MW_Enable_RealTime_Scaling()                   Active le mode temps réel pour les redimensionnement de fenêtres.
Rem MW_Disable_RealTime_Scaling()               Désactive le mode temps réel pour les redimensionnement de fenêtres.
Rem MW_Enable_RealTime_DrawingPriority()      Active le mode temps réel pour les changement de priorité d'affichage.
Rem MW_Disable_RealTime_DrawingPriority()  Désactive le mode temps réel pour les changement de priorité d'affichage.
Rem MW_AutoClearMode_On()                                            Active le mode CLS sur le bitmap 0 automatique.
Rem MW_AutoClearMode_Off()                              Désactive le mode CLS sur le bitmap 0 automatique (=défaut).
Rem MW_BackgroundRefreshMode_On()                    Active le mode de rafraichissement automatique du fond d'image.
Rem MW_BackgroundRefreshMode_Off()       Désactive le mode de rafraichissement automatique du fond d'image(=defaut).
Rem MW_Sprite_Mode_On()                                         Active le mode d'affichage des fenêtres par sprites.
Rem MW_Paste_Mode_On()                                     Active le mode d'affichage des fenêtres par paste images.
Rem MW_DBPro_Mode_On()                             Active le FLAG pour les images désactivant le mode BLUR de dbpro.
Rem MW_Auto_Images_To_VideoRam()           Load Automatically images to VideoRam (DBv1) equal to MW_DBPro_Mode_On().
Rem MW_Auto_Images_Compression_On()                Load images to videoram and use texture compression if available.
Rem MW_Auto_Images_To_SystemRam()                  Load images to videoram and use texture compression if available.
Rem MW_Auto_Position_Save_on() [NEW]                                Sauvegarde les dernières positions des fenêtres.
Rem MW_Auto_Position_Save_off() [NEW]                        Ne sauvegarde pas les dernières positions des fenêtres.
Rem MW_Set_Mouse_Pointer(_image) [NEW]                            Utilise un sprite pour faire le curseur graphique.
Rem MW_Default_Mouse_Pointer() [NEW]                                             Remet le curseur de souris de DBv1.
Rem MW_Hide_Windows_Border() [NEW]                                          n'affiche pas les bordures des fenêtres.
Rem MW_Show_Windows_Border() [NEW]                                      Affiche les bordures des fenêtres (=defaut).
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem =MW_MagicWindows_Initialized()                                   =1 si le système a été initialisé correctement.
Rem =MW_Window_Exist(_window)                                       Renvoie 1 si la fenêtre demandée existe sinon 0.
Rem =MW_Window_XSize(_window)                      Renvoie la dimension sur X de la fenêtre demandée si elle existe.
Rem =MW_Window_YSize(_window)                      Renvoie la dimension sur Y de la fenêtre demandée si elle existe.
Rem =MW_Window_XPosition(_window)      Renvoie la position sur X dans l'écran de la fenêtre demandée si elle existe.
Rem =MW_Window_YPosition(_window)      Renvoie la position sur Y dans l'écran de la fenêtre demandée si elle existe.
Rem =MW_Current_Window()                Renvoie le numéro de la fenêtre devant laquelle le curseur de la souris est.
Rem =MW_Current_Gadget()                  Renvoie le numéro du gadget au dessus duquel le pointeur de la souris est.
Rem =MW_Realtime_Moving_State()                 =1 si le mode Temps-Réel pour les déplacements de fenêtre est actif.
Rem =MW_Realtime_Scaling_State()          =1 si le mode Temps-Réel pour les redimensionnements de fenêtre est actif.
Rem =MW_Realtime_Drawing_State()    =1 si le mode Temps-Réel pour les changements de priorité d'affichage est actif.
Rem =MW_Window_Over() [SYSTEM]          Renvoie le numéro de la fenêtre devant laquelle le curseur de la souris est.
Rem =MW_Window_Gadget(_window) [SYSTEM]   Renvoie le numéro du gadget au dessus duquel le pointeur de la souris est.
Rem =MW_Gadget_Exist(_Window,_Gadget)                                                =1 si le gadget demandé existe.
Rem =MW_Gadget_Type(_Window,_Gadget)                                             Renvoie quel type de gadget est-ce.
Rem =MW_Gadget_Active(_Window_Gadget)                                           =1 si le gadget existe et est actif.
Rem =MW_Window_Position_X()               Renvoie la position sur X du curseur à l'intérieur de la fenêtre courante.
Rem =MW_Window_Position_Y()               Renvoie la position sur Y du curseur à l'intérieur de la fenêtre courante.
Rem ...$=MW_Get_FileName()              Donne le nom du dernier fichier choisi avec le sélecteur de fichier intégré.
Rem ...$=MW_Get_DrawerName()            Donne le nom du dernier dossier choisi avec le sélecteur de fichier intégré.
Rem =MW_RequestBox1(_winnum,title$,_desc$,item$)                    Ouvre une fenêtre de requête et attend un choix.
Rem =MW_RequestBox2(_winnum,title$,_desc$,item1$,item2$)            Ouvre une fenêtre de requête et attend un choix.
Rem =MW_RequestBox3(_winnum,title$,_desc$,itm1$,itm2$,itm3$)        Ouvre une fenêtre de requête et attend un choix.
Rem =MW_Windows_Opened() [NEW]                 Renvoie le nombre correspondant à la quantité de fenêtres existantes.
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Check_Menu() [NEW] [SYSTEM]                                        Redéssine le menu à l'écran si nécessaire.
Rem MW_Get_Menu_State() [NEW]                               Renvoie 1 si un menu ou une option est survolée sinon 0.
Rem MW_Get_Choosen_Menu() [NEW]                                     Renvoie le nombre correspondant au menu survolé.
Rem MW_Get_Choosen_Option() [NEW]                               Renvoie le nombre correspondant à l'option survolée.
Rem MW_Set_Menu_Title(menu,title$) [NEW]                                                 Définir le titre d'un menu.
Rem MW_Set_Menu_Option(menu,option,title$) [NEW]                                       Définir une option d'un menu.
Rem MW_Set_Menu_Image(_menu,_option,_image) [NEW]                            Définir l'image miniature d'une option.
Rem MW_Set_Menu_Transition(menu,option) [NEW]                             Définir une option en tant que transition.
Rem MW_Prepare_Menu_v3() [NEW]                                                   Créer le menu selon les paramètres.
Rem MW_Refresh_Menu_Option(xmenu,ymenu,state) [SYSTEM]                              Rafraîchit une option d'un menu.
Rem MW_Refresh_Menu_Title(xmenu,state) [SYSTEM]                                          Rafraîchit 1 titre de menu.
Rem MW_Show_Title_Bar() [SYSTEM]                                               Affiche la barre des menus à l'écran.
Rem MW_Show_Menu_Bar() [SYSTEM]                                                   Affiche un menu complet à l'écran.
Rem ------------------------------------------------------------------------------------- ----------- --------------
Rem STILL TO DO :
Rem
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Enable_Gadget_AutoRefresh()        redéssine tout les gadgets à chaque FPS. ( permet les gadget en 2 images )
Rem MW_Disable_Gadget_AutoRefresh()                                                   désactive cette fonctionalité.
Rem MW_Create_Predefined_Gadget(_Window,_Gadget,_Type,Xpos,Ypos)          Crée un gadget parmi une liste prédéfinié.
Rem ----------------------------------------------------------------------------------------------------------------
Rem
Rem
Rem
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Open_New_Window(_Window,title$,x,y,close,prior,size)                               Crée une nouvelle fenêtre.
Function MW_Open_New_window(_winnum,title$,xsize,ysize,closegad,displaygad,sizegad)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _Windows_Data(_winnum,1)=0
      if bitmap exist(32-_winnum)=0
        _howmany=_Windows_Sys(4)
        inc _howmany : _Windows_Order(_HowMany)=_winnum
        _Windows_Sys(4)=_howmany
        create bitmap 32-_winnum,xsize+4,ysize+14
        _Windows_Data(_winnum,1)=1
        if _Windows_sys(30)=0
          _Windows_Data(_winnum,2)=0 : _Windows_Data(_winnum,3)=12
         else
          _Windows_Data(_winnum,2)=_Windows_Default(_winnum,1)
          _Windows_Data(_winnum,3)=_Windows_Default(_winnum,2)
         endif
        _Windows_Data(_winnum,4)=xsize : _Windows_Data(_winnum,5)=ysize
        _Windows_Data(_winnum,6)=closegad : _Windows_Data(_winnum,7)=sizegad : _Windows_Data(_winnum,8)=displaygad
        _Windows_Title$(_winnum)=title$
        _Windows_Data(_winnum,9)=33 : _Windows_Data(_winnum,10)=33 : _Windows_Data(_winnum,11)=33 : Rem BGD ink
        _Windows_Data(_winnum,12)=0 : _Windows_Data(_winnum,13)=0 : Rem Cursor position
        _Windows_Data(_winnum,14)=255 : _Windows_Data(_winnum,15)=255 : _Windows_Data(_winnum,16)=255 : Rem Ink RGB
        Rem Default border colors.
        _Windows_Data(_winnum,18)=183 : _Windows_Data(_winnum,19)=183
        _Windows_Data(_winnum,20)=183 : _Windows_Data(_winnum,21)=106
        _Windows_Data(_winnum,22)=106 : _Windows_Data(_winnum,23)=106
        Rem Default Font Attributes
        _Windows_Font$(_winnum)="times new roman" : _Windows_Data(_winnum,17)=12 : Rem Font
        xsize=_Windows_Data(_winnum,4) : ysize=_Windows_Data(_winnum,5)
        _red=_windows_Data(_winnum,9) : _green=_windows_Data(_winnum,10) : _blue=_windows_Data(_winnum,11)
        _img=_Windows_sys(1)
        ink rgb(_red,_green,_blue),0
        box 0,0,xsize+3,ysize+13
        MW_Retrace_Window(_winnum)
       else
        _ERROR=-3
       Endif
     else
      _ERROR=-2
     endif
   else
    _ERROR=-1
   endif
 Endfunction _ERROR
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Position_Window(_Window,xpos,ypos)                 Repositionne la fenêtre dans l'écran visible ( Bitmap 0 ).
Function MW_Position_Window(_winnum,xpos,ypos)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _Windows_Data(_winnum,1)=1
      if xpos<0 then xpos=0
      if ypos<12 then ypos=12
      _Windows_Data(_winnum,2)=xpos
      _Windows_Data(_winnum,3)=ypos
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
  _Windows_Data(_winnum,0)=2
 Endfunction _ERROR
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Close_Window(_Window)                                                            Ferme une fenêtre existante.
Function MW_Close_window(_winnum)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _Windows_Data(_winnum,1)=1
      Rem Sauvegarde des coordonnées de la fenêtre.
      _Windows_Default(_winnum,1)=_Windows_Data(_winnum,2)
      _Windows_Default(_winnum,2)=_Windows_Data(_winnum,3)
      for bcl=1 to 32
        _Windows_Data(_winnum,bcl)=0
        For sbcl=1 to 8
          _Windows_Gadget(_winnum,bcl,sbcl)=0
         Next sbcl
        _Windows_Gadget_Text$(_winnum,bcl)=""
       next bcl
      _windows_Title$(_winnum)="" : _windows_Font$(_winnum)=""
      Rem Si la fenêtre supprimée n'est pas la dernière affichée , on la supprime de la liste.
      _howmany=_Windows_Sys(4) : _count=0
      Repeat
        inc _count,1
       until _Windows_Order(_count)=_winnum
      if _count<_howmany
        for boucle=_count to _howmany-1
          _Windows_Order(boucle)=_Windows_Order(boucle+1)
         next boucle
       endif
      dec _howmany,1 : _Windows_Sys(4)=_howmany
      _displaymode=_Windows_sys(22) : Rem check if displaymode is PASTE or SPRITE mode . . .
      if _displaymode=1
        _sprt=65536-_winnum
        if sprite exist(_sprt)=1 then delete sprite _sprt
       endif
      delete bitmap 32-_winnum
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction _ERROR
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Resize_Window(_Window,NewXSize,NewYSize)                                 Redimensionne une fenêtre existante.
Function MW_Resize_Window(_Winnum,NewXSize,NewYSize)
  _ERROR=0
  DBPro_Flag=_Windows_Sys(31)
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      Rem Tout d'abord , on essaye de trouver une image libre pour stoquer le contenu de la fenêtre.
      _Windows_Data(_winnum,0)=1
      _img=65536
      Repeat
        dec _img
       until image exist(_img)=0
      Rem On saisit le contenu de la fenêtre.
      xsize=_Windows_Data(_Winnum,4) : ysize=_Windows_Data(_Winnum,5)
      set current bitmap 32-_winnum
      if newxsize<64 then newxsize=64
      if newysize<12 then newysize=12
      if newxsize<>xsize or newysize<>ysize
        if xsize>newxsize then xsize=newxsize
        if ysize>newysize then ysize=newysize
        if _Windows_Data(_winnum,7)=0
          get image _img,2,12,2+xsize,ysize+12,DBPro_Flag
         else
          get image _img,2,12,xsize-8,ysize+12,DBPro_Flag
         endif
        delete bitmap 32-_winnum
        _Windows_Data(_Winnum,4)=NewXSize : _Windows_Data(_Winnum,5)=NewYSize
        Create Bitmap 32-_winnum,newxsize+4,newysize+14
        if newxsize<256 then newxsize=256
        if newysize<128 then newysize=128 : Rem Si la fenêtre est très petite , prévoit un bitmap + grand .
        Set Current Bitmap 32-_winnum
        MW_Retrace_Window(_Winnum)
        Paste Image _img,2,12
        _Windows_Data(_winnum,0)=1
        delete image _img
       endif
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction _ERROR
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_window_bgd(_Window,_red,_green,_blue)                    Définit la couleur du fond de la fenêtre par défaut.
Function MW_window_bgd(_winnum,_red,_green,_blue)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      _Windows_Data(_winnum,9)=_red
      _Windows_Data(_winnum,10)=_green
      _Windows_Data(_winnum,11)=_blue
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 Endfunction _ERROR
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Window_Borders(_Window,_red1,_green1,_blue1,_red2,_green2,_blue2)         Définit les couleurs des bordures.
Function MW_Window_Borders(_Winnum,_red1,_green1,_blue1,_red2,_green2,_blue2)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      _Windows_Data(_winnum,18)=_red1 : _Windows_Data(_winnum,19)=_green1
      _Windows_Data(_winnum,20)=_blue1 : _Windows_Data(_winnum,21)=_red2
      _Windows_Data(_winnum,22)=_green2 : _Windows_Data(_winnum,23)=_blue2
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction _ERROR
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Window_To_Front(_window)                                              Met la fenêtre choisie au premier plan.
Function MW_Window_To_Front(_winnum)
  _ERROR=0
  if _winnum>0 and _winnum<25 and _Windows_Sys(4)>1
    if _windows_Data(_winnum,1)=1
      Rem On cherche la fenêtre à déplacer dans la liste et on les décales à partir de celle la.
      _howmany=_Windows_Sys(4) : _count=0
      Repeat
        inc _count,1
       until _Windows_Order(_count)=_winnum
      if _count<_howmany
        for boucle=_count to _howmany-1 step 1
          _Windows_Order(boucle)=_Windows_Order(boucle+1)
         next boucle
        _Windows_Order(_howmany)=_winnum
       endif
      _displaymode=_Windows_sys(22) : Rem check if displaymode is PASTE or SPRITE mode . . .
      if _displaymode=1
        For boucle=1 to 16
          _sprt=65536-boucle
          if sprite exist(_sprt)=1 then delete sprite _sprt
         next boucle
       endif
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction _ERROR
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Window_To_Back(_window)                                               Met la fenêtre choisie au dernier plan.
Function MW_Window_To_Back(_winnum)
  _ERROR=0
  if _winnum>0 and _winnum<25 and _Windows_Sys(4)>1
    if _windows_Data(_winnum,1)=1
      Rem On cherche la fenêtre à déplacer dans la liste et on les décales à partir de celle la.
      _howmany=_Windows_Sys(4) : _count=0
      Repeat
        inc _count,1
       until _Windows_Order(_count)=_winnum
      if _count>1
        for boucle=_count-1 to 1 step -1
          _Windows_Order(boucle+1)=_Windows_Order(boucle)
         next boucle
        _Windows_Order(1)=_winnum
       endif
      _displaymode=_Windows_sys(22) : Rem check if displaymode is PASTE or SPRITE mode . . .
      if _displaymode=1
        For boucle=1 to 16
          _sprt=65536-boucle
          if sprite exist(_sprt)=1 then delete sprite _sprt
         next boucle
       endif
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction _ERROR
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Screen_Title_On() [NEW]                                       Active l'affichage du titre en haut de l'écran.
Function MW_Screen_Title_On()
  _Windows_sys(25)=1
 EndFunction
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Screen_Title_Off() [NEW]                                   Désactive l'affichage du titre en haut de l'écran.
Function MW_Screen_Title_Off()
  _Windows_sys(25)=0
 EndFunction
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Set_Screen_Title(_title$) [NEW]                          Permet de définir le titre de l'écran Magic-Windows.
Function MW_Set_Screen_Title(_titre$)
  _Windows_title$(0)=_titre$
 EndFunction
Rem -------------------------------------------------------------------------------------- MW WINDOWS --------------
Rem MW_Set_Window_Alpha(_window,_alpha) [NEW]     Utilise la transparence si la fenêtre est affichée en mode sprite.
Function MW_Set_Window_Alpha(_winnum,_alfa)
  if _winnum>0 and _winnum<25
    if _Windows_Data(_winnum,1)=1
      if _alfa<1 then _alfa=1
      if _alfa>255 then _alfa=255
      _Windows_Data(_winnum,26)=_alfa
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem
Rem
Rem
Rem ------------------------------------------------------------------------------------ MW 2D FUNCTIONS -----------
Rem MW_Cls(_Window,_red,_green,_blue)                                   Vide la fenêtre avec une couleur spécifique.
Function MW_Cls(_winnum,_red,_green,_blue)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _Windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      set current bitmap 32-_winnum
      xsize=_Windows_Data(_winnum,4) : ysize=_Windows_Data(_winnum,5)
      _img=_Windows_sys(1)
      ink rgb(_red,_green,_blue),0
      box 2,12,xsize+1,ysize+11
      if _Windows_Data(_winnum,7)=1 then paste image _img+4,xsize-8,ysize+2,1
      _Windows_Data(_winnum,0)=1
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ------------------------------------------------------------------------------------ MW 2D FUNCTIONS -----------
Rem MW_Ink(_Window,red,green,blue)                             Définit la couleur d'écriture du texte de la fenêtre.
Function MW_ink(_winnum,_red,_green,_blue)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      _Windows_Data(_winnum,14)=_red
      _Windows_Data(_winnum,15)=_green
      _Windows_Data(_winnum,16)=_blue
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 Endfunction _ERROR
Rem ------------------------------------------------------------------------------------ MW 2D FUNCTIONS -----------
Rem MW_Box(_Window,x1,y1,x2,y2)                                                          Draw a box inside a window.
Function MW_Box(_winnum,x1,y1,x2,y2)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      xsize=_Windows_Data(_winnum,04) : ysize=_Windows_Data(_winnum,05)
      if x1<0 or x2<0 or y1<0 or y2<0 then _ERROR=-6
      if x1>xsize or x2>xsize or y1>ysize or y2>ysize then _ERROR=-6
      Rem vérifie si les coordonnées
      if x1>x2 then x3=x1 : x1=x2 : x2=x3
      if y1>y2 then y3=y1 : y1=y2 : y2=y3
      if _ERROR=0
        _red=_Windows_Data(_winnum,14) : _green=_Windows_Data(_winnum,15) : _blue=_Windows_Data(_winnum,16)
        set current bitmap 32-_winnum
        ink rgb(_red,_green,_blue),0
        box x1+2,y1+12,x2+2,y2+12
       EndIf
      _Windows_Data(_winnum,0)=1
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 Endfunction _ERROR
Rem ------------------------------------------------------------------------------------ MW 2D FUNCTIONS -----------
Rem MW_Empty_Box(_Window,x1,y1,x2,y2)                                                          Draw a box inside a window.
Function MW_Empty_Box(_winnum,x1,y1,x2,y2)
      _Windows_Data(_winnum,0)=1
      xsize=_Windows_Data(_winnum,04) : ysize=_Windows_Data(_winnum,05)
      _red=_Windows_Data(_winnum,14) : _green=_Windows_Data(_winnum,15) : _blue=_Windows_Data(_winnum,16)
      _Windows_Data(_winnum,0)=1
      set current bitmap 32-_winnum
      ink rgb(_red,_green,_blue),0
      Line x1+2,y1+12,x1+2,y2+12
      Line x1+2,y2+12,x2+2,y2+12
      Line x2+2,y1+12,x2+2,y2+12
      Line x1+2,y1+12,x2+2,y1+12
 Endfunction
Rem ------------------------------------------------------------------------------------ MW 2D FUNCTIONS -----------
Rem MW_Line(_Window,x1,y1,x2,y2)                                                        Draw a line inside a window.
Function MW_line(winnum,x1,y1,x2,y2)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      xsize=_Windows_Data(_winnum,04) : ysize=_Windows_Data(_winnum,05)
      if x1<0 or x2<0 or y1<0 or y2<0 then _ERROR=-6
      if x1>xsize or x2>xsize or y1>ysize or y2>ysize then _ERROR=-6
      Rem vérifie si les coordonnées
      if x1>x2 then x3=x1 : x1=x2 : x2=x3
      if y1>y2 then y3=y1 : y1=y2 : y2=y3
      if _ERROR=0
        _red=_Windows_Data(_winnum,14) : _green=_Windows_Data(_winnum,15) : _blue=_Windows_Data(_winnum,16)
        set current bitmap 32-_winnum
        ink rgb(_red,_green,_blue),0
        line x1+2,y1+12,x2+2,y2+12
       EndIf
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 Endfunction _ERROR
Rem ------------------------------------------------------------------------------------ MW 2D FUNCTIONS -----------
Rem MW_Dot(_Window,x,y)                                                               Draw a single point on window.
Function MW_Dot(winnum,x,y)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      xsize=_Windows_Data(_winnum,04) : ysize=_Windows_Data(_winnum,05)
      if x<0 or y<0 then _ERROR=-6
      if x>xsize or y>ysize then _ERROR=-6
      if _ERROR=0
        _red=_Windows_Data(_winnum,14) : _green=_Windows_Data(_winnum,15) : _blue=_Windows_Data(_winnum,16)
        set current bitmap 32-_winnum
        ink rgb(_red,_green,_blue),0
        dot x+2,y+12
       EndIf
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 Endfunction _ERROR
Rem ------------------------------------------------------------------------------- MW 2D GRAPHICS FUNCTIONS -------
Rem MW_Get_Image(_Window,_Image,Xpos,Ypos,Xpos2,Ypos2)                               Crée une image saisie dans la fenêtre.
Function MW_Get_Image(_winnum,_Img,xp1,yp1,xp2,yp2)
  _ERROR=0
  DBPro_Flag=_Windows_Sys(31)
  if _winnum>0 and _winnum<25
    if _Windows_Data(_winnum,1)=1
      xsize=_Windows_Data(_winnum,04) : ysize=_Windows_Data(_winnum,05)
      if xp2<xsize and xp2>xp1
        if yp2<ysize and yp2>yp1
          if xp1>0-1 and yp1>0-1
            Set Current Bitmap 32-_winnum
            if image exist(_img)=1 then delete image _img
            get image _img,xp1+2,yp1+12,xp2+2,yp2+12,DBPro_Flag
           Else
            _ERROR=-6
           Endif
          _ERROR=-6
         Endif
        _ERROR=-6
       Endif
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ------------------------------------------------------------------------------- MW 2D GRAPHICS FUNCTIONS -------
Rem MW_Paste_Image(_Window,_Image,Xpos,Ypos)                                     Affiche une image dans une fenêtre.
Function MW_Paste_Image(_winnum,_Img,xp1,yp1)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _Windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      xsize=_Windows_Data(_winnum,4) : ysize=_Windows_Data(_winnum,5)
      if xp1>0-1 and yp1>0-1
        if xp1<xsize and yp1<ysize
          Set Current Bitmap 32-_winnum
          if image exist(_Img)=1 then paste image _Img,xp1+2,yp1+12,_flag
         Else
          _ERROR=-6
         Endif
       Else
        _ERROR=-6
       Endif
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ------------------------------------------------------------------------------- MW 2D GRAPHICS FUNCTIONS -------
Rem MW_Copy_Bitmap2Window(_Bitmap,X,Y,X2,Y2,_Window,X3,Y3,X4,Y4)      Copie une partie d'un bitmap dans une fenêtre.
Function MW_Copy_Bitmap2Window(_bmpnum,x1,y1,x2,y2,_winnum,x3,y3,x4,y4)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _Windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      if bitmap exist(_bmpnum)=1
        copy bitmap _bmpnum,x1,y1,x2,y2,32-_winnum,x3+2,y3+12,x4+2,y4+12
       else
        _ERROR=-7
       EndIf
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ------------------------------------------------------------------------------- MW 2D GRAPHICS FUNCTIONS -------
Rem MW_Copy_Window2Bitmap(_Window,X,Y,X2,Y2,_Bitmap,X3,Y3,X4,Y4)      Copie une partie d'une fenêtre dans un bitmap.
Function MW_Copy_Window2Bitmap(_winnum,x1,y1,x2,y2,_bmpnum,x3,y3,x4,y4)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _Windows_Data(_winnum,1)=1
      if bitmap exist(_bmpnum)=1
        copy bitmap 32-_winnum,x1+2,y1+12,x2+2,y2+12,_bmpnum,x3,y3,x4,y4
       else
        _ERROR=-7
       EndIf
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ------------------------------------------------------------------------------- MW 2D GRAPHICS FUNCTIONS -------
Rem MW_Copy_Window2Window(_Window,X,Y,X2,Y2,_Window,X3,Y2,X4,Y4)      Copie une partie d'une fenêtre dans une autre.
Function MW_Copy_Window2Window(_winnum,x1,y1,x2,y2,_winnum2,x3,y3,x4,y4)
  _ERROR=0
  if _winnum>0 and _winnum<25
      _Windows_Data(_winnum2,0)=1
    if _Windows_Data(_winnum,1)=1 and _Windows_Data(_winnum2,1)=1
      copy bitmap 32-_winnum,x1+2,y1+12,x2+2,y2+12,32-_winnum2,x3+2,y3+12,x4+2,y4+12
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_print(_Window,_text$)                                                 Ecrit un texte dans la fenêtre choisie.
Function MW_print(_winnum,_text$)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      ysize=_Windows_Data(_winnum,5) : xsize=_Windows_Data(_winnum,4)
      xcurs=_Windows_Data(_winnum,12) : ycurs=_Windows_Data(_winnum,13)
      _red=_Windows_Data(_winnum,14) : _green=_Windows_Data(_winnum,15) : _blue=_Windows_Data(_winnum,16)
      _red2=_Windows_Data(_winnum,09) : _green2=_Windows_Data(_winnum,10) : _blue2=_Windows_Data(_winnum,11)
      yfont=_Windows_Data(_winnum,17) : ymax=ysize-yfont : ylines=ysize/yfont
      set current bitmap 32-_winnum
      if ycurs>ymax+1
        repeat
          ycurs=ycurs-yfont
         until ycurs<ylines*yfont
        if ycurs<0 then ycurs=0
        if ysize>12 then copy bitmap 32-_winnum,2,12+yfont,xsize-10,11+ysize,32-_winnum,2,12,xsize-10,(11+ysize)-yfont
        ink rgb(_Windows_Data(_winnum,09),_Windows_Data(_winnum,10),_Windows_Data(_winnum,11)),0
        box 2,12+ycurs,xsize-10,11+ycurs+yfont
       endif
      ink rgb(_red,_green,_blue),rgb(_red2,_green2,_blue2)
      if _Windows_Font$(0)<>_Windows_Font$(_winnum) then MW_Set_Text_Font_Sys(_Windows_Font$(_winnum))
      MW_Set_Text_Size_Sys(_Windows_Data(_winnum,17))
      _Windows_Font$(0)=_Windows_Font$(_winnum) : _Windows_Sys(26)=_Windows_Data(_Winnum,17)
      if _Windows_Data(_Winnum,28)=0 then MW_Set_Text_Opaque_Sys() else MW_Set_Text_Transparent_Sys()
      _typ=_Windows_Data(_Winnum,27) : if _typ=0 then MW_Set_Text_Normal_Sys()
      if _typ=1 then MW_Set_Text_Italic_Sys()
      if _typ=2 then MW_Set_Text_Bold_Sys()
      if _Typ=3 then MW_Set_Text_BoldItalic_Sys()
      text xcurs+2,ycurs+12,_text$
      ycurs=ycurs+yfont
      _Windows_Data(_winnum,13)=ycurs
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 Endfunction _ERROR
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_MPrint(_Window,_text$) [NEW]                   Ecrit un texte dans la fenêtre choisie sans retour à la ligne.
Function MW_MPrint(_winnum,_text$)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      ysize=_Windows_Data(_winnum,5) : xsize=_Windows_Data(_winnum,4)
      xcurs=_Windows_Data(_winnum,12) : ycurs=_Windows_Data(_winnum,13)
      _red=_Windows_Data(_winnum,14) : _green=_Windows_Data(_winnum,15) : _blue=_Windows_Data(_winnum,16)
      _red2=_Windows_Data(_winnum,09) : _green2=_Windows_Data(_winnum,10) : _blue2=_Windows_Data(_winnum,11)
      yfont=_Windows_Data(_winnum,17) : ymax=ysize-yfont : ylines=ysize/yfont
      set current bitmap 32-_winnum
      if ycurs>ymax+1
        repeat
          ycurs=ycurs-yfont
         until ycurs<ylines*yfont
        if ycurs<0 then ycurs=0
        if ysize>12 then copy bitmap 32-_winnum,2,12+yfont,xsize-10,11+ysize,32-_winnum,2,12,xsize-10,(11+ysize)-yfont
        ink rgb(_Windows_Data(_winnum,09),_Windows_Data(_winnum,10),_Windows_Data(_winnum,11)),0
        box 2,12+ycurs,xsize-10,11+ycurs+yfont
       endif
      if _Windows_Font$(0)<>_Windows_Font$(_winnum) then MW_Set_Text_Font_Sys(_Windows_Font$(_winnum))
      MW_Set_Text_Size_Sys(_Windows_Data(_winnum,17))
      _Windows_Font$(0)=_Windows_Font$(_winnum) : _Windows_Sys(26)=_Windows_Data(_Winnum,17)
      if _Windows_Data(_Winnum,28)=0 then MW_Set_Text_Opaque_Sys() else MW_Set_Text_Transparent_Sys()
      _typ=_Windows_Data(_Winnum,27) : if _typ=0 then MW_Set_Text_Normal_Sys()
      if _typ=1 then MW_Set_Text_Italic_Sys()
      if _typ=2 then MW_Set_Text_Bold_Sys()
      if _Typ=3 then MW_Set_Text_BoldItalic_Sys()
      ink rgb(_red2,_green2,_blue2),0
      box xcurs+2,ycurs+12,xcurs+2+(len(_text$)*yfont),ycurs+12+yfont
      ink rgb(_red,_green,_blue),0
      text xcurs+2,ycurs+12,_text$
      _Windows_Data(_winnum,13)=ycurs
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 Endfunction _ERROR
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Text(_Window,xpos,ypos,_text$)                     Ecrit un texte en le centrant par rapport aux coordonnées.
Function MW_Text(_winnum,xpos,ypos,_text$)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      ysize=_Windows_Data(_winnum,5) : xsize=_Windows_Data(_winnum,4)
      _red2=_Windows_Data(_winnum,09) : _green2=_Windows_Data(_winnum,10) : _blue2=_Windows_Data(_winnum,11)
      _red=_Windows_Data(_winnum,14) : _green=_Windows_Data(_winnum,15) : _blue=_Windows_Data(_winnum,16)
      yfont=_Windows_Data(_winnum,17) : ymax=ysize-yfont : ylines=ysize/yfont
      if ypos>(ysize-yfont) then ypos=ysize-yfont
      if ypos<0 then ypos=0
      if xpos>xsize then xpos=xsize
      if xpos<0 then xpos=0
      set current bitmap 32-_winnum
      if _Windows_Font$(0)<>_Windows_Font$(_winnum) then MW_Set_Text_Font_Sys(_Windows_Font$(_winnum))
      MW_Set_text_size_Sys(_Windows_Data(_winnum,17))
      _Windows_Font$(0)=_Windows_Font$(_winnum) : _Windows_Sys(26)=_Windows_Data(_Winnum,17)
      if _Windows_Data(_Winnum,28)=0 then MW_Set_Text_Opaque_Sys() else MW_Set_Text_Transparent_Sys()
      _typ=_Windows_Data(_Winnum,27) : if _typ=0 then MW_Set_Text_Normal_Sys()
      if _typ=1 then MW_Set_Text_Italic_Sys()
      if _typ=2 then MW_Set_Text_Bold_Sys()
      if _Typ=3 then MW_Set_Text_BoldItalic_Sys()
      ink rgb(_red,_green,_blue),rgb(_red2,_green2,_blue2)
      Center Text xpos+2,ypos+12,_text$
     _Windows_Data(_winnum,13)=ycurs
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 Endfunction _ERROR
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Cursor(_Window,Xcurs,Ycurs)                       Redéfinit la position du curseur texte dans la fenêtre.
Function MW_Set_Cursor(_winnum,xcurs,ycurs)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      xsize=_Windows_Data(_winnum,4) : ysize=_Windows_Data(_winnum,5)
      _fontsize=_Windows_Data(_winnum,17)
      if xcurs>xsize-_fontsize
        xcurs=0 : ycurs=ycurs+_fontsize
       endif
      if ycurs>ysize-_fontsize then ycurs=ysize-_fontsize
      _Windows_Data(_winnum,12)=xcurs : _Windows_Data(_winnum,13)=ycurs
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 Endfunction _ERROR
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Font_Size(_Window,_FontSize)                     Redéfinit la dimension des textes de la fenêtre choisie.
Function MW_Set_Font_Size(_Winnum,_FontSize)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      if _FontSize>4 and _FontSize<100 then _Windows_Data(_winnum,17)=_FontSize
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction _ERROR
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Font_Name(_Window,_fonte$)                 Définit quel type d'écriture utiliser dans la fanêtre choisie.
Function MW_Set_Font_Name(_winnum,_font$)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      if _font$<>"" then _Windows_Font$(_winnum)=_font$
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction _ERROR
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem =MW_Input(_window,_texte$) [NEW]                                            équivalent d'un style INPUT de 3DGC.
Function MW_Input(_winnum,_texte$)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_winnum,1)=1
      xcurs=_Windows_Data(_winnum,12) : ycurs=_Windows_Data(_winnum,13) : yfont=_Windows_Data(_winnum,17)
      _red=_Windows_Data(_winnum,14) : _green=_Windows_Data(_winnum,15) : _blue=_Windows_Data(_winnum,16)
      _redb=_Windows_Data(_winnum,09) : _greenb=_Windows_Data(_winnum,10) : _blueb=_Windows_Data(_winnum,11)
      _style=_Windows_Data(_winnum,27)
      MW_Set_Text_Opaque(_winnum)
      Repeat
        MW_Background_Task()
        d$=inkey$()
        if d$<>""
          repeat
            _Windows_Data(_winnum,0)=1
            MW_Sync(0) : sync : MW_Background_Task()
           until inkey$()=""
          if _text<32 and asc(d$)<>13 and asc(d$)<>8
            inc _text,1
            _Windows_Text$(_text)=d$
           endif
          if asc(d$)=8 and _text>0 then dec _text,1
         endif
        map$=""
        if _text>0
          for boucle=1 to _text
            map$=map$+_Windows_Text$(boucle)
           next boucle
         endif
        MW_Ink(_winnum,_red,_green,_blue)
        MW_MPrint(_winnum,_texte$+map$+"_    ")
        MW_Sync(0)
        sync
        xlen=(len(_texte$+map$)*yfont/2)
        _Windows_Data(_winnum,13)=ycurs
       Until asc(d$)=13 or MW_Window_Exist(_winnum)=0
      ycurs=ycurs+yfont
      _Windows_Data(_winnum,13)=ycurs
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
  if _style=1 then MW_Set_Text_Transparent(_winnum)
 EndFunction map$
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_Normal(_Window) [NEW]                                            Define text as default DBv1 values.
Function MW_Set_Text_Normal(_Winnum)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_Winnum,1)=1
      _Windows_Data(_Winnum,28)=0
      _Windows_Data(_Winnum,27)=0
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_Opaque(_window) [NEW]                                                    Define text as opaque text.
Function MW_Set_Text_Opaque(_Winnum)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_Winnum,1)=1
      _Windows_Data(_Winnum,28)=0
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_Transparent(_Window) [NEW]                                          Define text as transparent text.
Function MW_Set_Text_Transparent(_Winnum)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_Winnum,1)=1
      _Windows_Data(_Winnum,28)=1
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_To_Italic(_Window) [NEW]                                                 Use Italic for text output.
Function MW_Set_Text_To_Italic(_Winnum)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_Winnum,1)=1
      _Windows_Data(_Winnum,27)=1
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_To_Bold(_Window) [NEW]                                                     Use bold for text output.
Function MW_Set_Text_To_Bold(_Winnum)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_Winnum,1)=1
      _Windows_Data(_Winnum,27)=2
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_To_BoldItalic(_Window) [NEW]                                    Use bold and italic for text output.
Function MW_Set_Text_To_BoldItalic(_Winnum)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _windows_Data(_Winnum,1)=1
      _Windows_Data(_Winnum,27)=3
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_Normal_Sys() [SYSTEM] [NEW]                           Check mode and active it if needed (speed up).
Function MW_Set_Text_Normal_Sys()
  if _Windows_sys(27)>0
    Set Text to Normal : _Windows_sys(27)=0
   Endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_Italic_Sys() [SYSTEM] [NEW]                           Check mode and active it if needed (speed up).
Function MW_Set_Text_Italic_Sys()
  if _Windows_sys(27)<>1
    Set Text to Italic : _Windows_sys(27)=1
   Endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_Bold_Sys() [SYSTEM] [NEW]                             Check mode and active it if needed (speed up).
Function MW_Set_Text_Bold_Sys()
  if _Windows_sys(27)<>2
    Set Text to Bold : _Windows_sys(27)=2
   Endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_BoldItalic_Sys() [SYSTEM] [NEW]                       Check mode and active it if needed (speed up).
Function MW_Set_Text_BoldItalic_Sys()
  if _Windows_sys(27)<>3
    Set Text to BoldItalic : _Windows_sys(27)=3
   Endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_Size_Sys() [SYSTEM] [NEW]                             Check mode and active it if needed (speed up).
Function MW_Set_Text_Size_Sys(_Size)
  if _Windows_sys(26)<>_Size
    Set Text Size _Size : _Windows_sys(26)=_Size
   Endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_Opaque_Sys() [SYSTEM] [NEW]                           Check mode and active it if needed (speed up).
Function MW_Set_Text_Opaque_Sys()
  if _Windows_Sys(28)=0
    Set Text Opaque : _Windows_Sys(28)=1
   Endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW TEXT FUNCTIONS ----------
Rem MW_Set_Text_Transparent_Sys() [SYSTEM] [NEW]                      Check mode and active it if needed (speed up).
Function MW_Set_Text_Transparent_Sys()
  if _Windows_Sys(28)=1
    Set Text Transparent : _Windows_Sys(28)=0
   Endif
 EndFunction

Function MW_Set_Text_Font_Sys(_font$)
  if _Windows_Font$(0)<>_font$
    _Windows_Font$(0)=_font$
    Set text font _font$
   endif
 EndFunction
Rem
Rem
Rem
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Initialize_Tiles(_firstimage)             Charge les images qui serviront à la partie graphique des fenêtres.
Function MW_Initialize_Tiles(_firstimage)
  _ERROR=0 : _INIT=1
  _Windows_Sys(1)=_firstimage
  _Windows_Title$(0)="Magic-Windows Ver1.2"
  DBPro_Flag=_Windows_Sys(31)
  if file exist("tiles\tiles.asc")=1
    open to read 1,"tiles\tiles.asc"
      Repeat
        read string 1,_ImageName$
        if file exist("tiles\"+_ImageName$)=1 then load image "tiles\"+_ImageName$,_firstimage,DBPro_Flag else _INIT=0
        inc _firstimage,1
       until _ImageName$="[ENDTILES]"
     close file 1
    Rem Prepare background for title.
    create bitmap 1,bitmap width(0),bitmap height(0)
    Set Current Bitmap 1
    For boucle=0 to bitmap width(0) step 12
      Paste Image _Windows_Sys(1)+1,boucle,0
     next boucle
    Paste Image _Windows_sys(1),0,0
    Paste Image _windows_sys(1)+2,bitmap width(0)-12,0
    Get Image _FirstImage,0,0,bitmap width(1)-1,12
    Delete Bitmap 1 : Inc _FirstImage,1
    _Windows_Sys(2)=_firstimage
   else
    _ERROR=-5 : _INIT=0
   endif
  _Windows_Sys(11)=1 : _Windows_Sys(12)=1 : _Windows_Sys(13)=1 : Rem Real-Time Activeds.
  _Windows_Sys(14)=_INIT : Rem initialisé correctement ?
  _Windows_Sys(15)=1 : Rem Défaut Auto-refresh pour gadgets actif.
  if _Windows_Sys(30)=1 then MW_Load_Default_Positions()
 EndFunction _ERROR
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Release_All()                                     Libère la mémoire utilisée par les graphiques des fenêtres.
Function MW_Release_All()
  Rem On ferme toutes les fenêter qui existent encore . . .
  For boucle=1 to 16
    if _Windows_Data(boucle,1)=1 then MW_Close_Window(boucle)
   next boucle
  if _Windows_Sys(30)=1 then MW_Save_Default_Positions()
  _displaymode=_windows_sys(22)
  if _displaymode=1
    For boucle=1 to 16
      _sprt=65536-boucle
      if sprite exist(_sprt)=1 then delete sprite _sprt
     next boucle
   endif
  Rem On libèrer tout les graphismes utilisés.
  img1=_Windows_sys(1) :  img2=_Windows_sys(2)
  if img1>0 and img2>img1
    for boucle=img1 to img2
      if image exist(boucle)=1 then delete image boucle
     next boucle
   endif
  _Windows_Sys(14)=0
 Endfunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Sync()                                     Réactualise toutes les fenêtres dans l'écran visible ( Bitmap 0 ).
Function MW_Sync(_bmptarget)
  if _Windows_Sys(23)=1
    MW_Background_Task()
   Endif
  _DBPro_Flag=_Windows_Sys(31) : _img=_Windows_sys(1)
  Rem Refresh Magic-Windows Screen Title if active !
  if _Windows_sys(25)=1 and _Menu_Sys(2)=0
    Set Current Bitmap _bmptarget
    if image exist(_Windows_Sys(2)-1)=1 then Paste Image _Windows_Sys(2)-1,0,0
    MW_Set_Text_Font_Sys("times new roman")
    MW_Set_Text_Size_Sys(12)
    MW_Set_Text_Transparent_Sys()
    Ink 0,0 : Text 3,1,_Windows_Title$(0)
    Ink rgb(255,255,255),0 : Text 2,0,_Windows_Title$(0)
   Endif
  _ERROR=0
  _displaymode=_Windows_sys(22) : Rem check if displaymode is PASTE or SPRITE mode . . .
  set current bitmap _bmptarget
  xbmpsize=bitmap width(_bmptarget) : ybmpsize=bitmap height(_bmptarget)
  if _Windows_Sys(21)=1 Then Get Image 65535,0,0,xbmpsize,ybmpsize,_DBPro_Flag
  For boucle=1 to 16
    mw_boucle=_Windows_Order(boucle)
    if _windows_data(mw_boucle,1)=1
      set current bitmap 32-mw_boucle
    Rem On retrace les bandes verticales de la fenêtre si le mode rafraichissement est activé.
      if _Windows_Sys(3)=1
        _winnum=mw_boucle
        set current bitmap 32-_winnum
        xsize=_Windows_Data(_winnum,4) : ysize=_Windows_Data(_winnum,5)
        _img=_Windows_sys(1)
        Rem On Retrace les bords de la fenêtre.
        _red1=_Windows_Data(_winnum,18) : _green1=_Windows_Data(_winnum,19) : _blue1=_Windows_Data(_winnum,20)
        _red2=_Windows_Data(_winnum,21) : _green2=_Windows_Data(_winnum,22) : _blue2=_Windows_Data(_winnum,23)
        ink rgb(_red1,_green1,_blue1),0 : line xsize+2,ysize+12,xsize+2,0
        ink rgb(_red2,_green2,_blue2),0 : line xsize+3,ysize+13,xsize+3,1
        Rem On affiche les gadgets demandés. RESIZE / BACK
        if _Windows_Data(_winnum,7)=1 then paste image _img+4,xsize-8,ysize+2,1
        if _Windows_Data(_winnum,8)=1 then paste image _img+5,xsize-8,0,1 else paste image _Img+2,xsize-8,0,1
       Endif
      Rem Re-actualisation des Gadgets si il en existe.
      if _Windows_Sys(15)=1
        For _gdg=1 to 32
          if _Windows_Gadget(_winnum,_gdg,1)>0 then MW_Refresh_Gadget(_winnum,_gdg)
         Next _gdg
       Endif
      Rem Copie de la fenêtre dans le bitmap choisi.
      _winbmp=32-mw_boucle
      xpos=_Windows_Data(mw_boucle,2) : ypos=_Windows_Data(mw_boucle,3)
      xsize=_Windows_Data(mw_boucle,4)+4 : ysize=_Windows_Data(mw_boucle,5)+14
      if xpos<0 then xpos=0
      if ypos<0 then ypos=0
      if _Windows_Sys(33)=1
        xsize=xsize-4 : ysize=ysize-14
       endif
      if xsize>xbmpsize then xsize=xbmpsize
      if ysize>ybmpsize then ysize=ybmpsize
      if xpos+xsize>xbmpsize
        xpos=xbmpsize-xsize
        _Windows_Data(mw_boucle,2)=xpos
       endif
      if ypos+ysize>ybmpsize
        ypos=ybmpsize-ysize
        _Windows_Data(mw_boucle,3)=ypos
       endif
     endif
   next boucle
  if _displaymode=0
    For mw_boucle=1 to 16
      boucle=_Windows_Order(mw_boucle)
      xpos=_Windows_Data(boucle,2) : ypos=_Windows_Data(boucle,3)
      xsize=_Windows_Data(boucle,4)+4 : ysize=_Windows_Data(boucle,5)+14
      if _Windows_Data(boucle,1)=1
        if _Windows_Sys(33)=0
          copy bitmap 32-boucle,0,0,xsize+_DBPro_Flag-1,ysize+_DBPro_Flag-1,_bmptarget,xpos,ypos,xpos+xsize+_DBPro_Flag-1,ypos+ysize+_DBPro_Flag-1
         else
          copy bitmap 32-boucle,2,12,xsize+_DBPro_Flag-3,ysize+_DBPro_Flag-3,_bmptarget,xpos,ypos,xpos+xsize+_DBPro_Flag-5,ypos+ysize+_DBPro_Flag-15
         endif
       Endif
     next mw_boucle
   else
    For boucle=1 to 16
      if _Windows_Data(boucle,0)=1 and _Windows_Data(boucle,1)=1
        set current bitmap 32-boucle
        _sprt=65536-boucle
        xpos=_Windows_Data(boucle,2) : ypos=_Windows_Data(boucle,3)
        xsize=_Windows_Data(boucle,4)+4 : ysize=_Windows_Data(boucle,5)+14
        if _Windows_Sys(33)=0
          get image _sprt,0,0,xsize,ysize,_DBPro_Flag
         else
          get image _sprt,2,12,xsize-2,ysize-2,_DBPro_Flag
         endif
       endif
     next boucle
    Set current bitmap _bmptarget
    for boucle=1 to 16
      _sprt=65536-boucle
      xpos=_Windows_Data(boucle,2) : ypos=_Windows_Data(boucle,3)
      xsize=_Windows_Data(boucle,4)+4 : ysize=_Windows_Data(boucle,5)+14
      _alfa=_Windows_Data(boucle,26)
      if _Windows_Data(boucle,1)=1
        if sprite exist(_sprt)=0
          sprite _sprt,xpos,ypos,_sprt
          if _alfa>0 then set sprite alpha _sprt,_alfa
         else
          if _Windows_Data(boucle,0)>0 then sprite _sprt,xpos,ypos,_sprt
         endif
       endif
      _Windows_Data(boucle,0)=0
     Next boucle
    For boucle=1 to 16
      _win=_Windows_Order(boucle)
      if sprite exist(65536-_win)=1 then set sprite priority 65536-_win,boucle
     next boucle
   endif
  if _Windows_Sys(32)=0 then _ACTIF=MW_Check_Menu() else _ACTIF=0
  _CURSOR=_Windows_Sys(29)
  if _CURSOR>0
    if image exist(_CURSOR)=1 then sprite 1,mousex(),mousey(),_CURSOR
   endif
  if bitmap exist(0)=1 then set current bitmap 0
  _Windows_sys(23)=0
 EndFunction _ERROR
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Auto_Refresh_On()                             Active le rafraichissement de bords de fenêtres à chaque frame.
Function MW_Auto_Refresh_On()
  _Windows_Sys(3)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Auto_Refresh_Off()                        Désactive la fonctionalité ( peut permettre de gagner quelques FPS.
Function MW_Auto_Refresh_Off()
  _Windows_Sys(3)=0
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Retrace_Window(_Window)                                Retrace entièrement la fenêtre ( bordures , contenu ).
Function MW_Retrace_Window(_winnum)
  _ERROR=0
  if _Windows_Sys(21)=1 and Image Exist(65535)=1
    Paste Image 65535,0,0 : Delete image 65535
   Endif
  if _winnum>0 and _winnum<25
    if _Windows_Data(_winnum,1)=1
      _Windows_Data(_winnum,0)=1
      set current bitmap 32-_winnum
      xsize=_Windows_Data(_winnum,4) : ysize=_Windows_Data(_winnum,5)
      _img=_Windows_sys(1)
      Rem On trace le fond de l'image
      _red0=_Windows_Data(_winnum,9) : _green0=_Windows_Data(_winnum,10) : _blue0=_Windows_Data(_winnum,11)
      Cls Rgb(_red0,_green0,_blue0)
      Rem On Retrace les bords de la fenêtre.
      _red1=_Windows_Data(_winnum,18) : _green1=_Windows_Data(_winnum,19) : _blue1=_Windows_Data(_winnum,20)
      _red2=_Windows_Data(_winnum,21) : _green2=_Windows_Data(_winnum,22) : _blue2=_Windows_Data(_winnum,23)
      ink rgb(_red1,_green1,_blue1),0
      line 0,0,0,ysize+12 : line 0,ysize+12,xsize+2,ysize+12 : line xsize+2,ysize+12,xsize+2,0
      ink rgb(_red2,_green2,_blue2),0
      line 1,0,1,ysize+13 : line 1,ysize+13,xsize+3,ysize+13 : line xsize+3,ysize+13,xsize+3,1
      Rem On retrace maintenant les bandes horizontales de la fenêtre
      xcases=(xsize/12)
      for Xpos=0 to Xcases*12 step 12
        paste image _img+1,xpos,0,1
       next Xpos
      Rem On affiche les gadgets demandés. CLOSE / RESIZE / FRONT-BACK
      if _Windows_Data(_winnum,6)=1 then paste image _img+3,0,0,1 else paste image _Img,0,0,1
      if _Windows_Data(_winnum,7)=1 then paste image _img+4,xsize-8,ysize+2,1
      if _Windows_Data(_winnum,8)=1
        paste image _img+6,xsize-20,0,1 : paste image _img+5,xsize-8,0,1
       else
        paste image _Img+2,xsize-8,0,1
       Endif
      Rem Maintenant on affiche le titre de la fenêtre.
      ink rgb(255,255,255),0
      MW_Set_Text_Font_Sys(_Windows_Font$(_winnum))
      MW_Set_Text_Size_Sys(_Windows_Data(_winnum,17))
      MW_Set_Text_Transparent_Sys()
      ink rgb(16,16,16),0
      if _Windows_Data(_winnum,6)=1 then text 15,1,_Windows_Title$(_winnum) else text 3,1,_Windows_Title$(_winnum)
      ink rgb(255,255,255),0
      if _Windows_Data(_winnum,6)=1 then text 14,0,_Windows_Title$(_winnum) else text 2,0,_Windows_Title$(_winnum)
      Rem Maintenant , on vérifie si il existe des gadgets et on les rafraichit
      For boucle=1 to 16
        if _Windows_Gadget(_winnum,boucle,1)>0 then MW_Refresh_Gadget(_winnum,boucle)
       Next Boucle
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction _ERROR
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_BackGround_Task()                        Permet les déplacement , dimensionnement , fermetures en temps réel.
Function MW_Background_Task()
  if MW_Get_Menu_State()=0
    _Windows_sys(23)=1
    if _Windows_Sys(20)=1 then Cls
    _mc=mouseclick()
    xm=mousex() : ym=mousey()
  Rem Load Registers
    oldxm=_Windows_Sys(5) : oldym=_Windows_Sys(6)
    _gad=_Windows_Sys(7) : _win=_Windows_Sys(8)
    Rem Calcul des gadgets actifs.
    if _mc=1 and _win>0 and ( _gad>0 or _gad<0 )
      if _gad=-1 then MW_Close_Window(_win)
      if _gad=-2 and _Windows_Sys(11)=1
        xpos=MW_Window_XPosition(_win) : ypos=MW_Window_YPosition(_win)
        xdeca=xm-oldxm : ydeca=ym-oldym
        xsup=oldxm-xpos : ysup=oldym-ypos
        MW_Position_Window(_win,xpos+xdeca,ypos+ydeca)
        oldxm=xm : oldym=ym : _movement=1
       endif
      if _gad=-3 and _Windows_Sys(13)=1 then MW_Window_To_Front(_win)
      if _gad=-4 and _Windows_Sys(13)=1 then MW_Window_To_Back(_win)
      if _gad=-5 and _Windows_Sys(12)=1
        xpos=MW_Window_XPosition(_win) : ypos=MW_Window_YPosition(_win)
        if xm<xpos+128 then xm=xpos+128
        if ym<ypos+12 then ym=ypos+12
        if _Windows_sys(33)=0
          xsize=xm-(xpos+3) : ysize=ym-(ypos+13)
         else
          xsize=xm-(xpos-1) : ysize=ym-(ypos-1)
         endif
        MW_Resize_Window(_win,xsize,ysize)
        oldmxm=xm : oldmym=ym : _movement=1
       endif
     else
      oldxm=xm : oldym=ym : oldmxm=xm : oldmym=ym : _movement=0
     Endif
    _Windows_Sys(32)=_movement
    Rem On Vérifie Quel était le dernier gadget activé et on le redéssine tel qu'il était inactif.
    _winlight=_Windows_Sys(18) : _gadlight=_Windows_Sys(19)
    if _winlight>0 and _gadlight>0
      _gadtype=MW_Gadget_Type(_winlight,_gadlight)
      if _gadtype=2 then MW_Refresh_Text_Gadget(_winlight,_gadlight)
      if _gadtype=3 then MW_Refresh_Graphic_Gadget(_winlight,_gadlight)
     endif
    Rem On vérifie ici si le pointeur de la souris passe devand 1 des fenêtres.
    if _movement=0
      _newwin=MW_Window_Over()
      if _newwin<>_win and _newwin>0 then _win=_newwin
      if _newwin=0 and _win<>0 then _win=0
      if _win>0
        _newgad=MW_Window_Gadget(_win)
       else
        _newgad=0 : _gad=0
       endif
      if ( _newgad<0 or _newgad>0 ) and _newgad<>_gad then _gad=_newgad
      if _newgad=0 then _gad=0
     Endif
    Rem Si un nouveau gadget est actif , on le met en surbrillance.
    if _win>0 and _gad>0
      _gadtype=MW_Gadget_Type(_win,_gad)
      if _gadtype=2 then MW_Refresh_Text_Gadget_Light(_win,_gad)
      if _gadtype=3 then MW_Refresh_Graphic_Gadget_Light(_win,_gad)
     Endif
    _Windows_sys(18)=_win : _windows_sys(19)=_gad
    Rem On lit les positions de la souris dans la fenêtre en cours.
     if _newwin>0
        xpos=MW_Window_XPosition(_win) : ypos=MW_Window_YPosition(_win)
        xwin=oldxm-(xpos+2) : ywin=oldym-(ypos+12)
      endif
     Rem Save Registers
    _Windows_Sys(5)=oldxm : _Windows_Sys(6)=oldym
    _Windows_Sys(7)=_gad : _Windows_Sys(8)=_win
    _Windows_Sys(9)=_newgad : _Windows_Sys(10)=_newwin
    _Windows_sys(16)=xwin : _Windows_sys(17)=ywin
   Endif
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Enable_RealTime_Moving()                         Active le mode temps réel pour les déplacements de fenêtres.
Function MW_Enable_RealTime_Moving()
  _Windows_Sys(11)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Disable_RealTime_Moving()                     Désactive le mode temps réel pour les déplacements de fenêtres.
Function MW_Disable_RealTime_Moving()
  _Windows_Sys(11)=0
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Enable_RealTime_Scaling()                   Active le mode temps réel pour les redimensionnement de fenêtres.
Function MW_Enable_RealTime_Scaling()
  _Windows_Sys(12)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Dinable_RealTime_Scaling()               Désactive le mode temps réel pour les redimensionnement de fenêtres.
Function MW_Disable_RealTime_Scaling()
  _Windows_Sys(12)=0
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Enable_RealTime_DrawingPriority()      Active le mode temps réel pour les changement de priorité d'affichage.
Function MW_Enable_RealTime_DrawingPriority()
  _Windows_Sys(13)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Dinable_RealTime_DrawingPriority()  Désactive le mode temps réel pour les changement de priorité d'affichage.
Function MW_Disable_RealTime_DrawingPriority()
  _Windows_Sys(13)=0
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_AutoClearMode_On()                                            Active le mode CLS sur le bitmap 0 automatique.
Function MW_AutoClearMode_On()
  _Windows_Sys(20)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_AutoClearMode_Off()                              Désactive le mode CLS sur le bitmap 0 automatique (=défaut).
Function MW_AutoClearMode_Off()
  _Windows_Sys(20)=0
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_BackgroundRefreshMode_On()                    Active le mode de rafraichissement automatique du fond d'image.
Function MW_BackgroundRefreshMode_On()
  _Windows_Sys(21)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_BackgroundRefreshMode_Off()       Désactive le mode de rafraichissement automatique du fond d'image(=defaut).
Function MW_BackgroundRefreshMode_Off()
  _Windows_Sys(21)=0
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Sprite_Mode_On() [NEW                                   Active le mode d'affichage des fenêtres par sprites.
Function MW_Sprite_Mode_On()
  _Windows_sys(22)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Paste_Mode_On() [NEW]                               Active le mode d'affichage des fenêtres par paste images.
Function MW_Paste_Mode_On()
  _Windows_sys(22)=0
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_DBPro_Mode_On() [NEW]                       Active le FLAG pour les images désactivant le mode BLUR de dbpro.
Function MW_DBPro_Mode_On()
  _Windows_Sys(31)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Auto_Images_To_VideoRam() [NEW]     Load Automatically images to VideoRam (DBv1) equal to MW_DBPro_Mode_On().
Function MW_Auto_Images_To_VideoRam()
  _Windows_sys(24)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Auto_Images_Compression_On() [NEW]          Load images to videoram and use texture compression if available.
Function MW_Auto_Images_Compression_On()
  _Windows_sys(24)=2
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Auto_Images_To_SystemRam() [NEW]          Load images to videoram and use texture compression if available.
Function MW_Auto_Images_To_SystemRam()
  _Windows_sys(24)=0
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem =MW_RequestBox1(_winnum,title$,_desc$,item$) [NEW]              Ouvre une fenêtre de requête et attend un choix.
Function MW_RequestBox1(_winnum,_title$,_comment$,_item1$)
  _gad=0
  if MW_Window_Exist(_winnum)=1 then MW_Close_Window(_winnum)
  MW_Open_New_Window(_winnum,_title$,320,64,0,0,0)
  MW_Ink(_winnum,255,255,255) : MW_Text(_winnum,160,8,_comment$)
  MW_Create_Text_Gadget(_winnum,1,_item1$,130,32,60,16)
  MW_Position_Window(_winnum,(Bitmap Width(0)/2)-160,(Bitmap Height(0)/2)-32)
  Repeat
    MW_Background_task()
    _Win=MW_Current_Window()
    if _Win=_Winnum and mouseclick()=1 then _Gad=MW_Current_Gadget()
    MW_Sync(0)
    Sync
   Until _gad>0
  Repeat
    MW_Background_Task() : MW_Sync(0) : Sync
   Until mouseclick()=0
  if MW_Window_Exist(_Winnum)=1 then MW_Close_Window(_Winnum)
 EndFunction _gad
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem =MW_RequestBox2(_winnum,title$,_desc$,item1$,item2$) [NEW]      Ouvre une fenêtre de requête et attend un choix.
Function MW_RequestBox2(_winnum,_title$,_comment$,_itm1$,_itm2$)
  _gad=0
  if MW_Window_Exist(_winnum)=1 then MW_Close_Window(_winnum)
  MW_Open_New_Window(_winnum,_title$,320,64,0,0,0)
  MW_Ink(_winnum,255,255,255) : MW_Text(_winnum,160,8,_comment$)
  MW_Create_Text_Gadget(_winnum,1,_itm1$,50,32,60,16)
  MW_Create_Text_Gadget(_winnum,2,_itm2$,210,32,60,16)
  MW_Position_Window(_winnum,(Bitmap Width(0)/2)-160,(Bitmap Height(0)/2)-32)
  Repeat
    MW_Background_task()
    _Win=MW_Current_Window()
    if _Win=_Winnum and mouseclick()=1 then _Gad=MW_Current_Gadget()
    MW_Sync(0)
    Sync
   Until _gad>0
  Repeat
    MW_Background_Task() : MW_Sync(0) : Sync
   Until mouseclick()=0
  if MW_Window_Exist(_Winnum)=1 then MW_Close_Window(_Winnum)
 EndFunction _gad
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem =MW_RequestBox3(_winnum,title$,_desc$,itm1$,itm2$,_itm3$) [NEW] Ouvre une fenêtre de requête et attend un choix.
Function MW_RequestBox3(_winnum,_title$,_comment$,_itm1$,_itm2$,_itm3$)
  _gad=0
  if MW_Window_Exist(_winnum)=1 then MW_Close_Window(_winnum)
  MW_Open_New_Window(_winnum,_title$,320,64,0,0,0)
  MW_Ink(_winnum,255,255,255) : MW_Text(_winnum,160,8,_comment$)
  MW_Create_Text_Gadget(_winnum,1,_itm1$,50,32,60,16)
  MW_Create_Text_Gadget(_winnum,2,_itm2$,130,32,60,16)
  MW_Create_Text_Gadget(_winnum,3,_itm3$,210,32,60,16)
  MW_Position_Window(_winnum,(Bitmap Width(0)/2)-160,(Bitmap Height(0)/2)-32)
  Repeat
    MW_Background_task()
    _Win=MW_Current_Window()
    if _Win=_Winnum and mouseclick()=1 then _Gad=MW_Current_Gadget()
    MW_Sync(0)
    Sync
   Until _gad>0
  Repeat
    MW_Background_Task() : MW_Sync(0) : Sync
   Until mouseclick()=0
  if MW_Window_Exist(_Winnum)=1 then MW_Close_Window(_Winnum)
 EndFunction _gad
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Auto_Position_Save_on()                                      Sauvegarde les dernières positions des fenêtres.
Function MW_Auto_Position_Save_On()
  _Windows_Sys(30)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Auto_Position_Save_off()                              Ne sauvegarde pas les dernières positions des fenêtres.
Function MW_Auto_Position_Save_Off()
  _Windows_Sys(30)=0
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Set_Mouse_Pointer(_image) [NEW]                            Utilise un sprite pour faire le curseur graphique.
Function MW_Set_Mouse_Pointer(_image)
  if image exist(_image)=1 then _Windows_Sys(29)=_image
  hide mouse
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Default_Mouse_Pointer() [NEW]                                             Remet le curseur de souris de DBv1.
Function MW_Default_Mouse_Pointer()
  _Windows_Sys(29)=0
  show mouse
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Hide_Windows_Border() [NEW]                                          n'affiche pas les bordures des fenêtres.
Function MW_Hide_Windows_Border()
  _Windows_Sys(33)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW SYSTEM FUNCTIONS ---------
Rem MW_Show_Windows_Border() [NEW]                                      Affiche les bordures des fenêtres (=defaut).
Function MW_Show_Windows_Border()
  _Windows_Sys(33)=0
 EndFunction
Rem
Rem
Rem
Rem ----------------------------------------------------------------------------------- MW DISK FUNCTIONS ----------
Rem MW_Load_Bitmap2Window(_file$,_window)                            Charge une image .bmp ou .jpg dans une fenêtre.
Function MW_Load_Bitmap2Window(_file$,_winnum)
  _ERROR=0
  if _winnum>0 and _winnum<25
    _bmp=32
    Repeat
      dec _bmp,1
     until _bmp=0 or bitmap exist(_bmp)=0
    if _bmp>0
      if file exist(_file$)=1
        load bitmap _file$,_bmp
        if MW_Window_Exist(_winnum)=1 then MW_close_Window(_winnum)
        xsize=bitmap width(_bmp) : ysize=bitmap height(_bmp)
        MW_Open_New_Window(_winnum,_file$,xsize,ysize,1,0,0)
        MW_Copy_Bitmap2Window(_bmp,0,0,xsize-1,ysize-1,_winnum,0,0,xsize-1,ysize-1)
        delete bitmap _bmp
        _Windows_Data(_winnum,0)=1
       endif
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ----------------------------------------------------------------------------------- MW DISK FUNCTIONS ----------
Rem MW_Save_WindowImage(_windonw,_file$)                    Sauvegarde le contenu d'une fenêtre en image sur disque.
Function MW_Save_WindowImage(_winnum,_file$)
  _ERROR=0
  if _winnum>0 and _winnum<25
    _bmp=32
    Repeat
      dec _bmp,1
     until _bmp=0 or bitmap exist(_bmp)=0
    if _bmp>0
      xsize=_Windows_Data(_winnum,04) : ysize=_Windows_Data(_winnum,05)
      Create Bitmap _bmp,xsize,ysize
      if file exist(_file$)=1 then delete file _file$
      MW_Copy_Window2Bitmap(_winnum,0,0,xsize-1,ysize-1,_bmp,0,0,xsize-1,ysize-1)
      save bitmap _file$,_bmp
      delete bitmap _bmp
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem
Rem
Rem
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem MW_Window_Exist(_window)                                       Renvoie 1 si la fenêtre demandée existe sinon 0.
Function MW_Window_Exist(_winnum)
  _EXIST=_Windows_Data(_winnum,01)
 EndFunction _EXIST
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem MW_Window_XSize(_window)                      Renvoie la dimension sur X de la fenêtre demandée si elle existe.
Function MW_Window_XSize(_winnum)
  _SIZE=-1 : if _Windows_Data(_winnum,01)=1 then _SIZE=_Windows_Data(_winnum,04) else _SIZE=0
 EndFunction _SIZE
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem MW_Window_YSize(_window)                      Renvoie la dimension sur Y de la fenêtre demandée si elle existe.
Function MW_Window_YSize(_winnum)
  _SIZE=-1 : if _Windows_Data(_winnum,01)=1 then _SIZE=_Windows_Data(_winnum,05) else _SIZE=0
 EndFunction _SIZE
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem MW_Window_XPosition(_window)      Renvoie la position sur X dans l'écran de la fenêtre demandée si elle existe.
Function MW_Window_XPosition(_winnum)
  _POS=-1 : if _Windows_Data(_winnum,01)=1 then _POS=_Windows_Data(_winnum,02) else _POS=0
 EndFunction _POS
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem MW_Window_YPosition(_window)      Renvoie la position sur Y dans l'écran de la fenêtre demandée si elle existe.
Function MW_Window_YPosition(_winnum)
  _POS=-1 : if _Windows_Data(_winnum,01)=1 then _POS=_Windows_Data(_winnum,03) else _POS=0
 EndFunction _POS
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem =MW_Window_Over()                   Renvoie le numéro de la fenêtre devant laquelle le curseur de la souris est.
Function MW_Window_Over()
  _Current=0 : _TRUE=0
  xm=mousex() : ym=mousey()
  if _Windows_Sys(4)>0
    _count=_Windows_sys(4)+1
    Repeat
      Dec _count,1
      _winnum=_Windows_Order(_count)
      xpos=_Windows_Data(_winnum,02) : ypos=_Windows_Data(_winnum,03)
      xsize=_Windows_Data(_winnum,04) : ysize=_Windows_Data(_winnum,05)
      if _Windows_Sys(33)=0
        xsize=xsize+4 : ysize=ysize+14
       endif
      if xm>xpos-1 and ym>ypos-1
        if xm<xpos+xsize and ym<ypos+ysize then _TRUE=1
       Endif
     until _TRUE=1 or _count=1
    if _TRUE=1 then _Current=_winnum
   Endif
  _Windows_sys(10)=_Current
 EndFunction _Current
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem =MW_Window_Gadget(_window)            Renvoie le numéro du gadget au dessus duquel le pointeur de la souris est.
Function MW_Window_Gadget(_winnum)
  _Gadget=0
  if _Windows_Data(_winnum,1)=1
    xm=mousex() : ym=mousey()
    xpos=_Windows_Data(_winnum,02) : ypos=_Windows_Data(_winnum,03)
    xsize=_Windows_Data(_winnum,04) : ysize=_Windows_Data(_winnum,05)
    if _Windows_Sys(33)=0
      xsize=xsize+4 : ysize=ysize+14
     endif
    if xm>xpos-1 and ym>ypos-1
      if xm<xpos+xsize and ym<ypos+ysize
        xc=xm-xpos : yc=ym-ypos : Rem xc,yc and mouse coordinates inside windows
        Rem Si le curseur est dans la barre des titres.
        if yc<13 and _Windows_Sys(33)=0 then _Gadget=-2
        if yc<2 and _Windows_Sys(33)=1 then _Gadget=-2
        Rem Si le curseur est en dessus du bouton de fermeture de fenêtre.
        if xc<13 and yc<13 and _Windows_Data(_winnum,6)=1 then _Gadget=-1
        Rem Si le curseur est en dessus du bouton de Window_To_Front ou Window_To_Back
        if _Windows_Data(_winnum,8)=1
          if xc>xsize-24 and xc<xsize-11 and yc<13 then _Gadget=-4
          if xc>xsize-12 and xc<xsize and yc<13 then _Gadget=-3
         Endif
        Rem Si le curseur est en dessus du bouton de redimensionnement de fenêtre.
        if _Windows_Data(_winnum,7)=1
          if xc>xsize-12 and xc<xsize
            if yc>ysize-12 and yc<ysize then _Gadget=-5
           Endif
         Endif
        Rem Si le curseur est en dessus d'un gadget .
        For _gdg=1 to 16
          if _Windows_Gadget(_winnum,_gdg,1)>0 and _Windows_Gadget(_winnum,_gdg,3)=1
            xp=_Windows_Gadget(_winnum,_gdg,4)+2 : yp=_Windows_Gadget(_winnum,_gdg,5)+12
            xs=_Windows_Gadget(_winnum,_gdg,6) : ys=_Windows_Gadget(_winnum,_gdg,7)
            if xc>xp-1 and yc>yp-1
              if xc<xp+xs and yc<yp+ys then _Gadget=_gdg
             endif
           Endif
         Next _gdg
        Rem Si le curseur est en dessus
       Endif
     Endif
   else
    _Gadget=-6
   endif
  _Windows_sys(09)=_Gadget
 EndFunction _Gadget
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem =MW_Current_Window()
Function MW_Current_Window()
  _VAL=_Windows_sys(10)
 Endfunction _VAL
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem =MW_Current_Gadget()
Function MW_Current_Gadget()
  _VAL=_Windows_sys(09)
 Endfunction _VAL
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem =MW_Realtime_Moving_State()
Function MW_RealTime_Moving_State()
  _VAL=_Windows_Sys(11)
 EndFunction _VAL
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem =MW_Realtime_Scaling_State()
Function MW_RealTime_Scaling_State()
  _VAL=_Windows_Sys(12)
 EndFunction _VAL
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem =MW_Realtime_Drawing_State()
Function MW_RealTime_Drawing_State()
  _VAL=_Windows_Sys(13)
 EndFunction _VAL
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem =MW_MagicWindows_Initialized()
Function MW_MagicWindows_Initialized()
  _VAL=_Windows_Sys(13)
 EndFunction _VAL
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem ...$=MW_Get_FileName()              Donne le nom du dernier fichier choisi avec le sélecteur de fichier intégré.
Function MW_Get_FileName()
  _fichierfinal$=fileselector$(9)
 EndFunction _fichierfinal$
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem ...$=MW_Get_DrawerName()            Donne le nom du dernier dossier choisi avec le sélecteur de fichier intégré.
Function MW_Get_DrawerName()
  _dossierfinal$=fileselector$(8)
 EndFunction _dossierfinal$
Rem -------------------------------------------------------------------------------- MW DATA BACK FUNCTIONS --------
Rem =MW_Windows_Opened() [NEW]                 Renvoie le nombre correspondant à la quantité de fenêtres existantes.
Function MW_Windows_Opened()
  _RESULT=_Windows_Sys(4)
 EndFunction _RESULT
 Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Create_Text_Gadget(_Window,_Gadget,_Text$,XPos,Ypos,Xsize,Ysize)                Crée un gadget de type texte.
Function MW_Create_Text_Gadget(_win,_gad,_texte$,xp,yp,xs,ys)
  _ERROR=0
  if _win>0 and _win<17
    if _Windows_Data(_win,1)=1
      if _Windows_Gadget(_win,_gad,1)=0
        _Windows_Data(_win,0)=1
        _Windows_Gadget(_win,_gad,1)=2 : _Windows_Gadget(_win,_gad,3)=1
        _Windows_Gadget(_win,_gad,4)=xp : _Windows_Gadget(_win,_gad,5)=yp
        _Windows_Gadget(_win,_gad,6)=xs : _Windows_Gadget(_win,_gad,7)=ys
        _Windows_Gadget_Text$(_win,_gad)=_texte$
        MW_Refresh_Gadget(_win,_gad)
       else
        _ERROR=-8
       EndIf
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Create_Graphical_Gadget(_Window,_Gadget,_Image,Xpos,Ypos,Xsize,Ysize)       Crée un gadget de type graphique.
Function MW_Create_Graphical_Gadget(_winnum,_gadget,_Image,xp,yp,xs,ys)
  _ERROR=0
  if _winnum>0 and _winnum<25
    if _Windows_Data(_winnum,1)=1
      if _Windows_Gadget(_winnum,_gadget,1)=0
        _Windows_Data(_winnum,0)=1
        _Windows_Gadget(_winnum,_gadget,1)=3 : Rem Gadget de type GRAPHIQUE IMAGE UTILISATEUR
        _Windows_Gadget(_winnum,_gadget,2)=_Image : Rem Numéro de l'image à utiliser pour le gadget.
        _Windows_Gadget(_winnum,_gadget,3)=1 : Rem le gadget est actif par défaut.
        _Windows_Gadget(_winnum,_gadget,4)=xp : _Windows_Gadget(_winnum,_gadget,5)=yp
        _Windows_Gadget(_winnum,_gadget,6)=xs : _Windows_Gadget(_winnum,_gadget,7)=ys
        _Windows_Gadget(_Winnum,_Gadget,8)=_Image
        MW_Refresh_Gadget(_winnum,_gadget)
       else
        _ERROR=-8
       EndIf
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Set_Alternate_Gadget_Image(_Window,_Gadget,_Image)                        Créer l'image alternée d'un gadget.
Function MW_Set_Alternate_Gadget_Image(_Win,_Gad,_Image)
  if image exist(_Image)=1 then _Windows_Gadget(_Win,_Gad,8)=_Image
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Delete_Gadget(_Window,_Gadget)                                                     Efface un gadget existant.
Function MW_Delete_Gadget(_winnum,_gadget)
  For boucle=1 to 7
    _Windows_Gadget(_winnum,_gadget,boucle)=0
   next boucle
  _Windows_Gadget_Text$(_winnum,_gadget)=""
 Endfunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Disable_Gadget(_Window,_Gadget)                                              Rend un gadget existant inactif.
Function MW_Disable_Gadget(_winnum,_gadget)
  _Windows_Gadget(_winnum,_gadget,2)=0
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Enable_Gadget(_Window,_Gadget)                                                 Rend un gadget existant actif.
Function MW_Enable_Gadget(_winnum,_gadget)
  _Windows_Gadget(_winnum,_gadget,2)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Create_Gadget(_Window,_Gadget,_Type,Xpos,Ypos)                     Crée un gadget parmi une liste prédéfinié.
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Refresh_Gadget(_window,_gadget)                                         Redéssine un gadget dans une fenêtre.
Function MW_Refresh_Gadget(_win,_gad)
  _ERROR=0
  if _win>0 and _win<25
    if _Windows_Data(_win,1)=1
      _gad_type=_Windows_Gadget(_win,_gad,1)
      _Windows_Data(_win,0)=1
      if _gad_type>0
Rem        if _gadget_type=1 then MW_Refresh_Defined_Gadget(_win,_gad)
        if _gad_type=2 then MW_Refresh_Text_Gadget(_win,_gad)
        if _gad_type=3 then MW_Refresh_Graphic_Gadget(_win,_gad)
       else
        _ERROR=-9
       EndIf
     else
      _ERROR=-4
     endif
   else
    _ERROR=-1
   endif
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Refresh_Text_Gadget(_window,_gadget)       [SYSTEM]      Rafraichit un gadget de type texte dans une fenetre.
Function MW_Refresh_Text_Gadget(_winnum,_gadget)
  _Windows_Data(_winnum,0)=1
  xp=_Windows_Gadget(_winnum,_gadget,4) : yp=_Windows_Gadget(_winnum,_gadget,5)
  xs=_Windows_Gadget(_winnum,_gadget,6) : ys=_Windows_Gadget(_winnum,_gadget,7)
  _texte$=_Windows_Gadget_Text$(_winnum,_gadget)
  set current bitmap 32-_winnum
  Rem On redéssine le fond du gadget
  _red1=_Windows_Data(_winnum,09) : _green1=_Windows_Data(_winnum,10) : _blue1=_Windows_Data(_winnum,11)
  ink rgb(_red1,_green1,_blue1),0
  box xp+2,yp+12,xp+xs+2,yp+ys+12
  Rem On trace la partie claire du bouton.
  _red2=_Windows_Data(_winnum,18) : _green2=_Windows_Data(_winnum,19) : _blue2=_Windows_Data(_winnum,20)
  ink rgb(_red2,_green2,_blue2),0
  line xp+2,yp+12,xp+xs+1,yp+12 : line xp+2,yp+12,xp+2,yp+ys+11
  line xp+2,yp+ys+11,xp+xs+1,yp+ys+11 : line xp+xs+1,yp+12,xp+xs+1,yp+ys+11
  Rem On trace la partie foncée du bouton.
  _red3=_Windows_Data(_winnum,21) : _green3=_Windows_Data(_winnum,22) : _blue3=_Windows_Data(_winnum,23)
  ink rgb(_red3,_green3,_blue3),0
  line xp+3,yp+13,xp+xs+2,yp+13 : line xp+3,yp+13,xp+3,yp+ys+12
  line xp+3,yp+ys+12,xp+xs+2,yp+ys+12 : line xp+xs+2,yp+13,xp+xs+2,yp+ys+12
  Rem On trace le texte.
  _red4=_Windows_Data(_winnum,14) : _green4=_Windows_Data(_winnum,15) : _blue4=_Windows_Data(_winnum,16)
Rem  ink rgb(_red4,_green4,_blue4),0
  Ink rgb(255,255,255),0
  MW_Set_Text_Font_Sys(_Windows_Font$(_winnum))
  MW_Set_Text_Size_Sys(_Windows_Data(_winnum,17))
  MW_Set_Text_Transparent_Sys()
  Center Text xp+2+(xs/2),yp+12,_texte$
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Refresh_Text_Gadget_Light(_window,_gadget)       [SYSTEM]      Rafraichit un gadget de type texte dans une fenetre.
Function MW_Refresh_Text_Gadget_Light(_winnum,_gadget)
  _Windows_Data(_winnum,0)=1
  xp=_Windows_Gadget(_winnum,_gadget,4) : yp=_Windows_Gadget(_winnum,_gadget,5)
  xs=_Windows_Gadget(_winnum,_gadget,6) : ys=_Windows_Gadget(_winnum,_gadget,7)
  _texte$=_Windows_Gadget_Text$(_winnum,_gadget)
  set current bitmap 32-_winnum
  Rem On redéssine le fond du gadget
  _red=_Windows_Data(_winnum,09)+32 : _green=_Windows_Data(_winnum,10)+32 : _blue=_Windows_Data(_winnum,11)+32
  if _red>255 then _red=255
  if _green>255 then _green=255
  if _blue>255 then _blue=255
  ink rgb(_red,_green,_blue),0
  box xp+2,yp+12,xp+xs+2,yp+ys+12
  Rem On trace la partie claire du bouton.
  _red=_Windows_Data(_winnum,18)+32 : _green=_Windows_Data(_winnum,19)+32 : _blue=_Windows_Data(_winnum,20)+32
  if _red>255 then _red=255
  if _green>255 then _green=255
  if _blue>255 then _blue=255
  ink rgb(_red,_green,_blue),0
  line xp+2,yp+12,xp+xs+1,yp+12 : line xp+2,yp+12,xp+2,yp+ys+11
  line xp+2,yp+ys+11,xp+xs+1,yp+ys+11 : line xp+xs+1,yp+12,xp+xs+1,yp+ys+11
  Rem On trace la partie foncée du bouton.
  _red=_Windows_Data(_winnum,21)+32 : _green=_Windows_Data(_winnum,22)+32 : _blue=_Windows_Data(_winnum,23)+32
  if _red>255 then _red=255
  if _green>255 then _green=255
  if _blue>255 then _blue=255
  ink rgb(_red,_green,_blue),0
  line xp+3,yp+13,xp+xs+2,yp+13 : line xp+3,yp+13,xp+3,yp+ys+12
  line xp+3,yp+ys+12,xp+xs+2,yp+ys+12 : line xp+xs+2,yp+13,xp+xs+2,yp+ys+12
  Rem On trace le texte.
  _red=_Windows_Data(_winnum,14)+32 : _green=_Windows_Data(_winnum,15)+32 : _blue=_Windows_Data(_winnum,16)+32
  if _red>255 then _red=255
  if _green>255 then _green=255
  if _blue>255 then _blue=255
  ink rgb(_red,_green,_blue),rgb(_red2,_green2,_blue2)
  MW_Set_Text_Font_Sys(_Windows_Font$(_winnum))
  MW_Set_Text_Size_Sys(_Windows_Data(_winnum,17))
  MW_Set_Text_Transparent_Sys()
  Center Text xp+2+(xs/2),yp+12,_texte$
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Refresh_Graphic_Gadget(_window,_gadget)       [SYSTEM]   Rafraichit un gadget de type texte dans une fenetre.
Function MW_Refresh_Graphic_Gadget(_winnum,_gadget)
  _Windows_Data(_winnum,0)=1
  _Image=_Windows_Gadget(_winnum,_gadget,2)
  xp=_Windows_Gadget(_winnum,_gadget,4) : yp=_Windows_Gadget(_winnum,_gadget,5)
  set current bitmap 32-_winnum
  if _Image>0 then if image exist(_Image)=1 then paste image _Image,xp+2,yp+12
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Refresh_Graphic_Gadget(_window,_gadget)       [SYSTEM]   Rafraichit un gadget de type texte dans une fenetre.
Function MW_Refresh_Graphic_Gadget_Light(_winnum,_gadget)
  _Windows_Data(_winnum,0)=1
  _Image=_Windows_Gadget(_winnum,_gadget,8)
  xp=_Windows_Gadget(_winnum,_gadget,4) : yp=_Windows_Gadget(_winnum,_gadget,5)
  set current bitmap 32-_winnum
  if _Image>0 then if image exist(_Image)=1 then paste image _Image,xp+2,yp+12
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Auto_Gadget_Refresh_On()                    Active le rafraichissement automatique des gadgets à l'affichage.
Function MW_Auto_Gadget_Refresh_On()
  _Windows_Sys(15)=1
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem MW_Auto_Gadget_Refresh_Off()                Désactive le rafraichissement automatique des gadgets à l'affichage.
Function MW_Auto_Gadget_Refresh_Off()
  _Windows_Sys(15)=0
 EndFunction
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem =MW_Gadget_Exist(_Window,_Gadget)                                                =1 si le gadget demandé existe.
Function MW_Gadget_Exist(_winnum,_gadget)
  _EXIST=0
  _gad=_Windows_Gadget(_winnum,_gadget,1)
  if _gad>0 then _EXIST=1
 EndFunction _EXIST
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem =MW_Gadget_Type(_Window,_Gadget)                                             Renvoie quel type de gadget est-ce.
Function MW_Gadget_Type(_winnum,_gadget)
  _gad=_Windows_Gadget(_winnum,_gadget,1)
 EndFunction _gad
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem =MW_Gadget_Active(_Window_Gadget)                                           =1 si le gadget existe et est actif.
Function MW_Gadget_Active(_winnum,_gadget)
  _gad=_Windows_Gadget(_winnum,_gadget,2)
 EndFunction _gad
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem =MW_Window_Position_X()
Function MW_Window_Position_X()
  _xps=_Windows_Sys(16)
 EndFunction _xps
Rem ---------------------------------------------------------------------------------- MW GADGET FUNCTIONS ---------
Rem =MW_Window_Position_Y()
Function MW_Window_Position_Y()
  _yps=_Windows_Sys(17)
 EndFunction _yps
Rem ----------------------------------------------------------------------------------- MW DISK FUNCTIONS ----------
Rem MW_File_Selector_v2(_window,_loaderpath$,filter1$,filter2$)           Crée une fenêtre de sélecteur de fichiers.
function MW_File_Selector_v2(_winnum,_loaderpath$,filter1$,filter2$)
Rem Cette image est l'image de sélecteur de fichier.
  fileselectordata(13)=_Winnum
  fileselector$(5)=filter1$
  fileselector$(6)=filter2$
  If MW_Window_Exist(_winnum)=1 then MW_Close_Window(_winnum)
  MW_Open_New_Window(_winnum,fileselector$(2),380,353,1,0,0)
  MW_Sync(0) : sync
  MW_Position_Window(_winnum,0,12)
Rem  MW_Paste_Image(_winnum,6,0,0)
  FS_File_Selector_Display()
  Rem set dir path$
  cd _loaderpath$
  fileselector$(3)=fileselector$(1)
  FS_refreshdrawercontent()
  FS_displaydrawername()
  FS_displayfilters()
  fileselectordata(10)=0
  repeat
    MW_BackGround_Task()
    if mouseclick()=1
      _wnd=MW_Current_Window()
      if _wnd=_winnum
        _gad=MW_Current_Gadget()
        xm=MW_Window_Position_X() : ym=MW_Window_Position_Y()
       else
        xm=0 : ym=0
        _gad=0
       endif
      if _wnd=_Winnum
      REM REMONTER DANS LA LISTE D'ITEMS
        if _gad=1
          fileselectordata(4)=fileselectordata(4)-1
          fileselectordata(9)=1
         endif
        REM DESCENDRE DANS LA LISTE D'ITEMS
        if _gad=2
          fileselectordata(4)=fileselectordata(4)+1
          fileselectordata(9)=1
         endif
       endif
        REM OPTION "CANCEL"/"ANNULER" = fileselectordata(10)
        if _gad=4
          fileselectordata(10)=1
          fileselector$(8)=""
          fileselector$(9)=""
         endif
         REM OPTION "OUVRIR"
        if _gad=3
          if fileselectordata(8)>0
            fileselectordata(10)=1
            fileselector$(8)=fileselector$(3)
            if right$(fileselector$(8),1)<>"\" then fileselector$(8)=fileselector$(8)+"\"
            fileselector$(9)=_extpath$+_fichier$(fileselectordata(8))
           endif
         endif
      REM CHOIX D'UN FICHIER DANS LA LISTE.
      if xm>21 and xm<358 and ym>24 and ym<153
        _num=(ym-24)/14
        fileselectordata(8)=_num+fileselectordata(4)
        if fileselectordata(8)>fileselectordata(5) then fileselectordata(8)=0
        if fileselectordata(8)>0 then FS_displayselected()
       endif
     endif
    if fileselectordata(4)>(fileselectordata(5)-9) then fileselectordata(4)=(fileselectordata(5)-9)
    if fileselectordata(4)<1 then fileselectordata(4)=1
    if fileselectordata(9)=1
      FS_Display_all()
      fileselectordata(9)=0
     endif
    if fileselectordata(8)>0
      fileselector$(7)=_fichier$(fileselectordata(8))
      if fileselector$(7)="[..]"
        fileselector$(4)=".."
        FS_changedrawer()
        FS_displaydrawername()
        FS_displayselected()
       endif
      if left$(fileselector$(7),1)="["
        fileselector$(4)=""
        for boucle=2 to (len(fileselector$(7))-1)
          fileselector$(4)=fileselector$(4)+mid$(fileselector$(7),boucle)
         next boucle
        FS_changedrawer()
        FS_displaydrawername()
        FS_displayselected()
       endif
     endif
    if MW_window_Exist(_winnum)=1 then MW_window_To_Front(_winnum)
    if mouseclick()=1
      Repeat
        MW_Sync(0) : Sync
        MW_BackGround_Task()
       Until Mouseclick()=0
     endif
    MW_Sync(0) : Sync
   until fileselectordata(10)=1 or MW_Window_Exist(_winnum)=0
  fileselectordata(8)=0 : fileselector$(7)=""
  fileselectordata(10)=0
  cd fileselector$(1)
  if fileselector$(8)<>"" then _selected=1
  if bitmap exist(1)=1 then delete bitmap 1
  MW_Background_Task()
  if MW_Window_Exist(_winnum)=1 then MW_Close_Window(_winnum)
  MW_sync(0) : sync
 endfunction _selected
REM                                             FONCTION POUR AFFICHER LA LISTE DES FICHIERS.
function FS_Display_all()
  _winnum=fileselectordata(13)
  _Windows_Data(_winnum,0)=1
  xpost=22 : ypost=24
  MW_Ink(_winnum,60,60,60)
  MW_box(_winnum,22,25,357,152)
  REM AFFICHER LA LISTE DE FICHIERS.
  MW_Ink(_winnum,255,255,255)
  fileselectordata(3)=fileselectordata(4)+8
  if fileselectordata(3)>fileselectordata(5) then fileselectordata(3)=fileselectordata(5)
  for boucle=fileselectordata(4) to fileselectordata(3)
    MW_Set_Cursor(_winnum,xpost+2,ypost)
    inc ypost,14
    MW_Print(_winnum,right$(_fichier$(boucle),40))
   next boucle
 endfunction
REM                                             FONCTION POUR AFFICHER LE NOM DU FICHIER CHOISI.
function FS_displayselected()
  _winnum=fileselectordata(13)
  _Windows_Data(_winnum,0)=1
  Rem AFFICHER LE FICHIER CHOISI.
  MW_Ink(_winnum,60,60,60)
  MW_Box(_winnum,55,159,246,170)
  MW_Ink(_winnum,255,255,255)
  MW_Set_Cursor(_winnum,55,157)
  if fileselectordata(8)>0
    MW_Print(_winnum,_fichier$(fileselectordata(8)))
    ext$=right$(_fichier$(fileselectordata(8)),4)
    if file exist(_fichier$(fileselectordata(8))+".jpg")=1
      Rem Display a preview of the texture you've selected.
      load bitmap _fichier$(fileselectordata(8))+".jpg",1
      xbitmap=bitmap width(1) : ybitmap=bitmap height(1)
      MW_Copy_Bitmap2Window(1,0,0,xbitmap-1,ybitmap-1,_winnum,249,259,328,338)
      MW_Ink(_winnum,32,32,32)
      MW_Box(_winnum,102,264,242,345)
      MW_Ink(_winnum,255,255,255)
      MW_Sync(0) : sync
      MW_BackGround_Task()
     endif
    if ext$=".jpg" or ext$=".bmp"
      Rem Display a preview of the texture you've selected.
      load bitmap _fichier$(fileselectordata(8)),1
      xbitmap=bitmap width(1) : ybitmap=bitmap height(1)
      MW_Copy_Bitmap2Window(1,0,0,xbitmap-1,ybitmap-1,_winnum,249,259,328,338)
      MW_Ink(_winnum,32,32,32)
      MW_Box(_winnum,102,264,242,345)
      MW_Ink(_winnum,255,255,255)
      MW_Set_Cursor(_winnum,102,270) : MW_Print(_winnum,str$(xbitmap)+" pixels")
      MW_Set_Cursor(_winnum,102,298) : MW_Print(_winnum,str$(ybitmap)+" pixels")
      MW_Sync(0) : sync
      MW_BackGround_Task()
     endif
   else
    MW_Ink(_winnum,64,64,64)
    MW_Box(_winnum,249,259,328,338)
    MW_Ink(_winnum,32,32,32)
    MW_Box(_winnum,102,264,242,345)
    MW_Sync(0) : Sync
    MW_BackGround_Task()
   endif
  if bitmap exist(1)=1 then delete bitmap 1
 endfunction
REM                                             FONTION POUR AFFICHER LE CHEMIN COURANT.
function FS_displaydrawername()
  _winnum=fileselectordata(13)
  _Windows_Data(_winnum,0)=1
  Rem AFFICHER LE CHEMIN D'ACCES COURANT.
  MW_Ink(_winnum,60,60,60)
  MW_Box(_winnum,63,4,352,15)
  MW_Ink(_winnum,255,255,255)
  MW_Set_Cursor(_winnum,63,3)
  MW_Print(_winnum,right$(fileselector$(3),40))
 endfunction
Rem                                             CHANGE LE DOSSIER COURANT.
function FS_changedrawer()
  cd fileselector$(4)
  fileselector$(3)=get dir$()
  FS_refreshdrawercontent()
 endfunction
REM                                             REACTUALISE LE CONTENU DU DOSSIER SELON LES FILTRES.
function FS_refreshdrawercontent()
  _winnum=fileselectordata(13)
  _Windows_Data(_winnum,0)=1
  fileselectordata(5)=1
  perform checklist for files
  fileselectordata(7)=checklist quantity()
  for boucle=1 to fileselectordata(7)
    _name$=checklist string$(boucle)
    if checklist value a(boucle)=1
      _fichier$(fileselectordata(5))=lower$("["+_name$+"]")
      fileselectordata(5)=fileselectordata(5)+1
     endif
   next boucle
  for boucle=1 to fileselectordata(7)
    _name$=checklist string$(boucle)
    if checklist value a(boucle)=0
      if fileselector$(5)="" and fileselector$(6)=""
        _fichier$(fileselectordata(5))=lower$(_name$)
        fileselectordata(5)=fileselectordata(5)+1
       endif
     endif
    Rem SI LE FILTRE 1 EST ACTIF , ON REGARDE SI L'EXTENSION DU FICHIER CORRESPOND
    if fileselector$(5)<>""
      ext$=lower$(right$(_name$,len(fileselector$(5))))
      if ext$=fileselector$(5)
        _fichier$(fileselectordata(5))=lower$(_name$)
        fileselectordata(5)=fileselectordata(5)+1
       endif
     endif
    Rem SI LE FILTRE 1 EST ACTIF , ON REGARDE SI L'EXTENSION DU FICHIER CORRESPOND
    if fileselector$(6)<>""
      ext$=lower$(right$(_name$,len(fileselector$(6))))
      if ext$=fileselector$(6)
        _fichier$(fileselectordata(5))=lower$(_name$)
        fileselectordata(5)=fileselectordata(5)+1
       endif
     endif
   next boucle
  for boucle=fileselectordata(5) to 255 step 1
    _fichier$(boucle)=""
   next boucle
  fileselector$(7)="" : fileselectordata(8)=0
  fileselectordata(9)=1
 endfunction
REM                                             AFFICHE LES FILTRES DANS LA CASE CHOISIE.
function FS_displayfilters()
  _winnum=fileselectordata(13)
  _Windows_Data(_winnum,0)=1
  Rem AFFICHER LE FICHIER CHOISI.
    MW_Ink(_winnum,60,60,60)
    MW_Box(_winnum,55,187,246,197)
    MW_Ink(_winnum,255,255,255)
    MW_Set_Cursor(_winnum,55,186)
  if fileselector$(5)<>"" and fileselector$(6)=""
    MW_Print(_winnum,"*"+fileselector$(5))
   endif
  if fileselector$(5)<>"" and fileselector$(6)<>""
    MW_Print(_winnum,"*"+fileselector$(5)+" / *"+fileselector$(6))
   endif
  if fileselector$(5)="" and fileselector$(6)<>""
    MW_Print(_winnum,"*"+fileselector$(6))
   endif
  if fileselector$(5)="" and fileselector$(6)=""
    MW_Print(_winnum,"*.*")
   endif
 endfunction
Function FS_File_Selector_Display()
  _winnum=fileselectordata(13)
  _Windows_Data(_winnum,0)=1
  MW_Cls(_Winnum,32,32,32)
  MW_Ink(_Winnum,0,0,0)
  MW_Box(_Winnum,63,4,352,15) : Rem Dossier
  MW_Box(_Winnum,22,25,357,152) : Rem Liste des fichiers
  MW_Box(_Winnum,360,39,373,136) : Rem barre à droite
  MW_Box(_Winnum,55,159,247,170) : Rem Fichier choisi
  MW_Box(_Winnum,55,187,247,198) : Rem Filtres
  MW_Box(_Winnum,249,259,328,338) : Rem Thumbail
  MW_Ink(_Winnum,183,183,183)
  MW_Empty_Box(_Winnum,61,2,353,16) : Rem Dossier
  MW_Empty_Box(_Winnum,20,23,358,153) : Rem Liste des fichiers
  MW_Empty_Box(_Winnum,360,39,374,137) : Rem barre à droite
  MW_Empty_Box(_Winnum,53,157,248,171) : Rem Fichier choisi
  MW_Empty_Box(_Winnum,53,185,248,199) : Rem Filtres
  MW_Empty_Box(_Winnum,247,257,329,339) : Rem Thumbail
  MW_Ink(_Winnum,106,106,106)
  MW_Empty_Box(_Winnum,62,3,354,17) : Rem Dossier
  MW_Empty_Box(_Winnum,21,24,359,154) : Rem Liste des fichiers
  MW_Empty_Box(_Winnum,361,40,375,138) : Rem barre à droite
  MW_Empty_Box(_Winnum,54,158,249,172) : Rem Fichier choisi
  MW_Empty_Box(_Winnum,54,186,249,200) : Rem Filtres
  MW_Empty_Box(_Winnum,248,258,330,340) : Rem Thumbail
  Rem Gadgets texte pour la fenêtre.
  MW_Create_Text_Gadget(_Winnum,1,"+",360,23,15,15)
  MW_Create_Text_Gadget(_Winnum,2,"-",360,139,15,15)
  MW_Create_Text_Gadget(_Winnum,3,"Ouvrir",278,157,66,16)
  MW_Create_Text_Gadget(_Winnum,4,"Annuler",278,185,66,16)
  Rem Affichage des textes et commentaires.
  MW_Ink(_Winnum,255,255,255)
  MW_Set_Cursor(_Winnum,11,7) : MW_Print(_Winnum,"Dossier :")
  MW_Set_Cursor(_Winnum,6,161) : MW_Print(_Winnum,"Fichier :")
  MW_Set_Cursor(_Winnum,6,190) : MW_Print(_Winnum,"Type :")
  MW_Set_Cursor(_Winnum,2,247) : MW_Print(_Winnum,"Informations Image :")
  MW_Set_Cursor(_Winnum,2,271) : MW_Print(_Winnum,"Dimension X :")
  MW_Set_Cursor(_Winnum,2,302) : MW_Print(_Winnum,"Dimension Y :")
 EndFunction
Rem
Rem
Rem
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Get_Menu_State() [NEW]                                   Renvoie le nombre correspondant à l'option survolée.
function MW_Get_Menu_State()
  _ACTIF=_Menu_Sys(2)
 EndFunction _ACTIF
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Get_Choosen_Option()                                     Renvoie le nombre correspondant à l'option survolée.
function MW_Get_Choosen_Menu()
  _LASTMENU=_Menu_Sys(4)
 EndFunction _LASTMENU
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Get_Choosen_Option()                                     Renvoie le nombre correspondant à l'option survolée.
Function MW_Get_Choosen_Option()
  _LASTMENU=_Menu_Sys(4) : _LASTOPTION=_Menu_Sys(5)
  if _Menu_State(_LASTMENU,_LASTOPTION)=3 then _LASTOPTION=0
 EndFunction _LASTOPTION
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Check_Menu()                                                       Redéssine le menu à l'écran si nécessaire.
Function MW_Check_Menu()
  if _Menu_Sys(6)>0 and _Menu_sys(1)=1
    xm=mousex() : ym=mousey() : mc=mouseclick()
    xmenu=(xm/128)+1
    _ACTIVE=_Menu_sys(2) : _LASTMENU=_Menu_Sys(4) : _LASTOPTION=_Menu_Sys(5)
     xmin=(_LASTMENU-1)*128
    Rem ON réaffiche de couleur normale la dernière option surlignée.
    Rem Si le menu était en mode TITRE SELECTIONNE.
    if _ACTIVE=1
      if ( xm<xmin or xm>(xmin+127) ) and ym>11
        _ACTIVE=0
        _windows_Sys(34)=1
        if _LASTOPTION>0 then MW_Refresh_Menu_Option(_LASTMENU,_LASTOPTION,1)
        if _LASTMENU>0 then MW_Refresh_Menu_Title(_LASTMENU,1)
        _MENU=0 : _OPTION=0
       else
        ymax=(_Menu_State(xmenu,0)+1)*12
        xpos=(_LASTMENU-1)*128
        if xmenu<_Menu_Sys(3)+1 and ym<ymax
          _OPTION=(ym/12) : _MENU=xmenu
          if _OPTION=0
            if _LASTOPTION>0
              _windows_Sys(34)=1
              MW_Refresh_Menu_Option(_LASTMENU,_LASTOPTION,1)
             Endif
            if _MENU<>_LASTMENU
              _windows_Sys(34)=1
              if _MENU>0 then MW_Refresh_Menu_Title(_MENU,2)
              if _LASTMENU>0 then MW_Refresh_Menu_Title(_LASTMENU,1)
             Endif
           Else
            if _OPTION<>_LASTOPTION
              _windows_Sys(34)=1
              if _OPTION>0 then MW_Refresh_Menu_Option(_MENU,_OPTION,2)
              _windows_Sys(34)=1
              if _LASTOPTION>0 then MW_Refresh_Menu_Option(_LASTMENU,_LASTOPTION,1)
             Endif
           Endif
         Endif
        MW_Show_Title_Bar()
        MW_Show_Menu_Bar(_MENU)
       endif
      if ym>((_Menu_State(xmenu,0)+1)*12)-1
        _ACTIVE=0
        _windows_Sys(34)=1
        if _LASTOPTION>0 then MW_Refresh_Menu_Option(_LASTMENU,_LASTOPTION,1)
        if _LASTMENU>0 then MW_Refresh_Menu_Title(_LASTMENU,1)
        _windows_Sys(34)=1
        if _OPTION>0 then MW_Refresh_Menu_Option(_MENU,_OPTION,1)
        if _MENU>0 then MW_Refresh_Menu_Title(_MENU,1)
        _MENU=0 : _OPTION=0
       endif
     Else
      _MENU=0 : _OPTION=0
      Rem Si la souris est bien placée alors on active le menu choisi.
      if ym<12
Rem        MW_Show_Title_Bar()
        _ACTIVE=1
       else
        if sprite exist(65536-17)=1 then delete sprite 65536-17
       Endif
     Endif
    _Menu_Sys(2)=_ACTIVE
    _Menu_Sys(4)=_MENU : _Menu_Sys(5)=_OPTION
    Rem On stoque les coordonnées des dernièrs options/menus sélectionnés.
   EndIf
 EndFunction _ACTIVE
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Show_Title_Bar() [SYSTEM]                                               Affiche la barre des menus à l'écran.
Function MW_Show_Title_Bar()
  _DBPFlag=_Windows_Sys(31) : _bitmap=_Menu_Sys(6)
  xmax=bitmap width(_bitmap) : xmax2=bitmap width(0)
  if xmax>xmax2 then xmax=xmax2
  Copy Bitmap _bitmap,0,0,xmax-1+_DBPFlag,11+_DBPFlag,0,0,0,xmax-1+_DBPFlag,11+_DBPFlag
 EndFunction
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Show_Menu_Bar() [SYSTEM]                                                   Affiche un menu complet à l'écran.
Function MW_Show_Menu_Bar(menu)
  if _Menu_State(menu,0)>0
    _DBPFlag=_Windows_Sys(31)-1
    XStart=(menu-1)*128 : ymax=(_Menu_State(menu,0)+1)*12 : _bitmap=_Menu_Sys(6)
    if _Windows_sys(22)=0
      Copy Bitmap _bitmap,xstart,11,xstart+128+_DBPFlag,ymax+_DBPFlag,0,xstart,11,xstart+128+_DBPFlag,ymax+_DBPFlag
     else
      set current bitmap _bitmap
      _sprt=65536-17
      if _windows_Sys(34)=1 then get image _sprt,xstart,11,xstart+128+_DBPFlag,ymax+_DBPFlag,_DBPFlag+1
      _windows_Sys(34)=0
      Sprite _sprt,xstart,11,_sprt
     endif
   endif
 EndFunction
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Set_Menu_Title(menu,title$)                                                       Définir le titre d'un menu.
Function MW_Set_Menu_Title(_menu,_name$)
  _Menu_sys(1)=0
  if _menu>0 and _menu<6
    _menu_option$(_menu,0)=_name$ : _Menu_State(_menu,0)=1
   endif
 EndFunction
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Set_Menu_Option(menu,option,title$)                                             Définir une option d'un menu.
Function MW_Set_Menu_Option(_menu,_option,_name$)
  _Menu_sys(1)=0
  if _menu>0 and _menu<6
    if _option>0 and _option<17
      _menu_option$(_menu,_option)=_name$ : _Menu_State(_menu,_option)=1
     endif
   endif
 EndFunction
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Set_Menu_Image(_menu,_option,_image)                                  Définir l'image miniature d'une option.
Function MW_Set_Menu_Image(_menu,_option,_image)
  if _image>0 and _image<65536
    if image exist(_image)=1
      _Menu_Logo(_menu,_option)=_image
     endif
   endif
 EndFunction
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Set_Menu_Transition(menu,option)                                   Définir une option en tant que transition.
Function MW_Set_Menu_Transition(_menu,_option)
  _Menu_sys(1)=0
  _Menu_State(_menu,_option)=3 : _Menu_Logo(_menu,_option)=0 : _menu_option$(_menu,_option)=""
 EndFunction
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Prepare_Menu_v3()                                                         Créer le menu selon les paramètres.
Function MW_Prepare_Menu_v3()
  _Menu_sys(1)=1
  MW_Set_Text_Font_Sys("times new roman")
  MW_Set_text_size_Sys(12)
  MW_Set_Text_Normal_sys()
  MW_Set_Text_Transparent_Sys()
  Rem We look for a free bitmap to store menu graphics.
  if _Menu_Sys(6)=0
    _bitmap=16
    Repeat
      dec _bitmap,1
     until bitmap exist(_bitmap)=0 or _bitmap=0
    if _bitmap>0
      create bitmap _bitmap,bitmap width(0),bitmap height(0)
      _Menu_Sys(6)=_bitmap
     endif
    Set Current Bitmap _bitmap
   Else
    _bitmap=_Menu_Sys(6)
    Set current bitmap _bitmap
    Cls
   Endif
  Rem ON réalise les 5 menus en commençant par les titres . . .
  _Menu_Sys(3)=0 : _DBPFlag=_Windows_Sys(31)
  ink rgb(216,208,200),0
  box 0,0,bitmap width(_bitmap)-1+_DBPFlag,12
  for xmenu=1 to 5
    Rem Si le menu à un titre alors on crée le menu
    if _menu_state(xmenu,0)<>0 then _Menu_Sys(3)=xmenu
    MW_Refresh_Menu_Title(xmenu,1)
    Rem On vérifie le contenu des menus . . .
    for ymenu=1 to 16
      MW_Refresh_Menu_Option(xmenu,ymenu,1)
     next ymenu
   next xmenu
 EndFunction
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Refresh_Menu_Option(xmenu,ymenu,state) [SYSTEM]                              Rafraîchit une option d'un menu.
Function MW_Refresh_Menu_Option(xmenu,ymenu,state)
  set current bitmap _Menu_Sys(6)
  Rem Si le menu contient un texte alors on le crée.
  if _Menu_State(xmenu,ymenu)>0
    _DBPFlag=_Windows_Sys(31)
    xpos=((xmenu-1)*128)+64 : xm=(xmenu-1)*128 : ym=(ymenu)*12
    Rem On affiche le contenu de la boite de menu.
    if state=1 or _Menu_State(xmenu,ymenu)=3 then ink rgb(216,208,200),0 else ink rgb(0,36,104),0
    box xm,ym,xm+127 + _DBPFlag,ym+11 + _DBPFlag
    Rem Si le menu n'est pas une transition et qu'il possède un THUMBAIL , on l'affiche.
    if _Menu_State(xmenu,ymenu)<3
      Rem Affichage de l'image
      _img=_Menu_Logo(xmenu,ymenu)
      if _img>0 then If Image exist(_img)=1 then paste image _img,xm+1,ym
     Else
      Rem Affichage de la transition . . .
      Ink rgb(128,128,128),0 : line xm+4,ym+5,xm+124,ym+5
      Ink rgb(255,255,255),0 : line xm+4,ym+6,xm+124,ym+6
     Endif
    if ymenu=1
      ink rgb(255,255,255),0 : line xm,ym,xm+127+_DBPFlag,ym
     Endif
    Rem On affiche alors le contour du menu
    ink rgb(255,255,255),0 : line xm,ym,xm,ym+11+_DBPFlag
    if state=1 then ink 0,0 else ink rgb(255,255,255),0
    MW_Set_Text_Transparent_Sys()
    _texte$ = _menu_option$(xmenu,ymenu)
    Text xm+18 , ym , _texte$
    ink rgb(128,128,128),0 : line xm+127,ym,xm+127,ym+11+_DBPFlag
    Rem Si le menu suivant ne contient rien alors on affiche la barre sombre du bas.
    if _Menu_State(xmenu,ymenu+1)=0 and _Menu_State(xmenu,ymenu)<>0
      _Menu_State(xmenu,0)=ymenu
      line xm+127,ym,xm+127,ym+11 : line xm+127,ym+11,xm,ym+11
     endif
   Endif
  _windows_Sys(34)=1
 EndFunction
Rem ------------------------------------------------------------------------------------- MENU SYSTEM --------------
Rem MW_Refresh_Menu_Title(xmenu,state) [SYSTEM]                                          Rafraîchit 1 titre de menu.
Function MW_Refresh_Menu_Title(xmenu,state)
  _DBPFlag=_Windows_Sys(31)
  if xmenu>_Menu_Sys(3) then state=1
  set current bitmap _Menu_Sys(6)
  xm=(xmenu-1)*128
  Rem Affichage du titre du menu
  if state=1 then ink rgb(216,208,200),0 else ink rgb(0,36,104),0
  box xm,0,xm+127+_DBPFlag,11+_DBPFlag
  if state=1 then ink 0,0 else ink rgb(255,255,255),0
  MW_Set_Text_Transparent_Sys()
  _texte$ = _menu_option$(xmenu,0)
  Text xm+2,0,_texte$
 EndFunction
Rem
Rem
Rem
Rem ------------------------------------------------------------------------ 3DMAPEDITOR SPECIAL FUNCTIONS ---------
Rem MW_Save_Default_Positions() [NEW]                   Sauvegarde les dernières positions des fenêtres sur fichier.
Function MW_Save_Default_Positions()
  mw_config$=get dir$()+"\tiles\mw_config.dat"
  Rem On efface le fichier sauvegarde si il existe.
  if file exist(mw_config$)=1 then delete file mw_config$
  Rem On sauvegarde les positions.
  open to write 1,mw_config$
  write string 1,"Magic-Windows Configuration File Ver1.3"
  for boucle=1 to 24 step 1
    write word 1,_Windows_Default(boucle,1)
    write word 1,_Windows_Default(boucle,2)
   next boucle
  write string 1,"end_of_cfg"
  close file 1
    sync
 EndFunction
Rem ------------------------------------------------------------------------ 3DMAPEDITOR SPECIAL FUNCTIONS ---------
Rem MW_Load_Default_Positions() [NEW]             Charge les dernières positions des fenêtres à partir d'un fichier.
Function MW_Load_Default_Positions()
  mw_config$=get dir$()+"\tiles\mw_config.dat"
  Rem si la sauvegarde existe , on la charge.
  if file exist(mw_config$)=1
    Rem On sauvegarde les positions.
    open to read 1,mw_config$
    read string 1,_s$
    for boucle=1 to 24 step 1
      read word 1,_Windows_Default(boucle,1)
      read word 1,_Windows_Default(boucle,2)
     next boucle
    read string 1,_s$
    close file 1
    sync
   endif
 endfunction
Rem
Rem
Rem
Rem
Rem ----------------------------------------------------------------------------------------------------------------
Rem
REMSTART
  Tiles Order :
`    #00 : top_left     #03 : Close_Gadget     #06 : Back_Gadget
`    #01 : top          #04 : Resize_Gadget    #07 : ...
`    #02 : top_right    #05 : Front_Gadget     #08 : ...

Windows gadgets data : xx=window number(1-16) , yy=gadget number(1,32)
    _Windows_Gadget(xx,yy,1) : Type de gadget ( =1 graphique , =2 texte , =3 direct IMAGE )
    _Windows_Gadget(xx,yy,2) : Image ou graphique à utiliser pour le gadget.
    _Windows_Gadget(xx,yy,3) : Gadget actif ?
    _Windows_Gadget(xx,yy,4) : Gadget x position.
    _Windows_Gadget(xx,yy,5) : Gadget y position.
    _Windows_Gadget(xx,yy,6) : Gadget x size.
    _Windows_Gadget(xx,yy,7) : Gadget y size.
    _Windows_Gadget(xx,yy,8) : Image Alternée graphique à utiliser.
    _Windows_Gadget_Text$(xx,yy) : Text à mettre dans le gadget si c'est un gadget texte.

  _Windows_sys(xx) values :
    _Windows_sys(1)=First tile image
    _Windows_Sys(2)=Last tile image
    _Windows_Sys(3)=Refresh windows when trace to screen.
    _Windows_Sys(4)=Nombre de fenêtres existantes.
    _Windows_Sys(5)=old x mouse
    _Windows_Sys(6)=old y mouse
    _Windows_Sys(7)=Last active gadget
    _Windows_Sys(8)=Last active window
    _Windows_Sys(9)=Second Gadget value checking.
    _Windows_sys(10)=Second window value checking
    _Windows_Sys(11)=Real Time Windows move enabled ?
    _Windows_Sys(12)=Real Time Windows Scaling enabled ?
    _Windows_Sys(13)=Real Time Windows drawing priority enabled ?
    _Windows_Sys(14)=Initialisation
    _Windows_Sys(15)=Refresh Gadgets when trace to screen.
    _Windows_Sys(16)=XWin Temp
    _Windows_Sys(17)=YWin Temp
    _Windows_Sys(18)=Current Windows
    _Windows_Sys(19)=Current Gadget
    _Windows_Sys(20)=AutoClsMode
    _Windows_Sys(21)=RefreshBackGround Mode
    _windows_sys(22)=Display mode ( 0=CopyBitmap/Paste , 1=Sprites )
    _Windows_sys(23)=1 if MW_Background_Task() was called . MW_sync(x) set it to 0.
    _Windows_sys(24)=Texture mode ( 0=System Ram , 1=VideoRam , 2=Compressed )
    _Windows_sys(25)=Affichage du titre actif (=1) ou inactif (=0)
    _Windows_Sys(26)=Last used font size
    _Windows_Sys(27)=Last Text Style Used ( 0=normal 1=italic 2=bold 3=italicbold )
    _Windows_Sys(28)=Text de type transparent ou opaque.
    _Windows_Sys(29)=Default Mouse cursor
    _Windows_Sys(30)=Auto Windows Position save
    _Windows_Sys(31)=DBPro Mode Flag ( 1=DBPro 0=DBv1 )
    _Windows_Sys(32)=Window movement active
    _Windows_Sys(33)=Tracé du contour des fenêtres ou pas . . .


  _Windows_Data(xx,yy) : xx=window number(1-16)
    _Windows_Data(xx,01) : La fenetre existe ou pas
    _Windows_Data(xx,02) : position X
    _Windows_Data(xx,03) : position Y
    _Windows_Data(xx,04) : dimension X
    _Windows_Data(xx,05) : dimension Y
    _Windows_Data(xx,06) : Close_Gadget Actif ?
    _Windows_Data(xx,07) : Resize_Gadget Actif ?
    _Windows_Data(xx,08) : Front_Gadget & Back_Gadget Actifs ?
    _Windows_Data(xx,09) : RGB Red value    \
    _Windows_Data(xx,10) : RGB Green value   > ink for BGD default color
    _Windows_Data(xx,11) : RGB Blue value   /
    _Windows_Data(xx,12) : Cursor X position
    _Windows_Data(xx,13) : Cursor Y position
    _Windows_Data(xx,14) : RGB Red value   \
    _Windows_Data(xx,15) : RGB Green value  > ink for text
    _Windows_Data(xx,16) : RGB Blue value  /
    _Windows_Data(xx,17) : Font Size
    _Windows_Data(xx,18) : RGB Red value   \
    _Windows_Data(xx,19) : RGB Green value  > ink for border , lighest values
    _Windows_Data(xx,20) : RGB Blue value  /
    _Windows_Data(xx,21) : RGB Red value   \
    _Windows_Data(xx,22) : RGB Green value  > ink for border , darkest values
    _Windows_Data(xx,23) : RGB Blue value  /
    _Windows_Data(xx,24) : Title Bar active ?
    _Windows_Data(xx,25) : Window border Actif ?
    _Windows_Data(xx,26) : Use Alpha channel for transparent sprites .
    _Windows_Data(xx,27) : Text Format ( 0=Normal , 1=Italic , 2=Bold , 3=Italic+Bold )
    _Windows_Data(xx,28) : Text Opaque (=0) or transparent (=1)

  Messages d'erreur :
     -1 : Les valeurs entrées pour la fenêtre sont invalides.
     -2 : La fenêtre demandée existe deja.
     -3 : Le bitmap nécessaire à la fabrication de la fenêtre est deja utilisé !
     -4 : La fenêtre demandée n'existe pas.
     -5 : Le fichier contenant les données pour les graphiques n'a pas pu être chargé !
     -6 : Les coordonnées demandées sortent de la fenêtre
     -7 : Le bitmap demandé n'existe pas.
     -8 : Le bouton existe deja.
     -9 : Le bouton demandé n'existe pas.

  Valeurs des gadgets systèmes aux fenêtres :
     -1 : Close window gadget
     -2 : title bar
     -3 : window to front gadget
     -4 : window to back gadget
     -5 : resize gadget
     -6 : MESSAGE D'ERREUR : La fenêtre spécifiée n'existe pas.

REMEND
